## OOD

[1. Что такое ООД? Какие задачи выполняет ООД?](#1-Что-такое-ООД-Какие-задачи-выполняет-ООД)

[2. Расскажите о принципах KISS, DRY, YAGNI?](#2-Расскажите-о-принципах-KISS-DRY-YAGNI)

[3. Что такое SOLID?](#3-Что-такое-SOLID)

[4. Для чего используются JavaDoc?](#4-Для-чего-используются-JavaDoc)

[5. Как писать JavaDoc? Опишите основные теги @param, @return, @throws](#5-Как-писать-JavaDoc-Опишите-основные-теги-@param-@return-@throws)

[6. Расскажите про принципы составления Java класса?](#6-Расскажите-про-принципы-составления-Java-класса)

[7. Что такое SRP?](#7-Что-такое-SRP)

[8. Расскажите о нарушениях принципа SRP?](#8-Расскажите-о-нарушениях-принципа-SRP)

[9. Последствия нарушения SRP?](#9-Последствия-нарушения-SRP)

[10. Что такое OCP?](#10-Что-такое-OCP)

[11. Расскажите о нарушениях принципа OCP?](#11-Расскажите-о-нарушениях-принципа-OCP)

[12. Последствия нарушения OCP?](#12-Последствия-нарушения-OCP)

[13. Что такое LSP?](#13-Что-такое-LSP)

[14. Расскажите о нарушениях принципа LSP?](#14-Расскажите-о-нарушениях-принципа-LSP)

[15. Последствия нарушения LSP?](#15-Последствия-нарушения-LSP)

[16. Что такое ISP?](#16-Что-такое-ISP)

[17. Расскажите о нарушениях принципа ISP?](#17-Расскажите-о-нарушениях-принципа-ISP)

[18. Последствия нарушения ISP?](#18-Последствия-нарушения-ISP)

[19. Что такое DIP?](#19-Что-такое-DIP)

[20. Расскажите о нарушениях принципа DIP?](#20-Расскажите-о-нарушениях-принципа-DIP)

[21. Последствия нарушения DIP?](#21-Последствия-нарушения-DIP)

[22. Расскажите что такое автоматическое тестирование?](#22-Расскажите-что-такое-автоматическое-тестирование)

[23. Как в Java осуществляется автоматическое тестирование?](#23-Как-в-Java-осуществляется-автоматическое-тестирование)

[24. Что такое JUnit и как используется для тестирования?](#24-Что-такое-JUnit-и-как-используется-для-тестирования)

[25. Что такое функциональное тестирование и чем отличается от модульного?](#25-Что-такое-функциональное-тестирование-и-чем-отличается-от-модульного)

[26. Расскажите про принцип TDD?](#26-Расскажите-про-принцип-TDD)

[27. Расскажите про принцип BDD?](#27-Расскажите-про-принцип-BDD)

[28. Что такое тестирование черным ящиком?](#28-Что-такое-тестирование-черным-ящиком)

[29. Опишите типы тестов: модульное, интеграционное, функциональное, приемочное?](#29-Опишите-типы-тестов-модульное-интеграционное-функциональное-приемочное)


[6. Что такое Java code convention?](#6-Что-такое-Java-code-convention)

## 1. Что такое ООД? Какие задачи выполняет ООД?

https://habr.com/ru/articles/531466/

ООД - это подход к разработке программного обеспечения, который заключается в проектировании системы взаимодействующих объектов с целью решения какой-либо задачи. По-другому ООД еще называют объектно-ориентированным проектированием.

ООД заключается в правильном определении взаимодействия объектов между собой. Сами доменные модели выделяются на стадии ООА. Далее при проектировании приложения, то есть при разработке схемы взаимодействия объектов между собой, применяются принципы ООД.

Цель ООД - создание структуры, которую можно будет легко поддерживать и обслуживать, то есть при необходимости менять существующие реализации или добавлять новые. Это достигается путём грамотного определения взаимодействия объектов друг с другом и сокрытия деталей их реализаций о пользователя.

Правильное проектирование приложения помогает не только сделать корректную структуру самого приложения, чтобы его можно было поддерживать и расширять, но и даёт понять всем членам команды на проекте как будет работать это приложение. То есть слово дизайн здесь подразумевает не внешний вид, а именно структуру приложения - как будут объекты взаимодействовать друг с другом. Еще не имея полной реализации уже можно будет многое понять по выделенным объектам и построенной структуре приложения. 
 
Чтобы создавать качественные приложения с легкорасширяемой структурой недостаточно просто знать принципы ООП - наследование, инкапсуляция, полиморфизм, абстракция. Нужны еще знания о проектировании самого приложения, например, знание шаблонов проектирования, а также знание принципов ООД, которые мы будем проходить в этом разделе.

[к оглавлению](#OOD)


## 2. Расскажите о принципах KISS, DRY, YAGNI?

https://job4j.ru/profile/exercise/63/task-view/379

https://habr.com/ru/companies/itelma/articles/546372/

**KISS** - keep it simple and short. Код должен быть простым и коротким.

Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.

Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.

Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.

**DRY** - don't repeat yourselft. Дословно "не повторяй себя". Противоположность этому принципу - copypaste. То есть, старайтесь использовать уже существующие методы, чтобы решить новую задачу. Не копируйте код.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.

**YAGNI** - You aren't gonna need it. Принцип пересекается со втором. Подумайте, стоит ли создавать новый метод. Можно ли решить задачу уже существующими методами.

Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.

Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.

Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.

[к оглавлению](#OOD)

## 3. Что такое SOLID?

https://job4j.ru/profile/exercise/64/task-view/382

https://habr.com/ru/companies/ruvds/articles/426413/

https://habr.com/ru/articles/348286/

SOLID всегда упоминают в контексте ООП. Так получилось, что именно в ООП языках появилась удобная и безопасная поддержка динамического полиморфизма. Фактически, в контексте SOLID под ООП понимается именно динамический полиморфизм.

Полиморфизм дает возможность для разных типов использовать один код.
Полиморфизм можно грубо разделить на динамический и статический.

- Динамический полиморфизм — это про абстрактные классы, интерфейсы, утиную типизацию, т.е. только в рантайме будет понятно, с каким типом будет работать наш код.
- Статический полиморфизм — это в основном про шаблоны (genererics). Когда уже на этапе компиляции из одного шаблонного кода генерируется код специфичный для каждого используемого типа.


нужно отметить две вещи:

- Принципы между собой связаны, поэтому понимание отдельно взятого принципа зависит от комплексного понимания всех принципов
- Принципы SOLID базируются на основных принципах ООП. Возможно, вы встречали, что в некоторых источниках выделяют такой принцип как абстракция. Без выделения абстракций невозможно воспринимать принципы SOLID. Программными абстракциями являются интерфейсы и абстрактные классы. Если косвенно это соотнести с принципом SRP, то интерфейсы и абстрактные классы должны отвечать за абстракцию, а реализации должны уже отвечать за представление этих абстракций. Также это основа для соблюдения принципа OCP, о котором мы поговорим потом.

**SOLID (single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion)** - 
акроним пяти основных принципов дизайна классов в объектно-ориентированном проектировании. 
При создании программных систем использование принципов SOLID способствует созданию такой системы, 
которую будет легко поддерживать и расширять в течение долгого времени 

SOLID принципы советуют, как проектировать модули, т.е. кирпичики, из которых строится приложение. 
Цель принципов — проектировать модули, которые:

+ терпимы к изменениям
+ легко понимаемы
+ повторно используемы

Принципы SOLID:  
+ подходят для проектов, разрабатываемых по гибким методологиям, ведь Роберт Мартин — один из авторов Agile Manifesto.
+ стремятся свести изменение модулей к их добавлению и удалению.
+ способствуют откладыванию принятия технических решений и разделению труда программистов.

[к оглавлению](#OOD)

## 4. Для чего используются JavaDoc?

https://job4j.ru/profile/exercise/31/task-view/232

**Javadoc** — генератор документации в HTML-формате из комментариев исходного кода на Java.
Javadoc также предоставляет API для создания доклетов и тэглетов, которые позволяют программисту анализировать структуру Java-приложения.
В каждом случае комментарий должен находиться перед документируемым элементом.
@author, @version, @since

Многие IDE также используют Javadocs для генерации контекстных описаний API.
- --------

О качестве кода, который пишет программист говорит не только его "чистота", но и наличие документации к написанному коду. Если документация и код разделены, то могут появиться проблемы, которые связанны с необходимостью внесения изменений в соответствующие разделы сопроводительной документации при изменении программного кода.

Все существующие среды разработки IDE приложений на языке Java предоставляют инструмент по связыванию кода с документацией в процессе разработки с использованием JavaDoc. Чтобы пользоваться этой возможностью просто необходимо соответствующим образом написать комментарий к коду. Поэтому комментарии к коду нужны не только для простого его комментирования, но и для составления и оформления документации.

Разработан специальный синтаксис для оформления документации в виде комментариев и **инструмент для создания** из комментариев **документации**. Таким инструментом является JavaDoc, который обрабатывает файл с исходным кодом, выделяет помеченную документацию из комментариев и связывает с именами соответствующих классов, методов и полей. Таким образом, приложив минимальные усилия для создания комментариев к коду, можно получить качественную документацию к программе.

JavaDoc - это генератор документации в HTML-формате из комментариев исходного кода Java. Для создания элементов, которые позволят программисту анализировать структуру приложения, JavaDoc предоставляет API. При этом комментарий должен находиться перед документируемым элементом.

[к оглавлению](#OOD)

## 5. Как писать JavaDoc? Опишите основные теги @param, @return, @throws

Утилита javadoc позволяет вставлять HTML тэги и использовать специальные ярлыки (дескрипторы) документирования. 
НТМL тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой.
Дескрипторы javadoc, начинающиеся со знака @, называются автономными и должны помещаться с начала строки комментария (лидирующий символ * игнорируется). 
Дескрипторы, начинающиеся с фигурной скобки, например {@code}, называются встроенными и могут применяться внутри описания.

Комментарии документации применяют для документирования классов, интерфейсов, полей (переменных), конструкторов и методов. 
В каждом случае комментарий должен находиться перед документируемым элементом.

Документирование класса, метода или переменной начинается с комбинации символов /** , после которого следует тело комментариев; заканчивается комбинацией символов */.
В тело комментариев можно вставлять различные дескрипторы. Каждый дескриптор, начинающийся с символа '@' должен стоять первым в строке. 
Несколько дескрипторов одного и того же типа необходимо группировать вместе. 
Встроенные дескрипторы (начинаются с фигурной скобки) можно помещать внутри любого описания.

```java
/** 
 * Класс продукции со свойствами <b>maker</b> и <b>price</b>.
 * @autor Киса Воробьянинов
 * @version 2.1
*/
class Product {
    /**
     * Поле производитель 
     */
    private String maker;
     
    /** 
     * Поле цена 
     */ 
    public double price;
    
    /** 
     * Конструктор - создание нового объекта
     * @see Product#Product(String, double)
     */
    Product() {
        setMaker("");
        price=0;
    }
    
    /** 
     * Конструктор - создание нового объекта с определенными значениями
     * @param maker - производитель
     * @param price - цена
     * @see Product#Product()
     */
    Product (String maker, double price) {
        this.setMaker(maker);
        this.price=price;
    }
    
    /**
     * Функция получения значения поля {@link Product#maker}
     * @return возвращает название производителя
     */
    public String getMaker() {
        return maker;
    }
    
    /**
     * Процедура определения производителя {@link Product#maker}
     * @param maker - производитель
     */
    public void setMaker(String maker) {
        this.maker = maker;
    }
}
```

- -------------------

Важная особенность JavaDoc комментариев, что в отличие от комментариев с которыми мы сталкивались ранее, в данном случае комментарии помещаются в такую конструкцию:

/** комментирование документации */

т.е. в начале у нас идет две **, а не одна как ранее (одна * - это просто многострочный комментарий в коде).

С помощью утилиты JavaDoc, которая входит в состав JDK, комментарий документации можно извлекать и помещать в HTML файл. Утилита JavaDoc позволяет вставлять HTML тэги и использовать специальные ярлыки (дескрипторы) документирования. HTML тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой.

Есть 2 типа дескрипторов:

1. **Автономные** - они начинаются со знака @ и должны помещаться с начала строки комментария;

2. **Встроенные** - начинаются с фигурной скобки и могут применяться внутри описания.

Комментарии документации применяют для документирования классов, интерфейсов, полей (переменных), конструкторов и методов. В каждом случае комментарий должен находиться перед документируемым элементом.

Давайте познакомимся с описанием основных дескрипторов, которые Вы будете применять, разделив их на три категории:

1. Применяются только для **_классов_** или **_интерфейсов_**:

- @author - указывается имя автора;

- @version - указывается версия нашего класса. Не более одного дескриптора на класс.

2. Применяются только для **_методов_**:

- @param - приводится описание входного параметра описываемого метода;

- @return - описывается возвращаемое значение документируемого метода;

- @exception имя_класса_исключения - приводится описание исключения, которое может бросить описываемый метод.

- - @throws - Обозначает исключение, генерируемое методом (то же самое что @exception)

3. Применяются для **_классов, интерфейсов, полей и методов_**:

- @since - указывается с какой версии доступен документируемый элемент;

- @see - тут можно указать ссылку на другое место в документации;

- @deprecated - описываются устаревшие блоки кода;

{@link reference} - можно указать ссылку на другой класс, метод и прочее.

Комментарии могут быть очень большими - но так делать не стоит, главное изложить суть - для чего нужно, что делает и какой результат мы получим, если будем использовать этот код.

[к оглавлению](#OOD)

## 6. Расскажите про принципы составления Java класса?

Отмеим, что:

- Принципы между собой связаны, поэтому понимание отдельно взятого принципа зависит от комплексного понимания всех принципов
- Принципы SOLID базируются на основных принципах ООП. Возможно, вы встречали, что в некоторых источниках выделяют такой принцип как абстракция. Без выделения абстракций невозможно воспринимать принципы SOLID. Программными абстракциями являются интерфейсы и абстрактные классы. Если косвенно это соотнести с принципом SRP, то интерфейсы и абстрактные классы должны отвечать за абстракцию, а реализации должны уже отвечать за представление этих абстракций. Также это основа для соблюдения принципа OCP, о котором мы поговорим потом.

+ **SRP (Single Responsibility Principle)** - программная сущность (класс, пакет, модуль) должна иметь только одну ответственность. В некоторых источниках можно встретить такую трактовку: класс должен иметь только одну причину для изменения.

+ **OCP (Open/Closed Principle)** – принцип открытости/закрытости, утверждающий, что программы должны быть открыты для расширения, но закрыты для изменения. *программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, 
но закрыты для изменения.*
Простая для изменения система должна предусматривать простую возможность изменения ее поведения добавлением нового, 
но не изменением существующего кода.

+ **LSP (Liskov Substitution Principle)** - принцип подстановки Барбары Лисков, требующий, чтобы объекты в программе могли быть заменены на их подтипы без изменения корректности программы. *объекты в программе можно заменить их наследниками без изменения свойств программы.*

+ **ISP (Interface Segregation Principle)** - принцип разделения интерфейса, согласно которому чем меньше методов и свойств описывает интерфейс, тем проще его использовать и изменять. *клиенты не должны реализовывать методы, 
которые они не будут использовать.* Этот принцип призывает разработчиков программного обеспечения избегать зависимости от всего, что не используется. **Программные сущности не должны зависеть от методов, которые они не используют.**

+ **DIP (Dependency Inversion Principle)** - принцип инверсии зависимости, который предлагает перевернуть зависимости между высокоуровневыми и низкоуровневыми абстракциями, чтобы уменьшить связанность и улучшить модульность системы. *зависимости внутри системы строятся на основе абстракций, а не конкретных реализаций.*

Данный принцип гласит:

- Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Проще говоря, используемые сущности в вашем коде должны быть абстракциями, т.е. не должно быть прямой зависимости от реализации.

Это касается:

- полей классов
- возвращаемых значений методов
- аргументов методов и конструкторов
- создаваемых объектов (вспомните пример из урока про SRP)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/solid.png)

[к оглавлению](#OOD)

## 7. Что такое SRP?

https://job4j.ru/profile/exercise/64/task-view/382

Данный принцип гласит: программная сущность (класс, пакет, модуль) должна иметь только одну ответственность. В некоторых источниках можно встретить такую трактовку: класс должен иметь только одну причину для изменения. Хотя скорее второе это следствие из первого.

SRP — это принцип, объясняющий КАК декомпозировать, то есть где провести линию разделения. Он говорит, что декомпозировать надо по принципу разделения "ответственности", то есть по задачам тех или иных объектов.

SRP — Принцип единой изменчивости. Это определение гласит, что "У модуля есть один и только один повод для изменения". То есть "Ответственность — это повод для изменения".

"Схожие для изменения вещи должны храниться в одном месте". или “То, что изменяется вместе, должно храниться в одном месте”

То есть, если мы меняем логировку операции, то мы должны это менять в одном месте.

Это очень важный момент — так как все объяснения SRP, которые были выше, говорили о том, что надо дробить типы, пока они дробятся, то есть накладывало "ограничение сверху" на размер объекта, а теперь мы говорим уже и об "ограничении снизу". Иными словами, SRP не только требует "дробить пока дробится", но и не перестараться — "не раздробить сцепленные вещи". Не усложнять без надобности.

**Формализм 1. Определение SRP**

- Разделяйте элементы так, чтобы каждый из них был ответственен за что-то одно.
- Ответственность расшифровывается как "повод для изменения". То есть каждый элемент имеет только один повод для изменения, в терминах бизнес логики.
- Потенциальные изменения бизнес логики. должны быть локализованы. Изменяемые вместе элементы должны быть рядом.

**Формализм 2. Необходимые критерии самопроверки.**

1) Задайте себе вопрос — что делает этот класс/метод/модуль/сервис. вы должны ответить на него простым определением.

2) Фикс некоторого бага или добавление новой фичи затрагивает минимальное количество файлов/классов. В идеале — один.

3) Если несколько разработчиков работают над разными фичами вашего проекта, то вероятность мердж -конфликта, то есть вероятность того, что один и тот же файл/класс будет изменен у нескольких разработчиков одновременно — минимальна.

4) При уточняющем вопросе про бизнес логику (от разработчика или менеджера) вы лезете строго в один класс/файл и получаете информацию только от туда.

**Формализм 3. Методика разработки "Оккама-first".**

- Сделать слишком большие объекты, склеив разные ответственности
- Передробить, разделив единую ответственность на много разных типов
- Неверно определить границы ответственности

Важно запомнить правило: "ошибаться лучше в большую сторону", или "не уверены — не дробите". Если, например, ваш класс собирает в себе две ответственности — то он по прежнему понятен и его можно распилить на два с минимальным изменением клиентского кода. Собирать же из осколков стекла стакан, как правило, сложнее из-за размазанного по нескольким файлам контекста и отсутствия необходимых зависимостей в клиентском коде.

- ---
A module should be responsible to one, and only one, actor *(Модуль должен отвечать за одного и только за одного актора)*.

Старая формулировка: A module should have one, and only one, reason to change (Модуль должен иметь одну и только одну причину для изменения).

Часто ее трактовали следующим образом: Модуль должен иметь только одну обязанность. И это главное заблуждение при знакомстве с принципами. Все несколько хитрее.

На каждом проекте люди играют разные роли (actor): Аналитик, Проектировщик интерфейсов, Администратор баз данных. 
Естественно, один человек может играть сразу несколько ролей. В этом принципе речь идет о том, 
что ***изменения в модуле может запрашивать одна и только одна роль***. Например, есть модуль, 
реализующий некую бизнес-логику, запросить изменения в этом модуле может только Аналитик, но никак не DBA или UX.

[к оглавлению](#OOD)

## 8. Расскажите о нарушениях принципа SRP?

https://job4j.ru/profile/exercise/64/task-view/382

Таким образом сделаем вывод. Чтобы не нарушить данный принцип, нужно:

1. Обращать внимание на функционал, предоставляемый классом. У класса должна быть только одна цель.

2. Обращать внимание на создаваемые объекты. Если класс умеет их создавать и инициализировать, то это скорее всего нарушает принцип SRP

3. Обращать внимание на используемые операции, которые используются без зависимости. Как в случае с генератором. Это могут быть неявные преобразования. Здесь антипаттерном служат статические библиотеки, не предоставляющие стандарт языка. Например, вы выводите дату в определенном формате, преобразование в формат есть преобразование, которое может поменяться. В качестве примера можно также привести проверку условий, диктуемых извне. Например, поиск по файловой системе должен быть по предикату.

- ------------------------

**Пример 1. Чистая архитекура Р.Мартин 2017**

Например, класс Employee из приложения платежной ведомости имеет три метода: calculatePay(), reportHours() и save()

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/srp1.png)

Этот класс нарушает принцип единственной ответственности, потому что три его метода отвечают за три разные роли.
+ Реализация метода calculatePay() определяется бухгалтерией.
+ Реализация метода reportHours() определяется и используется отделом по работе с персоналом.
+ Реализация метода save() определяется администраторами баз данных.

Поместив исходный код этих трех методов в общий класс Employee, разработчики объединили перечисленные роли. 
В результате такого объединения действия сотрудников бухгалтерии могут затронуть что-то, что требуется сотрудникам 
отдела по работе с персоналом.
Допустим, функции calculatePay() и reportHours() используют общий алгоритм расчета не сверхурочных часов. 
Разработчики, старающиеся не дублировать код, поместили реализацию этого алгоритма в функцию 
с именем regularHours()

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/srp2.png)

Допустим, сотрудники бухгалтерии решили изменить алгоритм расчета не сверхурочных часов. 
Сотрудники отдела кадров были бы против такого изменения, т.к. вычисленное время они используют для других целей.

Разработчик, внесящий это изменение, заметил, что функция regularHours() вызывается 
методом calculatePay(), но не заметил, что она также вызывается методом reportHours().
Он внес требуемые изменения и протестировал результат. Сотрудники бухгалтерии проверили и 
подтвердили, что обновленная функция работает верно, после чего измененная версия 
системы была развернута.

Сотрудники отдела кадров не знали этого и продолжали использовать отчеты, генерируемые функцией reportHours(), 
но теперь содержащие неправильные цифры. В какой-то момент проблема вскрылась, 
и выяснилось, что ошибочные данные обошлись бюджету фирмы в несколько миллионов.

Эти проблемы возникают из-за того, что мы вводим в работу код, от которого зависят разные роли. 
Принцип единственной ответственности требует разделять код, от которого зависят разные роли.

Существует несколько решений этой проблемы. Но каждое связано с перемещением функций в разные классы.

Наиболее очевидное решение - отделить данные от функций. 
Три класса используют общие данные EmployeeData — простую структуру без методов.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/srp3.png)

Каждый класс включает только исходный код для конкретной функции. Эти три класса никак не зависят друг от друга. 
То есть любое непреднамеренное дублирование исключено.

Недостаток такого решения — разработчик теперь должен создавать экземпляры трех классов и следить за ними. 

Эта проблема часто решается применением шаблона проектирования «Фасад» (Facade), как показано на рис.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/srp4.png)

Класс EmployeeFacade компактный и отвечает за создание экземпляров трех классов и делегирование вызовов методов.

**Пример 2.**

Представьте себе модуль, который обрабатывает заказы. 
Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа:
```java
public class OrderProcessor {

    public void process(Order order){
        if (order.isValid() && save(order)) {
            sendConfirmationEmail(order);
        }
    }

    private boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }

    private void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}
```
Такой модуль может измениться по трем причинам:
1. может стать другой логика обработки заказа, 
2. может измениться способ его сохранения (тип базы данных), 
3. может измениться способ отправки письма подтверждения (вместо email нужно отправлять SMS).

Принцип SRP подразумевает, что три аспекта этой проблемы на самом деле — три разные обязанности. 
А значит, они должны находиться в разных классах или модулях. 
Объединение нескольких сущностей, которые могут меняться в разное время и по разным причинам, плохое проектное решение.

Правильнее разделить модуль на три отдельных, каждый из которых будет выполнять одну единственную функцию:
```java
public class MySQLOrderRepository {
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }
}

public class ConfirmationEmailSender {
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}

public class OrderProcessor {
    public void process(Order order){

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }

}
```
[Еще примеры](https://blog.byndyu.ru/2009/10/blog-post.html)

- -----------


[к оглавлению](#OOD)

## 9. Последствия нарушения SRP?

Поскольку все принципы связаны друг с другом

В этом проявляется связь с принципом DIP – ваши классы должны зависеть от абстракций, а не от реализаций. 

Также здесь есть зависимость с принципом OCP – по факту сам код генератора не расширяемый, мы можем лишь создать новые реализации, а это расширение относится к контексту, где будет применяться генератор последовательности, но не к самому генератору.  

--------------------------

Что является причиной изменения логики работы класса? 
Изменение отношений между классами, введение новых требований или отмена старых. 

Если изменения в модуле могут запрашивать несколько ролей, то и меняться он будет часто. 
А это ведет ***к хрупкости дизайна и ошибкам в неожиданных местах при изменениях кода***.

[к оглавлению](#OOD)

## 10. Что такое OCP?

https://job4j.ru/profile/exercise/65/task-view/384

OCP – Open Closed Principle. Данный принцип гласит, что программные сущности должны быть открыты к расширению, но закрыты к изменению.

**Почему так важен факт изменения?**

1) Изменение программы может привести к ее некорректной работе. Если программа маленькая, то продебажить ее не трудно, но если в ней много кода, то это будет сделать затруднительно, поэтому становится актуальным ее расширение, а не изменение.

2) Программы со временем меняются. Меняются требования. Выходят новые версии. Все это делается за счет возможности гибкого расширения программы.    

**Контекст расширения**

Говоря о расширении важно отметить контекст, в котором мы говорим о нем. В примере выше мы говорим об отдельно взятом внутреннем классе, а именно о внутреннем устройстве этих классов.

К примеру, кто-то может сказать: первый класс мы можем тоже расширить, например через наследование. Но тут уже другой контекст – контекст, в котором будет применяться сам класс. А это уже совсем другое. Не путайте контекст.

**Механизмы расширения**

Расширение, как правило, достигается созданием новых сущностей. Тут мы ярко можем увидеть полиморфизм. Таким образом, расширение достигается за счет полиморфизма. А за счет чего достигается полиморфизм?

_Наследование_

_Интерфейсы и их реализация_

**Вывод**, наследование можно использовать только при устойчивой иерархии классов, всегда подставляйте «is A» между сущностями, чтобы проверить можно ли наследоваться. Если не уверены, то лучше использовать интерфейсы, потому что они дают гибкость. Также помните, что при наследовании наследуется состояние объектов, что не всегда удобно, нужно и допустимо. 


- --------------------------

A software artifact should be open for extension but closed for modification *(Программный артефакт должен быть открыт для расширения, но закрыт для модификации.)*.

Старая формулировка: You should be able to extend a classes behavior, without modifying it (Вы должны иметь возможность расширять поведение классов, не изменяя его).

Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения.
Это означает, что такие сущности могут позволять менять свое поведение без изменения их исходного кода.

Принцип открытости/закрытости — одна из движущих сил в архитектуре систем. 
Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений. 
Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, 
защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.

Этот принцип тесно связан с LSP и DIP.

[к оглавлению](#OOD)

## 11. Расскажите о нарушениях принципа OCP?

при написании расширяемых классов стоит обращать внимание:

- на создаваемые объекты. Помните классы должны зависеть от абстракций, а не от реализаций (принцип DIP). Вспомните пример из прошлого задания. Подобный подход мешает наследованию

- на поля. Поля также должны представлять собой тип абстракций. Такой вариант тоже может привести к сложностям расширения, так как, чтобы расширить программу, придется наследоваться, но не всегда наследование возможно.

- на параметры и возвращаемые типы методов. Они тоже должны быть абстракциями. Как в примере выше.

Если говорить кратко, взаимодействие должно быть строго через абстракции (интерфейсы, абстрактные классы), за исключением примитивных типов и не изменяемых типов (строки, классы-обертки, в общем классы помеченные final), которые в конечном счете представляют собой состояние объектов.

если у нас условия с проверкой на конкретно заданные сущностями

- ------------------------------------

**Пример 1.**

Предположим, способ отправки письма подтверждения был реализован следующим образом:
```java
public class MessageSender {
    //Шлем уведомление клиенту
    public void send(String msg, MessageType type) {
        if (type == MessageType.SMS) {
            sendSMS(msg);
        } else if (type == MessageType.EMAIL) {
                           sendEMAIL(msg);
                       }
    }
}
```
здесь нарушен OCP принцип, т.к. при изменении способов отправки уведомлений придется менять существующий код.
Воспользуемся паттерном "Стратегия" для решения проблемы:
```java
//Создаем интерфейс
interface SendingStrategy {
    void send(String msg);
}

//Создаем контекстный класс
public class MessageSender {
    private SendingStrategy strategy;
    
    public MessageSender(SendingStrategy strategy) {
        this.strategy = strategy;
    }
   
    public void send(String msg) {
             this.strategy.send(msg);  
    }
}

//Реализуем конкретные стратегии отправки
public class EmailSendingStrategy implements SendingStrategy {
    
    @Override
    public void send(String msg) {
        System.out.println("Sending Email: " + msg); 
    }
}

public class SMSSendingStrategy implements SendingStrategy {
    
    @Override
    public void send(String msg) {
        System.out.println("Sending SMS: " + msg); 
    }
}
```
теперь, чтобы добавить новый способ отправки уведомлений, нужно просто реализовать еще одну стратегию,
не меняя существующий код.

**Пример 2.**

Продолжая пример с заказом, предположим, что нам нужно выполнять какие-то действия перед обработкой заказа и 
после отправки письма с подтверждением. Вместо того, чтобы менять сам класс OrderProcessor, мы расширим его и добьемся 
решения поставленной задачи, не нарушая принцип OCP: 
```java
public class OrderProcessorWithPreAndPostProcessing extends OrderProcessor {

    @Override
    public void process(Order order) {
        beforeProcessing();
        super.process(order);
        afterProcessing();
    }

    private void beforeProcessing() {
        // Осуществим некоторые действия перед обработкой заказа
    }

    private void afterProcessing() {
        // Осуществим некоторые действия после обработки заказа
    }
}
```
[Еще примеры](https://blog.byndyu.ru/2009/10/blog-post_14.html)

[к оглавлению](#OOD)

## 12. Последствия нарушения OCP?

При изменении требований придется каждый раз изменять существующий код, что влечет за собой также изменение тестов.

Также нарушения одного приципа ведет к нарушению другогих (DIP)

[к оглавлению](#OOD)

## 13. Что такое LSP?

https://job4j.ru/profile/exercise/66/task-view/386

LSP (Liskov Substitution Principle). Данный принцип гласит, что если в коде используется
сущность X, то при постановке его наследников или других реализаций Y код будет работать. Фактически этот принцип
гарантирует, что не нарушится принцип OCP относительно взаимосвязи между классами в иерархии.

Как проверить что ваш код не нарушает этот принцип? Легко, представляете что нужно будет использовать в коде какие-то специфические
реализации и пытаетесь мысленно их подставить. Если нет проблем с подстановкой, то все отлично. В целом не должно быть завязки на конкретной реализации.

Можно было назвать просто “принцип подстановки”

L: Liskov Substitution Principle (Принцип подстановки/заменяемости (Барбары) Лисков).
Сокращенно пишут LSP.

Ключевое слово здесь – “подстановка” или “заменяемость”

**Данный принцип гласит, что если в коде используется
сущность X, то при постановке его наследников или других реализаций Y код будет работать. Фактически этот принцип
гарантирует, что не нарушится принцип OCP относительно взаимосвязи между классами в иерархии.**

**“Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом”**

***Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. 
Подклассы не могут замещать поведения базовых классов. Подтипы должны дополнять базовые типы*.**

Поэтому функция должна быть универсальной, чтобы не приходилось ее постоянно переписывать.

Вы не должны проверять тип объекта (instance of), чтобы реализовать нужный функционал.

Принцип LSP чем-то похож на OCP, но в LSP речь идет именно об “универсальной функции”, которая должна уметь работать с любыми существующими или будущими типами, которые в будущем могут быть созданы

Основное решение – использование полиморфизма, когда в зависимости от предоставленного объекта будет подставляться нужная реализация.

Именно поэтому в название присутствует слово “подстановка“.

**Контракты LSP**

Контракт - это некое правило, соблюдение которого гарантирует, что принцип не будет нарушен.
Применительно LSP выделяют следующие контракты:

1. **Предусловия (Preconditions)** не могут быть усилены в подклассе

Предусловие - это условие, которое проверяет корректность аргументов конструктора или метода.

Допустим у нас есть класс автотранспорта. Пусть теперь есть наследник - автобус. Предположим ему нужно больше топлива, чтобы сдвинуться с места

```java
package ru.job4j.ood.lsp;

class AutoTransport {

    protected float fuel;

    public AutoTransport(float fuel) {
        this.fuel = fuel;
    }

    public void move(float km) {
        if (km < 0) {
            throw new IllegalArgumentException("Invalid distance!");
        }
        if (fuel < 0) { /* <= предусловие */
            throw new IllegalArgumentException("Need more fuel!");
        }
        /* other logic */
    }

}

class Bus extends AutoTransport {

    public Bus(float fuel) {
        super(fuel);
    }

    public void move(float km) {
        if (km < 0) {
            throw new IllegalArgumentException("Invalid distance!");
        }
        if (fuel < 5) { /* условие усилено */
            throw new IllegalArgumentException("Need more fuel!");
        }
        /* other logic */
    }

}

public class FirstRule {
    public static void main(String[] args) {
        AutoTransport bus = new Bus(3);
        bus.move(2);
    }
}
```
От AutoTransport мы ожидаем, что машина сдвинется, но нет. Автобус не сдвигается, т.к. в нем усилено предусловие. Ожидаем мы одно поведение, а получаем другое.
Чтобы сдвинуть автобус нам придется дописать доп. условие, чтобы проверить является ли транспорт автобусом. Далее уже скормить ему больше топлива.

2. **Постусловия (Postconditions)** не могут быть ослаблены в подклассе.

Постусловие - это условие, налагаемое на возвращаемое значение метода.

Рассмотрим такой пример. Пусть есть бухгалтерия, которая считает по табелю сколько работник отработал
и если он отработал норму, то высчитывает для него зарплату. Далее мы наследуемся допустим для бухгалтерии магазина. В нем мы забываем про условие когда добавляем специфическое поведение
и когда запускаем пример, то получаем, что недобросовестный работник получает зарплату.
```java
package ru.job4j.ood.lsp;

import java.time.LocalDate;
import java.time.Month;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

class WorkDays implements Iterable<Integer> {

    private Map<LocalDate, Integer> workDays = new LinkedHashMap<>();

    public void add(LocalDate date, int hours) {
        workDays.put(date, hours);
    }

    @Override
    public Iterator<Integer> iterator() {
        return workDays.values().iterator();
    }
}

class CountingRoom {

    protected int normHours;

    protected int payPerHour;

    public CountingRoom(int normHours, int payPerHour) {
        this.normHours = normHours;
        this.payPerHour = payPerHour;
    }

    public int pay(WorkDays workDays) {
        int factHours = 0;
        for (Integer hoursPerDay : workDays) {
            factHours += hoursPerDay;
        }
        if (factHours < normHours) {
            throw new IllegalArgumentException("Worker didn't work enough!");
        }
        return factHours * payPerHour;
    }

}

class ShopCountingRoom extends CountingRoom {

    public ShopCountingRoom(int normHours, int payPerHour) {
        super(normHours, payPerHour);
    }

    @Override
    public int pay(WorkDays workDays) {
        int factHours = 0;
        for (Integer hoursPerDay : workDays) {
            factHours += hoursPerDay;
        }
        return factHours * payPerHour;
    }
}

public class SecondRule {
    public static void main(String[] args) {

        WorkDays workDays = new WorkDays();
        workDays.add(LocalDate.of(2020, Month.DECEMBER, 1), 8);
        workDays.add(LocalDate.of(2020, Month.DECEMBER, 2), 6);
        workDays.add(LocalDate.of(2020, Month.DECEMBER, 3), 7);

        CountingRoom countingRoom = new ShopCountingRoom(3 * 8, 500);
        System.out.println(countingRoom.pay(workDays));
    }
}
```

Правила 1-2 не распространяются на приватные поля, т.е. когда вы проверяете специфичные только для объекта поля, то вы не нарушаете эти правила. Принцип Лисков контролирует отношения между классами при наследовании.

3. **Инварианты (Invariants)** — все условия базового класса также должны быть сохранены и в подклассе

Инвариант - это условие, которое постоянно на протяжении существования объекта.

Например, есть номер телефона. Есть абонент. От него наследуется абонент какого-то оператора. Но при переопределении сеттера, забыли сделать проверку. Поэтому код в машине запускается успешно.
Ошибка остается. Нарушено состояние объекта потомка, потому что в нем не соблюдено условие предка.

```java
package ru.job4j.ood.lsp;


class PhoneNumber {

    private int countryCode;

    private int cityCode;

    private int number;

    public PhoneNumber(int countryCode, int cityCode, int number) {
        this.countryCode = countryCode;
        this.cityCode = cityCode;
        this.number = number;
    }

    public int getCountryCode() {
        return countryCode;
    }

    public int getCityCode() {
        return cityCode;
    }

    public int getNumber() {
        return number;
    }
}

/* абонент */
class Subscriber {

    protected PhoneNumber phoneNumber;

    public Subscriber(PhoneNumber phoneNumber) {
        validate(phoneNumber);
        this.phoneNumber = phoneNumber;
    }

    protected void validate(PhoneNumber phoneNumber) {
        if (phoneNumber.getCountryCode() < 1 || phoneNumber.getCountryCode() > 999) {
            throw new IllegalArgumentException("Invalid country code!");
        }
        if (phoneNumber.getCityCode() < 1 || phoneNumber.getCityCode() > 999) {
            throw new IllegalArgumentException("Invalid city code!");
        }
        if (phoneNumber.getNumber() < 1 || phoneNumber.getNumber() > 999_999_999) {
            throw new IllegalArgumentException("Invalid number!");
        }
    }

    public PhoneNumber getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(PhoneNumber phoneNumber) {
        validate(phoneNumber);
        this.phoneNumber = phoneNumber;
    }
}

class SomeOperatorSubscriber extends Subscriber {

    public SomeOperatorSubscriber(PhoneNumber phoneNumber) {
        super(phoneNumber);
    }

    @Override
    public void setPhoneNumber(PhoneNumber phoneNumber) {
        /* some specific logic; */
        /* Забыли сделать проверку. Возможно не валидное состояние */
        this.phoneNumber = phoneNumber;
    }
}

public class ThirdRule {
    public static void main(String[] args) {
        Subscriber subscriber = new SomeOperatorSubscriber(
                new PhoneNumber(+1, 111, 111_111_111)
        );
        subscriber.setPhoneNumber(
                new PhoneNumber(-1, 111, 111_111_111)
        );
    }
}
```
- ----------------------------------------

Определение подтипов, данное Барбарой Лисков:

Здесь требуется что-то вроде следующего свойства подстановки: если для каждого объекта o1 типа S существует 
такой объект o2 типа T, что для всех программ P, определенных в терминах T, 
поведение P не изменяется при подстановке o1 вместо o2, то S является подтипом T.

Эта идея лежит в основе LSP, который звучит так:
*Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. 
Подклассы не могут замещать поведения базовых классов. Подтипы должны дополнять базовые типы*.

Руководство по использованию наследования:

Пусть класс с именем License, имеет метод с именем calcFee(), который вызывается приложением Billing. 
Существует два «подтипа» класса License: PersonalLicense и BusinessLicense. 
Они реализуют разные алгоритмы расчета лицензионных отчислений.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/lsp1.png)

Этот дизайн соответствует принципу подстановки Барбары Лисков, 
потому что поведение приложения Billing не зависит от использования того или иного подтипа. 
Оба подтипа могут служить заменой для типа License.

[к оглавлению](#OOD)

## 14. Расскажите о нарушениях принципа LSP?

Признаки нарушения принципа:

1. Использование методов getClass(), instance of

Допустим вам нужно написать программу которая рисует фигуры. У каждой фигуры есть свое состояние

Написание кода вида

```java
if (figure.getClass() == Line.class) {
            canvas.drawLine(
                    ((Line) figure).getX1(), ((Line) figure).getY1(),
                    ((Line) figure).getX1(), ((Line) figure).getY1()
            );
        } else if (figure.getClass() == Rectangle.class) {
             ...
        } else if (...) {

        }
        ...
```

Приведет к нарушению принципа OCP, мы не можем расширить код, нам нужно его дописать чтобы он работал с новой фигурой, а
нарушение принципа OCP было по причине нарушения принципа LSP.

Аналогично было бы нарушением использование instance of

2. Написание кода с наличием слова type

Часто код где есть методы setType(), getType() нарушает принцип LSP. Исключением здесь является использование рефлекции, которая само
собой предполагает извлечение и модификацию метаинформации о классах.

Обычно совместно с этим идет использование enum. Например для примера выше могло бы быть создано перечисление

```java

enum FigureType {
    LINE, RECTANGLE, ...
}

 if (figure.getType() == FigureType.LINE) {
            canvas.drawLine(
                    ((Line) figure).getX1(), ((Line) figure).getY1(),
                    ((Line) figure).getX1(), ((Line) figure).getY1()
            );
        } else if (FigureType.RECTANGLE) {
            ...
        } else if (...) {

        }
        ...
```
Это не означает, что нужно избегать использования enum, это означает, что нужно тщательно подумать прежде чем ограничивать
реализации. В enum должны быть константы, которые в будущем не будут изменяться и не будут пополняться.

3. Обращение к свойствам ограничивающим определенное множество объектов.

К примеру, у каждой фигуры замкнутой фигуры есть площадь. Вы решили по разному рисовать фигуры с разной площадью

```java
 if (figure.isClosed()) {
            double s = figure.square();
            if (100 < s && s < 500) {
                // draw red
            } else if (...) {
               ...
            }
        }
```

Такой код может и не нарушить LSP, если учесть все варианты. Но в таких случаях высока вероятность допустить ошибку. Будь бдительны. Подумайте не понадобятся ли в дальнейшем посылать в метод объекты с другими свойствами.

Вывод:

1. Если при подстановке нарушается поведение объекта, то это есть нарушение принципа Лисков.
2. Если в коде присутствует адаптация под реализации, то скорее всего код нарушает принцип Лисков. Это наблюдение исходит из первого, потому что под определенное поведение нам нужна определенная проверка.

- ------------------------

LSP тесно связан с принципом единственной ответственности и принципом разделения интерфейса.

Если класс реализует больше функциональности, чем подкласс, 
то последний может не поддерживать некоторые функции и тем самым нарушает данный принцип.

Классические примеры нарушения LSP - это проблемы квадрат/прямоугольник и круг/эллипс.

**Пример 1.**

Проблема квадрат/прямоугольник

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/lsp2.png)

```java
class Rectangle {
	
	public int getWidth() {
		return width;
	}
	
	public int getHeight() {
		return height;
	}
	
	public void setWidth(int width) {
		this.width = width;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public int getArea() {
	    return this.width * this.height;
	}
}

class Square extends Rectangle {
	
	@Override
	public void setWidth(int width) {
		this.width = width;
		this.height = width;
	}
	
	@Override
	public void setHeight(int height) {
		this.height = height;
		this.width = height;
	}
}

public class Main {
    static void resize(Rectangle r, int new_width, int new_height) {
        r.setWidth(new_width);
        r.setHeight(new_height); 
    }

	public static void main(String[] args) {
		Rectangle r = new Rectangle();
		Square s = new Square();
		resize(r,2,3);
		resize(s,2,3);
		System.out.println(r.getArea()); //2*3=6
		System.out.println(s.getArea()); //ошибка
	}
}
```
Функция resize() провоцирует неявную ошибку при работе с экземпляром класса Square, потому что позволяет 
устанавливать отличные друг от друга значения ширины и высоты. Согласно принципу LSP, функции, использующие ссылки 
на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом. 
Поэтому для корректной работы функция resize() должна проверять, является ли передаваемый объект экземпляром 
класса Square, и в этом случае не позволять установить разные значения ширины и высоты. Отсюда идёт нарушение принципа.

**Пример 2.**

Предположим есть класс, который отвечает за валидацию заказа и проверяет, все ли из товаров заказа находятся на складе. 
У данного класса есть метод isValid который возвращает true или false:
public class OrderStockValidator {
```java
public class OrderStockValidator {
    
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (! item.isInStock()) {
                return false;
            }
        }
        return true;
    }
}
```
Также предположим, что некоторые заказы нужно валидировать иначе: 
проверять, все ли товары заказа находятся на складе и все ли товары упакованы. 
Для этого мы расширили класс OrderStockValidator классом OrderStockAndPackValidator:
```java
public class OrderStockAndPackValidator extends OrderStockValidator {

    @Override
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (!item.isInStock() || !item.isPacked()){
                throw new IllegalStateException(
                     String.format("Order %d is not valid!", order.getId())
                );
            }
        }
        return true;
    }
}
```
Однако в данном классе мы нарушили принцип LSP, так как вместо того, чтобы вернуть false, 
если заказ не прошел валидацию, наш метод бросает исключение IllegalStateException. 
Клиенты данного кода не рассчитывают на такое: они ожидают возвращения true или false. 
Это может привести к ошибкам в работе программы.

[Еще примеры](https://blog.byndyu.ru/2009/10/blog-post_29.html)

[к оглавлению](#OOD)

## 15. Последствия нарушения LSP?

Неожиданное поведение классов. Ошибки в программе при замене на подклассы.

[к оглавлению](#OOD)

## 16. Что такое ISP?

https://job4j.ru/profile/exercise/67/task-view/389

https://metanit.com/sharp/patterns/5.4.php

ISP (Interface Segregation Principle),
принцип разделения интерфейсов.

Роберт Мартин точно высказал суть этого принципа: "Программные сущности не должны зависеть от методов, которые они не используют."
Можно догадаться, что если добавить много методов в интерфейс, то придется в реализациях все методы реализовывать, хотя это не всегда уместно.

“Нужно создавать такие интерфейсы, в которых описан только необходимый минимум реализаций методов”

Основная мысль – максимально делить (дробить) интерфейсы, но не слишком мелко.

Вместо того, чтобы класс реализовывал один большой интерфейс, лучше пусть реализовывает несколько мелких.

НЕ следует создавать избыточные интерфейсы, которые будут обязывать классы реализовывать то, что им не нужно (не свойственно их поведению). Лучше разбить такой интерфейс на несколько.

Каждый интерфейс занимается только своим делом. Не нужно создавать универсальный интерфейс, который умеет все, или лезть в чужие дела.

Эта мысль перекликается с первым принципом SOLID – Single Responsibility Principle (Принцип единственной ответственности)

Вывод:

1. Наличие более 3 методов в интерфейсе может быть признаком нарушения ISP
2. Некорректное выделение абстракций ведет к нарушению всех методов SOLID включая ISP
3. Решение разделение интерфейсов на более мелкие

- ---------------
Make fine grained interfaces, that are client specific.
Клиенты не должны реализовывать методы, которые они не будут использовать.

Много специализированных интерфейсов лучше, чем один универсальный. Иными словами большие, 
объемные интерфейсы нужно разбивать на мелкие таким образом, чтобы клиенты маленьких интерфейсов 
знали только о тех методах, которые необходимы им в работе. 
Также при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

[к оглавлению](#OOD)

## 17. Расскажите о нарушениях принципа ISP?

- неверное выделение абстракции, которое в свою очередь ведет к нарушению ISP. В этом случае программные сущности, которые работали бы с фигурами на плоскости, не использовали бы метод volume(), хотя зависели бы от него.

- При больших интерфейсах программа становится сильносвязной. Т.к. при изменении интерфейса придется внести изменения в реализации.

Вывод:

1. Наличие более 3 методов в интерфейсе может быть признаком нарушения ISP
2. Некорректное выделение абстракций ведет к нарушению всех методов SOLID включая ISP
3. Решение разделение интерфейсов на более мелкие

Техники для выявления нарушения этого принципа:

- Слишком большие интерфейсы
- Компоненты в интерфейсах слабо согласованы (перекликается с принципом единой ответственности)
- Методы без реализации (перекликается с принципом Лисков

**Пример 1. ISP и язык**

Пусть имеется несколько классов, пользующихся операциями в классе OPS. 
Допустим, что User1 использует только операцию op1, User2 — только op2 и User3 — только op3.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/isp1.png)

Теперь представьте, что OPS — это класс, написанный на таком языке, как Java. 
Очевидно, что исходный код User1 непреднамеренно будет зависеть от op2 и op3, даже при том, что он не пользуется ими. 
Эта зависимость означает, что изменения в исходном коде метода op2 в классе OPS потребуют повторной компиляции 
и развертывания класса User1, несмотря на то, что для него ничего не изменилось.
Эту проблему можно решить разделением операций по интерфейсам:

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/isp2.png)

Если снова представить, что этот интерфейс реализован на языке со строгим контролем типов, таком как Java, 
исходный код User1 будет зависеть от U1Ops и op1, но не от OPS. 
То есть изменения в OPS, которые не касаются User1, не потребуют повторной компиляции и развертывания User1.

Очевидно, что описание выше в значительной степени зависит от типа языка. Языки со статическими типами, такие как Java, 
вынуждают программистов создавать объявления, которые должны импортироваться или подключаться к исходному коду 
пользователя как-то иначе. Именно эти инструкции подключения в исходном коде пользователя создают зависимости и 
вынуждают выполнять повторную компиляцию и развертывание.

**Пример 2. ISP и архитектура**

В общем случае опасно создавать зависимости от модулей, содержащих больше, чем требуется. 
Это справедливо не только в отношении зависимостей в исходном коде, которые могут вынуждать выполнять 
без необходимости повторную компиляцию и развертывание, но также на более высоком уровне — на уровне архитектуры.

Рассмотрим, например, действия архитектора, работающего над системой S. Он пожелал включить в систему 
некоторый фреймворк F. Теперь представьте, что авторы F связали его с поддержкой конкретной базы данных D. 
То есть S зависит от F, который зависит от D

Например, архитектор, работает над системой S. Он пожелал включить в систему некоторый фреймворк F. 
Теперь представьте, что авторы F связали его с поддержкой конкретной базы данных D. 
То есть S зависит от F, который зависит от D

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/isp3.png)

Представьте, что D включает функции, которые не используются фреймворком F и, соответственно, не используются системой S. 
Изменения в этих функциях внутри D могут вынудить повторно развернуть F и, соответственно, повторно развернуть S. 
Более того, ошибка в одной из таких функций внутри D может спровоцировать появление ошибок в F и S.

Т.е. зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причиной неожиданных проблем.

[Еще примеры](https://blog.byndyu.ru/2009/11/blog-post_19.html)

[к оглавлению](#OOD)

## 18. Последствия нарушения ISP?

Дублирование кода - мы вынуждены будем переопределять неиспользуемые методы в классах, реализующих "большой" интерфейс.

Кроме того, с точки зрения архитектуры проекта, 
зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причиной неожиданных проблем.

[к оглавлению](#OOD)

## 19. Что такое DIP?

https://job4j.ru/profile/exercise/68/task-view/391

https://habr.com/ru/articles/313796/

**DIP (Dependency Inversion Principle)** - принцип инверсии зависимостей.

Данный принцип гласит:

- Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Проще говоря, используемые сущности в вашем коде должны быть абстракциями, т.е. не должно быть прямой зависимости от реализации.

Это касается:

- полей классов
- возвращаемых значений методов
- аргументов методов и конструкторов
- создаваемых объектов (вспомните пример из урока про SRP)

Чаще всего это не касается моделей данных бизнес-логики, т.е. классов типа Item, Post, User, Role и т.д, однако если они также содержат какую-то логику, то правило также действует и на них.
- ------------------------

Depend on abstractions, not on concretions.
Зависимости внутри системы строятся на основе абстракций, а не конкретных реализаций.

Наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, 
а не на конкретные реализации.

+ Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
+ Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Что такое модули верхних уровней? Как определить этот уровень? Как оказалось, все очень просто. 
Чем ближе модуль к вводу/выводу, тем ниже уровень модуля. Т.е. модули, работающие с BD, интерфейсом пользователя, 
низкого уровня. А модули, реализующие бизнес-логику — высокого уровня.

Что такое зависимость модулей? Это ссылка на модуль в исходном коде, т.е. import, require и т.п. 
С помощью динамического полиморфизма в runtime можно обратить эту зависимость.

Есть модуль Logic, реализующий логику, который должен отсылать уведомления. В этом же пакете объявляется интерфейс 
ISender, который используется Logic. Уровнем ниже, в другом пакете объявляется ConcreteSender, реализующий ISender. 
Получается, что в момент компиляции Logic не зависит от ConcreteSender. В runtime, например, через конструктор 
в Logic устанавливается экземпляр ConcreteSender.

Отдельно стоит отметить частый вопрос: *"Зачем плодить абстракции, если мы не собираемся заменять базу данных?"*.

Логика тут следующая. На старте проекта, мы знаем, что будем использовать реляционную базу данных, 
и это точно будет Postgresql, а для поиска — ElasticSearch. Мы даже не планируем их менять в будущем. 
Но мы хотим отложить принятие решений о том, какая будет схема таблиц, какие будут индексы, и т.п. до момента, 
пока это не станет проблемой. И на этот момент мы будем обладать достаточной информацией, чтобы принять правильное 
решение. Также мы можем раньше отладить логику нашего приложения, реализовать интерфейс, собрать обратную связь 
от заказчика, и минимизировать последующие изменения, ведь многое реализовано только в виде заглушек.

[к оглавлению](#OOD)

## 20. Расскажите о нарушениях принципа DIP?

На что стоит обратить внимание? 

1. Поля. У сервиса есть единственное поле - мапа, для хранения данных. С точки зрения DIP, это нарушение, потому что мы зависим от реализации, а не абстракции. Решение - выделение абстракции для хранилища и уже далее от него нужно будет реализовать InMemoryShopStore

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись 
друг с другом с помощью абстракции.

2. Стоит обратить внимание на подобные строки. Вы уже знакомы с логгированием, которое проходили в разделе IO. Подобная запись также является нарушением DIP, потому что есть прямая зависимость самого логгирования от реализации, в данном случае оно напрямую зависит от консольного вывода.

```java
System.out.println("Get error with "  + user + " " + order);
```

Решение опять использование абстракции для логирования

```java
private static final Logger LOGGER = Logger.getLogger("Shop logger");
```

3. На входные параметры. В данном случае на Order. Во-первых, этот класс нарушает SRP, потому что представляет как саму модель заказа, так и АПИ для работы с ней. Во-вторых, он нарушает DIP, потому что опять же сохранение идет в память, нам нужно здесь аналогично абстрагироваться от самого хранилища, создав для него отдельный интерфейс. Но зависимость от хранилища уже будет в сервис заказа, а сервис магазина будет зависеть от сервиса заказов

Вывод:

Как уже было сказано ранее, чтобы не нарушить принцип DIP

1. Выделяйте абстракции и делайте зависимости именно от них, а не от их реализаций.

2. Для этого обращайте внимание на:

- поля классов
- возвращаемые значения методов
- аргументы методов и конструкторов
- создаваемые объекты 

**Пример.**

Пусть есть модуль, который обрабатывает заказы. 
Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа: 
```java
public class OrderProcessor {
    
    public void process(Order order) {

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```
В данном примере наш OrderProcessor зависит от двух конкретных классов MySQLOrderRepository и ConfirmationEmailSender.
Эти классы далеки от того, чтобы называться абстракциями. И с точки зрения принципа DIP было бы правильнее для начала 
создать некоторые абстракции, которые позволят нам оперировать в дальнейшем ими, а не конкретными реализациями. 
Создадим два интерфейса MailSender и OrderRepository, которые и станут нашими абстракциями и 
мплементируем данные интерфейсы в уже готовых для этого классах: 
```java
interface MailSender {
    void sendConfirmationEmail(Order order);
}

interface OrderRepository {
    boolean save(Order order);
}

public class ConfirmationEmailSender implements MailSender {
    @Override
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();
        // Шлем письмо клиенту
    }
}

public class MySQLOrderRepository implements OrderRepository {
    @Override
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных
        return true;
    }
}
```
Теперь наш класс OrderProcessor зависит от абстракций, а не от конкретных реализаций.  
Внесем в него изменения, внедряя наши зависимости в конструкторе класса:
```java
public class OrderProcessor {

    private MailSender mailSender;
    private OrderRepository repository;

    public OrderProcessor(MailSender mailSender, OrderRepository repository) {
        this.mailSender = mailSender;
        this.repository = repository;
    }

    public void process(Order order){
        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```
Поведение класса теперь можно без труда менять, внедряя нужную зависимость в момент создания экземпляра OrderProcessor.

[Еще примеры](https://blog.byndyu.ru/2009/12/blog-post.html)

[к оглавлению](#OOD)

## 21. Последствия нарушения DIP?

https://job4j.ru/profile/exercise/12/task-view/40

https://habr.com/ru/articles/426487/

Каждое изменение абстрактного интерфейса вызывает изменение его конкретной реализации. 
Изменение конкретной реализации, напротив, не всегда сопровождается изменениями и даже обычно 
не требует изменений в соответствующих интерфейсах. Т.е. интерфейсы менее изменчивы, чем реализации.

***Вместо замены реализации, придется изменять сам класс.***

Если в приложении абстракции не отделены от деталей, то изменение логики в низкоуровневых реализациях
может неожидано привести к поломке высокоуровневых модулей.
Тестировать такую систему будет очень сложно. Даже если получится написать модульные тесты, 
то любое изменение в системе приведет к тому, что эти тесты придется переписывать.

***В результате получим жесткую, хрупкую, неподвижную систему, которую сложно тестировать.***

1. Жесткость - тяжело менять систему, потому что каждое изменение затрагивает очень много различных ее частей.

2. Хрупкость - когда вы вносите изменения в одну часть системы, то в неожиданном месте ломается другая.

3. Неподвижность - очень сложно повторно использовать код в другом приложении, т.к. модули сильно связаны между собой.

[к оглавлению](#OOD)

## 22. Расскажите что такое автоматическое тестирование?

https://job4j.ru/profile/exercise/12/task-view/40

https://habr.com/ru/articles/426487/

Тестирование – это процесс выполнения определенного сценария с получением результата, который в конце должен соответствовать ожидаемому.

В целом тестирование можно разделить на автоматизированное и ручное. Программист должен уметь применять оба подхода для проверки своей программы.

Схематично каждый тест можно представить в виде следующей схемы:

Автоматизированное тестирование или автоматизация тестирования – это метод тестирования программного обеспечения, который выполняется с использованием специальных программных средств, которые, в свою очередь необходимы для выполнения набора тестовых примеров. Напротив, ручное тестирование выполняется человеком, сидящим перед компьютером и тщательно выполняющим каждый шаг теста «руками».
- ------------------------------

Автоматизированное тестирование - это процесс использования программного обеспечения для проверки корректности работы функциональности приложения или системы. В отличие от ручного тестирования, где тесты выполняются человеком, в автоматизированном тестировании используются специальные программы (тесты) для проверки различных аспектов работы системы без вмешательства человека.

Тесты пишутся на специальных языках или с использованием фреймворков тестирования и запускаются на выполнение с заданными параметрами. Результаты выполнения тестов обычно сохраняются и анализируются, чтобы определить, успешно ли прошло тестирование.

Преимущества автоматизированного тестирования включают увеличение скорости и эффективности тестирования, снижение вероятности ошибок, вызванных человеческим фактором, а также возможность повторного использования уже написанных тестов для проверки новых версий приложения или систем.
- --------------------------------------

Автоматическое тестирование – проверка ПО выполняется с помощью специальных инструментов. 
Оценка результатов проводится автоматически.

Основные шаги теста (запуск, инициализация, выполнение, анализ и выдача результата) 
проводятся автоматически посредством программных средств.

+ сокращает время тестирования и упрощает его процесс.
+ повышает качество тестирования (исключается человеческий фактор),
+ обеспечивает повторное использование тестов при корректировке ПО, что особенно важно в больших проектах.

[к оглавлению](#OOD)

## 23. Как в Java осуществляется автоматическое тестирование?

https://job4j.ru/profile/exercise/63/task-view/788

https://job4j.ru/profile/exercise/12/task-view/41

https://habr.com/ru/articles/120101/

Все тесты базируются на принципе AAA – Arrange Act Assert. Arrange – указание входных и ожидаемых данных программы. Act – выполнение программы путем передачи входных и получение выходных данных. Assert – сравнение выходных и ожидаемых данных. 

С помощью библиотек для автоматического тестирования (например):

+ **Selenium -** набор различных программных инструментов, каждый из которых имеет свой подход к поддержке 
автоматизации тестирования веб-приложений на многих платформах.

+ **JUnit -** фреймворк для написания повторяющихся тестов. 
Это экземпляр архитектуры xUnit для платформ модульного тестирования.

с Junit 5 используется также библиотека AssertJ. 

JUnit 4 и Harmcrest - это библиотека матчеров – классов, которые позволяют проводить сравнение определенным образом.

Здесь же стоит упомянуть Mockito. Эту библиотеку мы используем на уровне мидл. Она позволяет заменять реальные объекты в тестах на объекты-заглушки, которые имитируют поведение.

[к оглавлению](#OOD)

## 24. Что такое JUnit и как используется для тестирования?

JUnit — это фреймворк автоматического тестирования отдельных модулей кода, например, методов или классов. Тест это отдельный класс.

Фреймворк JUnit5 позволяет создавать независимые блоки кода для тестирования. При использовании JUnit5 мы можем писать независимые методы, которые можно запускать и проверять отдельно.Есть общее соглашение о создании JUnit тестов. При написании тестов на класс мы создаем такой же класс с добавлением к имени суффикса Test.

```java
Фреймворк - это работающий каркас со всеми необходимыми элементами и инструментами. Он является многоразовым - его можно использовать повторно в следующих проектах. 

Фреймворк - это что-то вроде шаблона будущей программы. Главное особенностью его использования является наличие жестких рамок, т.е. разработчик не может менять шаблон, он лишь добавляет свой код.

Поэтому наши тесты будут иметь шаблонный вид, мы лишь в них будем имитировать работу нашего кода и проверять корректность работы нашей программы.
```

Методы должны иметь отличие только в имени, остальной каркас всегда остается одинаковым. 

Термин "Тест-метод" означает метод, который используется для проверки кода.

Обратите внимание: над каждым методом стоит аннотация @Test. Аннотация позволяет пометить метод, класс или переменную для дополнительной обработки.
В данном примере аннотация @Test позволяет запустить каждый метод по отдельности. В случае с тестированием это удобный механизм.

Юнит-тесты должны быть небольшими. В идеальном случае — одно утверждение (assert) на тест. 
Так модульнй тест будет соответствовать SRP, а также быстрее выполняться.

В юнит-тестах стоит использовать шаблон "Arrange, Act and Assert (AAA)", т.е. четко определить:
+ Arrange - предусловия (инициализация тестовых данных, предварительные установки);
+ Act - действие (вызыв тестируемого метода);
+ Assert - постусловия (что должно быть в результате выполнения действия). 

Подобное оформление повышает читаемость кода и облегчает его использование в качестве документации 
к тестируемой функциональности.

```java
import org.junit.Assert;
import org.junit.Test;

import static org.hamcrest.core.Is.is;

public class TemplateTest {

    @Test
    public void whenUniqueKeysThenTheyAreReplaced() {
       
        //arrange
        Template template = new SimpleGenerator();
        String data = "I am ${name}, Who are ${subject}?";
        Map<String, String> map = new HashMap<>();
        map.put("name", "Petr");
        map.put("subject", "you");
        String expected = "I am Petr, Who are you?";

        //act
        String result = template.generate(data, map);

        //assert
        Assert.assertThat(result, is(expected));
    }
}
```
Для улучшения читаемости кода в связке c JUnit используется библиотека matcher-ов Hamcrest.
Matcher – это выражение, тестирующее на совпадение с определенным условием.

Плюсы использования JUnit:
+ Открытый исходный код, тестовые наборы/комплекты, аннотации, простая интеграция (Spring, CI и т.д.)
+ При рефакторинге кода, тесты JUnit помогут нам проследить, чтобы логика нашей программы не поломалась.
+ JUnit сработает еще лучше в связке с Maven. При сборке проекта Maven обязательно проведет все тесты 
и потом соберет готовый проект. Если тесты будут провалены, проект не будет собран, 
но мы будем знать причины, и так будет легче разобраться где именно поломка.

[обзор JUnit](http://java-online.ru/blog-junit.xhtml)

[к оглавлению](#OOD)

## 25. Что такое функциональное тестирование и чем отличается от модульного?

https://habr.com/ru/articles/587620/

**Модульное тестирование (unit testing) —** направлено на тестирование методов, классов. На данном уровне достигается максимальная изоляция для тестирования именно бизнес-логики. Эти тесты чаще пишутся программистами. Тестирование (Unit Testing) проводится самими разработчиками, т.к. предполагает полный доступ к коду, для тестирования какого-либо одного логически выделенного и изолированного элемента (модуля) системы в коде, проверяет функциональность и ищет дефекты в частях приложения, которые доступны и могут быть протестированы по-отдельности (модули программ, объекты, классы, функции и т.д.).

**Функциональное тестирование (functional testing) —**  тестирование в соответствии с функциональными требованиями или бизнес-процессами. Причем под функциями или процессами здесь понимается то, что доступно и выполняется пользователем.

В качестве резюме,

Модульные тесты пишутся с точки зрения программистов. Они предназначены для обеспечения того, чтобы конкретный метод (или модуль) класса выполнял набор конкретных задач.

Функциональные тесты пишутся с точки зрения пользователя. Они гарантируют, что система функционирует так, как этого ожидают пользователи.
- ----------------------------------------

Обычно используют два вида автоматических тестов:

**Модульное тестирование (unit testing) —** это тестирование отдельных отдельных частей продукта. 
Unit — наименьшая тестируемая часть ПО, обычно метод или класс.

Юнит-тесты проверяют выполнение конкретного набора задач методом или классом.
Юнит тестирование по определению является тестированием белого ящика.

**Функциональное тестирование (functional testing) —** это тестирование некоего функционала продукта, 
при этом продукт воспринимается как единый «чёрный ящик».

Функциональные тесты проверяют работу системы на соответствие требованиям, указанным в спецификации продукта.
Внешнее поведение системы (логика работы продукта) проверяется независимо от внутренней реализации.

**Отличия:**
+ Даже успешное прохождение всех юнит-тестов не гарантирует правильной работы продукта: ведь одна и та же функция 
может быть использована в различных частях системы, в то время как юнит-тест писался для неё с оглядкой лишь 
на один вариант использования.

+ Функциональные тесты полностью определяют (по крайней мере должны) работоспособность продукта. 
И прежде всего нужны заказчику/руководителю разработки. Юнит-тестирование прежде всего нужно самим разработчикам, 
для быстрого нахождения ошибок или проверки последствий рефакторинга.

[к оглавлению](#OOD)

## 26. Расскажите про принцип TDD?

https://job4j.ru/profile/exercise/63/task-view/380

Test Driven Development.подход создания программы - это начать описывать поведение системы через тесты. Требования клиента формируется на основе тест-кейсов. Тест-кейс это описание того, что должен получить клиент или заказчик в какой-то конкретной ситуации при соблюдении определенных условий. Тест-кейс находит свое воплощение в Unit тестах. При этом как система будет достигать этих требований пока неизвестно. Это будет определено в ходе реализации. 

В таком подходе мы фокусируемся на возможности системы, а не на ее реализацию. Любую систему можно описать через интерфейсы взаимодействия. 

**Разработка через тестирование (test-driven development, TDD) —** техника разработки ПО, основанная
на повторении коротких циклов разработки: 
1. пишется тест, покрывающий желаемое изменение;
2. пишется код, который позволит пройти тест;
3. проводится рефакторинг нового кода к соответствующим стандартам.

Следуя TDD, вы получаете следующие преимущества:
+ ваш код полностью покрыт тестами;
+ создавая тесты до написания кода класса, вы заранее задумаетесь об его использовании, что положительно скажется как на качестве внешнего интерфейса класса, так и на архитектуре проекта в целом;
+ хорошие тесты могут легко заменить документацию, т.к. наглядно демонстрируют использование трестируемого кода.

[к оглавлению](#OOD)

## 27. Расскажите про принцип BDD?

https://habr.com/ru/companies/haulmont/articles/459134/

**Разработка на основе поведения (behavior-driven development, BDD) -** это методология разработки ПО, 
являющаяся ответвлением от методологии разработки через тестирование (TDD), при которой особое внимание 
уделяется описанию поведения системы/модуля в терминах бизнеса(заказчика).

Основная идея - совмещение в процессе разработки чисто технических интересов и интересов бизнеса.
Для общения между этими группами на естественном языке, понятном неспециалисту, формулируется 
поведение программного продукта и ожидаемые результаты.

BDD фокусируется на следующих вопросах:
+ С чего начинается процесс?
+ Что нужно тестировать, а что нет?
+ Сколько проверок должно быть совершено за один раз?
+ Что можно назвать проверкой?
+ Как понять, почему тест не прошёл?
Исходя из этих вопросов, BDD требует, чтобы имена тестов были целыми предложениями, 
которые начинаются с глагола в сослагательном наклонении и следовали бизнес целям. 
Описание приемочных тестов должно вестись на гибком языке пользовательской истории, например,
```java
Как [роль того, чьи бизнес интересы удовлетворяются] я хочу, 
чтобы [описание функциональности так, как она должна работать], 
для того чтобы [описание выгоды].
```
Критерии приёмки должны быть описаны через сценарий, который реализует пользователь, чтобы достигнуть результата.

**Резюме**

1. TDD — делать вещи правильно. BDD — делать правильные вещи. Они не взаимозаменяемы.

2. TDD проверяет исключительно модули, а BDD — пользовательские сценарии.

3. TDD используется для разработки через модульное тестирование непосредственно программистами, 
которые пишут код через этот подход.
BDD в основном используется для проверки взаимодействия разных компонентов системы, это уровень 
интеграционного тестирования — оно поведенческое и проверяет различные бизнес-кейсы.

4. TDD — это больше о программировании и тестировании на уровне технической реализации продукта, 
когда тесты создают сами разработчики. 
BDD предполагает описание тестировщиком или аналитиком пользовательских 
сценариев на естественном языке — если можно так выразиться, на языке бизнеса.

[к оглавлению](#OOD)

## 28. Что такое тестирование черным ящиком?

**Типы тестирования**

Тип тестирования показывает по какому принципу строятся тесты. Выделяют следующие типы:

- тестирование белым ящиком. Это тестирование с учетом исходного кода, т.е. мы знаем как устроена программа и знаем какой тест может протестировать ту или иную ветку кода. Пример, модульное тестирование;

- тестирование черным ящиком. Это тестирование без учета исходного кода. Неизвестно как программа работает внутри, но известны данные, которые она принимает и возвращает. Пример, приемочное тестирование;

- тестирование серым ящиком. Это тестирование находится на стыке белого и черного. Например, известен принцип внутренней работы программы и известны данные. Тестирование проводится с учетом и того и другого. Пример, регрессионное тестирование.


**тестирование "черного ящика" – это:**
+ тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства 
компонента или системы.
+ тест-дизайн, основанный на технике черного ящика – процедура написания или выбора тест-кейсов на основе анализа 
функциональной или нефункциональной спецификации компонента или системы без знания ее внутреннего устройства.

Тестируемая программа для тестировщика – как черный непрозрачный ящик, содержания которого он не видит. 
Целью этой техники является поиск ошибок в таких категориях как:

+ неправильно реализованные или недостающие функции;
+ ошибки интерфейса;
+ ошибки в структурах данных или организации доступа к внешним базам данных;
+ ошибки поведения или недостаточная производительности системы;

Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы. 
Нужно концентрироваться на том, что программа делает, а не на том, как она это делает.

## Тестирование

Тестирование программного обеспечение можно разделить на два вида:
+ тестирование черного ящика;
+ тестирование белого ящика.

Во время тестирования программы как черного ящика внутренняя структура приложения в расчет не принимается. 
Все, что имеет значение, это функциональность, которую приложение должно обеспечить. 
При тестировании программы как белого ящика во внимание принимается внутренняя структура, 
т.е. класс и методы. 

Кроме этого, тестирование можно разделить на четыре уровня:
 + Unit-тестирование — проверяет корректность работы отдельных модулей программы в изоляции.
 + Интеграционное — проверка корректности взаимодействия и совместной работы группы модулей друг с другом.
 + Системное — тесты проверяют работоспособность системы целиком.
 + Приёмочное — итоговое тестирование готовой системы на соответствие требованиям. 
 В реальном окружении, с реальными данными, на реальных сценариях. 

Юнит-тестирование по определению является тестированием белого ящика.

+ **Тестирование "черного ящика" —** методология при которой тестер не имеет доступа к исходному коду
(UI\UX тестирование, тестирование установки, тестирование локализации)

+ **Тестирование "белого ящика" —** методология при которой тестер(чаще сам разработчик или тестер-автоматизатор) 
имеет доступ к исходному коду продукта(Unit тестирование). 
Как правило, в данном случае баг репорт отражает именно ошибки в коде, а не в функциональном поведении.

+ **Тестирование "серого ящика" —** это расширенная методология “черного”, но при этом тестер также не имеет доступ 
к исходному коду(или имеет совсем ограниченный), но представляет как система устроена логически, 
может поделить её на модули и искать в них ошибки используя специальные методики(например, взаимодействие веб-приложений по сети).

[к оглавлению](#OOD)

## 29. Опишите типы тестов: модульное, интеграционное, функциональное, приемочное?

https://job4j.ru/profile/exercise/63/task/788/404654

**Уровни тестирования**

С точки зрения охвата тестирования ПО выделяют уровни тестирования:

- модульное направлено на тестирование методов, классов. На данном уровне достигается максимальная изоляция для тестирования именно бизнес-логики. Эти тесты чаще пишутся программистами, в курсе мы их используем. Подробнее здесь;

- интеграционное направлено на тестирование программы на предмет взаимодействия с внешними компонентами. Интеграция (внедрение) предполагает использование базы данных, файловой системы, внешних модулей программы, сети и т.д.  Данный вид тестов Вам также должен быть знаком, в курсе мы его используем. Подробнее здесь;

- системное направлено на тестирование подсистем системы и системы в целом. На этом уровне проверяется поведение системы в различных условия. Сюда можно, например, отнести нагрузочное тестирование. Подробнее здесь;

- приемочное. Его мы уже упоминали. Оно направлено на тестирование программы уже перед сдачей заказчику. Тестируется система целиком не с учетом ее программных особенностей, а с учетом функциональных требований.

![image](https://github.com/artemaverin/summary/assets/97846877/2b6f1c4e-a46b-4ec4-9bf8-396080458b1f)

[к оглавлению](#OOD)

## 4. Что такое Java code convention?

Документ Oracle по правилам оформления кода.
Соглашения по офрмлению кода важны для программистов по ряду причин:
+ 80% от стоимости программного обеспечения приходится на его обслуживание.
+ Вряд ли какое-либо программное обеспечение все время поддерживается первоначальным разработчиком.
+ Соглашения по оформлению кода делают исходный код программ более удобочитаемым, позволяя инженерам быстрее и тщательнее понимать новый код.
+ Если вы предоствляете исходный код как продукт, вы должны убедится, что он хорошо оформлен и упакован как любой другой продукт который вы создаете

[Code conventions](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf)

[к оглавлению](#OOD)

## Источники:

**SOLID** 

"Чистая архитектура" Р.Мартин 2018

https://academy.realm.io/posts/donn-felker-solid-part-1/

https://habr.com/ru/post/348286/

https://slide-share.ru/principi-solid-256783

https://blog.byndyu.ru/2009/10/solid.html

https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

https://habr.com/ru/post/208442/

**JavaDoc**

https://www.oracle.com/technetwork/java/codeconventions-150003.pdf


**Testing**

*Автоматизированное тестирование*

https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5

*обзор JUnit* 

http://java-online.ru/blog-junit.xhtml

https://ru.wikipedia.org/wiki/JUnit

*обзор Selenium* 

https://www.seleniumhq.org/docs/01_introducing_selenium.jsp

*Arrange Act Assert*

http://wiki.c2.com/?ArrangeActAssert

https://habr.com/ru/post/191986/

https://medium.com/pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80

*TDD vs BDD*

https://habr.com/ru/company/jugru/blog/329468

http://blog.bausov.pro/tdd-bdd-tests/

https://toster.ru/q/302924

https://dou.ua/forums/topic/8897/

## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс?](#3-Укажите-из-каких-элементов-состоит-класс)

[4. Что такое конструктор? Типы конструкторов?](#4-Что-такое-конструктор-Типы-конструкторов)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое не статический метод?](#8-Что-такое-не-статический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовый родительным классов для всех классов?](#10-Какой-класс-является-базовый-родительным-классов-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни?](#11-Что-такое-наследование-Приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта.](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительского класса?](#13-Как-вызвать-метод-из-родительского-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопределение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое сокрытие метода?](#16-Что-такое-сокрытие-метода)

[17. Что такое виртуальная функция и используются ли они в Java?](#17-Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)

[18. Что такое перегрузка метода?](#18-Что-такое-перегрузка-метода)

[19. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?](#19-Можно-ли-изменить-тип-возвращаемых-тип-данных-при-перегрузке-метода)

[20. Что такое множественное наследование? Как его можно реализовать в Java?](#20-Что-такое-множественное-наследование-Как-его-можно-реализовать-в-Java)

[21. Что такое полиморфизм? Приведите примеры из реальной жизни?](#21-Что-такое-полиморфизм-Приведите-примеры-из-реальной-жизни)

[22. Что такое инкапсуляция?](#22-Что-такое-инкапсуляция)

[23. Как реализована инкапсуляция в Java?](#23-Как-реализована-инкапсуляция-в-Java)

[24. Можно ли применить модификаторы доступа к конструкторам?](#24-Можно-ли-применить-модификаторы-доступа-к-конструкторам)

[25. Что такое интерфейс?](#25-Что-такое-интерфейс)

[26. Перечислите элементы, которые может содержать интерфейс.](#26-Перечислите-элементы-которые-может-содержать-интерфейс)

[27. Можно ли создать объект интерфейса? Если да, то как?](#27-Можно-ли-создать-объект-интерфейса-Если-да-то-как)

[28. Может ли интерфейс содержать какие-либо методы с реализацией? 
Если да, то какие?](#28-Может-ли-интерфейс-содержать-какиелибо-методы-с-реализацией-Если-да-то-какие)

[29. Что такое абстракция?](#29-Что-такое-абстракция)

[30. Что такое абстрактный класс?](#30-Что-такое-абстрактный-класс)

[31. Сколько абстрактных методов должен и может содержать абстрактный класс?](#31-Сколько-абстрактных-методов-должен-и-может-содержать-абстрактный-класс)

[32. Может ли абстрактный класс содержать обычные методы?](#32-Может-ли-абстрактный-класс-содержать-обычные-методы)

[33. Сколько объектов абстрактного класса можно создать в программе?](#33-Сколько-объектов-абстрактного-класса-можно-создать-в-программе)

[34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы 
родителя?](#34-Что-нужно-делать-если-наследник-абстрактного-класса-не-переопределяет-все-абстрактные-методы-родителя)

[35. Чем отличается интерфейс от абстрактного класса?](#35-Чем-отличается-интерфейс-от-абстрактного-класса)

[36. Что такое вложенные классы? Зачем они нужны?](#36-Что-такое-вложенные-классы-Зачем-они-нужны)

[37. Какие типы вложенных классов существуют в Java?](#37-Какие-типы-вложенных-классов-существуют-в-Java)

[38. Что такое внутренний класс? Когда он применяется?](#38-Что-такое-внутренний-класс-Когда-он-применяется)

[39. Что такое статический вложенный класс? Когда он применяется?](#39-Что-такое-статический-вложенный-класс-Когда-он-применяется)

[40. Сколько объектов статического вложенного класса можно создать в программе?](#40-Сколько-объектов-статического-вложенного-класса-можно-создать-в-программе)

[41. Что такое локальный класс? Когда он применяется?](#41-Что-такое-локальный-класс-Когда-он-применяется)

[42. Что такое анонимный класс? Когда он применяется?](#42-Что-такое-анонимный-класс-Когда-он-применяется)

[43. Сколько объектов анонимного класса можно создать в программе?](#43-Сколько-объектов-анонимного-класса-можно-создать-в-программе)

[44. Что такое исключения? Какие типы исключительных ситуаций бывают?](#44-Что-такое-исключения-Какие-типы-исключительных-ситуаций-бывают)

[45. Назовите основные методы класса Object?](#45-Назовите-основные-методы-класса-Object)

[46. Что такое шаблоны проектирования?](#46-Что-такое-шаблоны-проектирования)

[47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.](#47-Объясните-шаблон-декоратор-Придумайте-пример-не-относящийся-к-технике)

[48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.](#48-Объясните-шаблон-стратегия-Придумайте-пример-не-относящийся-к-технике)

[49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.](#49-Объясните-шаблон-синглтон-Придумайте-пример-не-относящийся-к-технике)

[50. Объясните шаблон - фабричный метод. Придумайте пример,
не относящийся к технике.](#50-Объясните-шаблон-фабричный-метод-Придумайте-пример-не-относящийся-к-технике)

[51. Что такое enum? Когда можно его применять?](#51-Чтотакое-enum-Когда-можно-его-применять)

[52. Что такое record? Когда можно его применять?](#52-Что-такое-record-Когда-можно-его-применять)

[53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?](#53-Зачем-нужны-StringBuilder-StringBuffer-StringJoiner-Что-они-делают)

[54. Чем отличаются StringBuffer и StringBuilder?](#54-Чем-отличаются-StringBuffer-и-StringBuilder)

[55. Каким образом производится экранирование символов и зачем это нужно?](#55-Каким-образом-производится-экранирование-символов-и-зачем-это-нужно)

[56. Что такое управляющие последовательности?](#56-Что-такое-управляющие-последовательности)

[28. Для чего используется конструктор в абстрактном классе?](#28-Для-чего-используется-конструктор-в-абстрактном-классе)

[29. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?](#29-Можно-ли-создать-анонимный-класс,-если-в-классе-нет-конструктора-по-умолчанию)

[30. Что такое композиция?](#30-Что-такое-композиция)

[31. Что такое агрегация?](#31-Что-такое-агрегация)


[35. ](#35-)

## 1. Что такое ООП?
**Ответ 1**

Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Согласно парадигме ООП, программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием,  единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние. Сообщение — это запрос на выполнение действия,дополненный набором аргументов, которые могут понадобиться при выполнении действия. Если объект должен «отвечать» на это сообщение, то у него должна иметься соответствующий данному сообщению метод.

достоинства ООП:
- быстрое расширение программы путем добавления новых элементов
- хорошая читаемость кода
- возможность повторного использования написанного кода
- относительная простота написания кода

недостатки ООП:
- увеличенное потребление памяти за счет использования объектов
- меньшая производительность, так как внутренняя реализация предоставляемых языком средств тоже требует затрат

**Ответ 2**\
Подход (методология) к программированию ориентированный на объекты. Представление программы в виде совокупности объектов, 
каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Важным элементом ООП является абстракция. Эффективным средством применения абстракции служат иерархические конструкции.
Это позволяет упрощать понимание сложных систем, разбивая их на более управляемые части.

Например, внешне автомобиль выглядит единым объектом. Но внутрион состоит из нескольких подсистем: 
рулевого управления, двигатель, тормоза, аудиосистемы и т.п. 
Каждая из этих подсистем, также собрана из более специализированных узлов. 
Т.е. структуру автомобиля (или любой сложной системы) можно описать с помощью иерархических абстракций.
Это применимо и к компьютерным программам.

Суть ООП - с помощью абстракций организовать данные компьютерной программы в виде объектов, а последовательность этапов 
ее выполнения — в совокупность сообщений, передаваемых между этими объектами. Т.е. каждый из этих объектов описывает 
свое особое поведение. Эти объекты можно считать конкретными сущностями, реагирующими на сообщения, 
предписывающие им выполнить конкретное действие.

**Сылки**\
https://job4j.ru/profile/exercise/20/task-view/132

https://habr.com/ru/articles/463125/

https://oracle-patches.com/coding/3720-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%BE%D0%BF

[к оглавлению](#OOP)

## 2. Базовые концепции ООП?

+ **Инкапсуляция** - свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. 
Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации».

+ **Наследование** - свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью 
заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским 
или суперклассом.

+ **Полиморфизм** - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней 
структуре объекта.

+ **Абстракция** - выделение значимой информации и исключение из рассмотрения незначимой.

+ **Класс** - способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). С точки зрения программирования класс можно рассматривать как набор полей и методов. С точки зрения структуры программы, класс является сложным типом данных.
+ **Объект/ экземпляр** - это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.


[к оглавлению](#OOP)

## 3. Укажите из каких элементов состоит класс?

Класс состоит из полей (атрибуты) и методов (функции для работы с этими полями). 
Поле (атрибут) класса — это характеристика объекта, содержит его состояние. 
Например для фигуры это может быть название, площадь, периметр.
У методов есть главная задача — они должны выполнять действия над данными объекта. Менять значение данных объекта, преобразовывать их, выводить в консоль или делать с ними что-то другое

Класс является ссылочным типом данных. Это шаблон для создания объекта, в свою очередь объект - это экземпляр класса.

Типы полей:

+ локальные переменные - определены внутри методов, конструкторов или иных блоков кода (циклы, итераторы и т.д.)
Они объявляются и уничтожаются по завершении работы метода.

+ переменные экземпляра - доступны в пределах класса и из любого метода, конструктора или иных блоков кода 
конкретного класса (циклы, итераторы и т.д.).

+ статические переменные - объявляются в классе вне любого метода с помощью ключевого слова `static`.

[к оглавлению](#OOP)

## 4. Что такое конструктор Типы конструкторов?

**Конструктор** — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с 
операцией `new`).
 
Конструктор нужен для автоматической инициализации переменных, т.е. он инициализирует объект непосредственно во время создания. 
Имя конструктора совпадает с именем класса, включая регистр, 
а по синтаксису конструктор похож на метод без возвращаемого значения `void`.

Существуют:

+ конструктор по умолчанию или неявный (без параметров - позволяет регулировать, какие параметры и в каком количестве
нужно задать для создания объекта определенного класса).

+ конструктор с параметрами или явный.

Модификатор доступа у конструктора по умолчанию зависит от модификатора доступа класса

[к оглавлению](#OOP)

## 5. Можно ли наследовать конструктор?

Нет, но ему можно передать аргументы с помощью `super`.

В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса.
Конструкторы не являются членами, поэтому они не наследуются, но конструктор суперкласса м.б. вызван из подкласса. Конструктор не может быть переопределен

По аналогии с ключевым словом this, super может быть использован для следующих целей:

1. Для вызова конструктора суперкласса:/
super(список_параметров_конструктора)/
2. Для вызова метода суперкласса:/
super.название_метода(список_ параметров _метода)
 
 Конструктор **не может** быть объявлен как ***final, static, synchronized или abstract***

[к оглавлению](#OOP)

## 6. Что такое перегрузка конструктора?

**Перегрузка конструктора** - это создание конструкторов с другим набором аргументов (как по количеству, так 
и по порядку следования).

Перегрузка конструктора позволяет установить различные способы начальной инициализации объектов класса.

Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), 
то его нужно создать явно.

[к оглавлению](#OOP)

## 7. Что такое статический метод?

**Статический метод** - это метод, который можно вызвать без создания объекта, напрямую через имя класса.

Особенности статических методов:
+ Статические методы нельзя переопределять. Метод с модификатором static относится к классу, а не к его объектам. Для него работает статическое связывание, поэтому именно переопределение (override) в дочернем классе не работает;
+ Статические методы не могут использовать ключевые слова this (ссылка на текущий объект) или super (ссылка на объект суперкласса);
+ Статические методы могут обращаться к статическим переменным и статическим методам. Это гарантирует, что во время выполнения нашего 
метода все элементы будут инициализированы и будут работать. Это называется "статическим контекстом";
+ Статические методы могут обращаться ко всем статическим переменным и другим статическим методам. Однако они не могут напрямую обращаться к переменным класса и нестатическим методам. Для этого им нужны ссылки на объект;
+ В отличие от локальных переменных статические поля и методы не потокобезопасны в Java;

Статические методы обычно используются для выполнения операции, не зависящей от создания экземпляра. При этом, они широко используются для создания служебных (утилитных) или вспомогательных классов, поскольку их можно вызывать без создания объекта этих классов.

[к оглавлению](#OOP)

## 8. Что такое не статический метод?

**Не статический метод** - это метод, для работы которого необходим объект. Т.е. он принадлежит объекту класса и 
может быть вызван с помощью ссылки на данный объект.

Нестатические методы могут обращаться непосредственно как к методам класса (включая статические), так и к переменным класса (включая статические);

[к оглавлению](#OOP)

## 9. Для чего используется ключевое слово this?

Ключевое слово `this` представляет ссылку на текущий экземпляр класса. Через это ключевое слово мы можем обращаться к переменным, методам объекта, а также вызывать его конструкторы

соответственно, `this` используется:

1. в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса. 
Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.
```java
class Student {
    int age;
    Student (int age) {
        this.age = age;
    }
}
```
2. когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризированном). 
Вызов `this()` может находиться только в первой строке конструктора.
```java
public class Toy {
    String name;
    int cost;
    String manufacturer;
    int age;

    public Toy(String name, int cost, String manufacturer, int age) {
        this(name, cost, manufacturer);
        this.age = age;
        System.out.println("В конструкторе с четырьмя параметрами");
    }

    public Toy(String name, int cost, String manufacturer) {
        this();
        this.name = name;
        this.cost = cost;
        this.manufacturer = manufacturer;
        System.out.println("В конструкторе с тремя параметрами");
    }

    public Toy() {
        System.out.println("В конструкторе по умолчанию");
    }
}
public class ToyDemo {
    public static void main(String[] args) {
        Toy toy = new Toy("Кукла", 34, "Disney", 3);
    }
}
```
вывод:
```
В конструкторе по умолчанию
В конструкторе с тремя параметрами
В конструкторе с четырьмя параметрами
```
* И this, и super — это нестатические переменные, соответственно их нельзя использовать в статическом контексте, а это означает, что их нельзя использовать в методе main
* Внутри конструктора this и super должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и this(), и super().
* Каждый конструктор при отсутствии явных вызовов других конструкторов неявно вызывает с помощью super() конструктор без аргументов родительского класса, при этом у вас всегда остается возможность явно вызвать любой другой конструктор с помощью либо this(), либо super()

[к оглавлению](#OOP)

## 10. Какой класс является базовый родительным классов для всех классов?
**Ответ 1**

`Object` - корневой класс в иерархии классов Java. 

Все непримитивный типы, включая массивы, наследуют прямо или косвенно от него.
Поэтому ссылочная переменная класса `Object` может ссылаться на объект любого другого класса.

Ключевое слово `super` представляет текущий экземпляр родительского класса.

**Ответ 2**

Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы:
```
public boolean equals(Object obj) – служит для сравнения объектов по значению;
int hashCode() – возвращает hash код для объекта;
String toString() – возвращает строковое представление объекта;
Class getClass() – возвращает класс объекта во время выполнения;
protected Object clone() – создает и возвращает копию объекта;
void notify() – возобновляет поток, ожидающий монитор;
void notifyAll() – возобновляет все потоки, ожидающие монитор;
void wait() – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
void wait(long timeout) – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
void wait(long timeout, int nanos) – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
protected void finalize() – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.
```
[к оглавлению](#OOP)

## 11. Что такое наследование Приведите примеры из реальной жизни?

Это когда один объект перенимает все публичные поля и методы другого объекта. // Свойства родительского элемента доступны дочернему элементу. Это и есть наследование. 

Автомобили -> Легковые -> Модель1, Модель2.

Млекопитающие -> Киты -> Голубой кит, горбатый кит.

Элементы наследования

Давайте перечислим элементы, которые есть в классе и отметим, какие из них наследуются.

1. Конструкторы. Этот элемент не наследуются, но он активно принимает участие в наследовании. Каждый из описанных пунктов будет рассмотрен ниже в этом модуле. Сейчас ваша задача понять смысл наследования, а не разобраться в его деталях.

2. Поля класса. Они могут наследоваться и использоваться в дочернем классе, но я настоятельно не рекомендую это делать. В разделе "Инкапсуляция" мы рассмотрим тему использования полей через наследование. 

3. Методы. Самый интересный для нас элемент в теме наследования. Они то и делают основную работу в наследовании. 

[к оглавлению](#OOP)

## 12. Опишите процесс создания нового объекта?

Объект создается с помощью ключевого слова `new`, которое вызывает конструктор класса, который инициализирует начальное 
состояние объекта.

```java
Book b;         // объявление переменной определенного типа/класса
b = new Book(); // инстационирование/создание (выделение памяти под объект) и инициализация объекта;
```

Кроме конструктора начальную инициализацию объекта можно проводить с помощью инициализатора объекта (блока инициализации). 
Инициализатор выполняется до любого конструктора. Т.е. в инициализатор мы можем поместить код, общий для всех конструкторов.

https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
https://metanit.com/java/tutorial/3.1.php
https://www.baeldung.com/java-initialization

**Последовательность инициализации блоков класса и его родителя:**
+ Сначала вызываются все статические блоки от первого предка до последнего наследника.
+ Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности 
(от предка до последнего потомка).

**Порядок инициализации объекта для случая наследования классов:**

 *Статические поля класса Parent;\
 Статический блок инициализации класса Parent;\
 Статические поля класса Сhild;\
 Статический блок инициализации класса Child;\
 Нестатические поля класса Parent;\
 Нестатический блок инициализации класса Parent;\
 Конструктор класса Parent;\
 Нестатические поля класса Сhild;\
 Нестатический блок инициализации класса Сhild\
 Конструктор класса Сhild.*

https://ru.stackoverflow.com/questions/629700/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2-%D1%80%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8F-%D0%B8-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0-%D0%BF%D1%80%D0%B8-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8

[к оглавлению](#OOP)

## 13. Как вызвать метод из родительского класса?

Если метод родительского класса переопределен, а нужно вызвать оригинальную версию метода, то нужно 
использовать ключевое слово `super`, которое представляет текущий экземпляр родительского класса.

> так делать никогда не нужно. В целом механизм наследования старайтесь никогда не использовать.

[к оглавлению](#OOP)

## 14. Что такое переопределение метода?

Это возможность задать методу родительского класса другой функционал. 

При этом сигнатура (имя метода плюс параметры, причем порядок параметров имеет значение) метода и тип возвращаемого 
значения должны совпадать с сигнатурой и типом возврата в базовом классе.

При переопределении метода в классе:
- можно менять модификатор доступа в сторону расширения доступа
- нельзя изменить сигнатуру метода
- нельзя переопределить конструктор ???

Важно! Переопределять можно только нестатические методы, тогда их поведение будет как в этом уроке. Если же мы попытаемся переопределить статический метод, это будет называться "сокрытием метода из суперкласса". 

https://habr.com/ru/company/otus/blog/347900/

[к оглавлению](#OOP)

## 15. Можно ли переопределить статический метод?

Нет, статический метод создается при инициализации класса один на все объекты.

[к оглавлению](#OOP)

## 16. Что такое сокрытие метода?

Сокрытие методов, грубо говоря, представляет из себя "перекрытие" методом текущего класса, метода родительского класса. Выглядит это следующим образом:
```java
public class App {
    public static void main(String[] args) {
        Dog.voice(); // Вывод: Гав
    }
}

class Animal {
    public static void voice() {
        System.out.print("звук");
    }
}
class Dog extends Animal {
    // Метод определенный в классе-наследнике идентичный по сигнатуре с методом родительского класса
    public static void voice() {
        System.out.print("Гав");
    }
}
```
Сигнатуры методов этих двух классов идентичны, т.е. в классе родителе Animal есть public static void voice() и в классе-наследнике Dog есть public static void voice(). Следовательно вызов Dog.voice() будет вызывать метод определенный в классе Dog

Важно отметить, что перекрытие требует таких же правил как и переопределение метода.
> Переопределенный метод должен иметь тот же модификатор доступа что его родитель, принимать аргументы как его родитель, и иметь возвращаемый тип такой же как у его родителя

Использование без схожего по сигнатуре метода
```java
public class App {
    public static void main(String[] args) {
        Dog.voice(); // Вывод: звук
    }
}

class Animal {
    public static void voice() {
        System.out.print("звук");
    }
}

class Dog extends Animal {  
    public static void dog_voice() {
        voice();
    }
}
```

[к оглавлению](#OOP)

## 17. Что такое виртуальная функция и используются ли они в Java?

**Виртуальная функция** - это функция (метод), которая может быть переопределена наследником.
 
В Java практически все функции виртуальные (`private` функции не могут быть переопределены в связи с правами видимости). Статические методы принадлежат классу и не могут быть переопределены, поэтому они не являются виртуальными функциями.

[к оглавлению](#OOP)

## 18. Что такое перегрузка метода?

**Перегрузка метода** - это наличие в классе нескольких методов с одним именем, но разными наборами параметров и порядком параметров.

Перегрузить можно не только метод, но и конструктор.

При вызове перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые 
указываются при вызове.

> Сигнатура метода - это сочетание имени метода и список параметров вместе с типами этих параметров. Больше никакие части объявления метода не входят в сигнатуру метода. 

[к оглавлению](#OOP)

## 19. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?

Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать.

Т.е. если меняем тип возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.

https://habr.com/ru/company/otus/blog/347900/

[к оглавлению](#OOP)

## 20. Что такое множественное наследование Как его можно реализовать в Java?

Множественное наследование - это наследование класса от нескольких суперклассов одновременно. 

В Java запрещено множественное наследование главным образом из-за ромбовидной проблемы. 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_1.png)

возникает неоднозначность: если метод класса D вызывает метод класса А (и этот метод не переопределён в классе D), 
а классы B и C по своему переопределили этот метод, то от какого класса его наследовать? от B или C?

В Java множественное наследование поддерживают интерфейсы.

Если есть необходимость использовать методы из двух разных классов, то можно воспользоваться композицией. 
Для этого в третьем классе нужно создать два необходимых объекта, добавить методы, которые 
обращаются к нужным методам этих объектов. И наследоваться от этого класса.

[к оглавлению](#OOP)

## 21. Что такое полиморфизм Приведите примеры из реальной жизни?

Полиморфизм описывают выражением: *Один интерфейс - множество реализаций.* 

**Полиморфизм** - это возможность работать с несколькими типами, как будьто это один и тот же тип, 
в то же время поведение каждого типа будет уникальным в зависимости от его реализации. 

**Примеры:** 
+ Пульт управления один для разных моделей. 
+ Монетоприемник в каком-нибудь продающем автомате. 
+ Цоколь лампочки - это переменная определенного базового типа. Лампочка - созданный объект конкретного класса. 
Лампочки разные - цоколь один.

[к оглавлению](#OOP)

## 22. Что такое инкапсуляция?

**Инкапсуляция** - это сокрытие реализации и отделение его внутреннего представления от внешнего.

Т.е. это скрытие полей объектов, ограничение доступа к определенным методам и полям.

Инкапсуляция - это когда мы собираем вместе какие-либо относящиеся друг к другу данные и методы управления ими, то есть получаем некий контейнер (класс). А с помощью сокрытия (модификаторов доступа) мы указываем к каким данным или методам будет или не будет доступ извне класса. Таким образом, можно применить инкапсуляцию без сокрытия, но сокрытие отдельно от инкапсуляции применить нельзя.

Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании. Инкапсуляция в Java означает ограничение доступа к данным и возможностям их изменения.

[к оглавлению](#OOP)

## 23. Как реализована инкапсуляция в Java?

+ специальные методы - геттеров и сеттеров.

+ модификаторы доступа - специальные слова, которые определяют доступ к данным.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_2.png)

Например, модификатором доступа private скрываются поля объекта, 
и при необходимости к ним разрешается подкотрольный доступ через геттеры и сеттеры.

[к оглавлению](#OOP)

## 24. Можно ли применить модификаторы доступа к конструкторам?

В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.

[к оглавлению](#OOP)

## 25. Что такое интерфейс?

Интерфейсы задают описание, как должен работать объект. Интерфейсы не содержат реализации.
 
Инерфейс позволяет создавать общий тип данных для разных объектов, т.е. использование интерфейса гарантирует 
наличие определенного метода у объекта.
 
При реализации интерфейса класс реализовать все его методы, иначе он должен быть помечен как `abstract`.
 
Если у интерфейса только один абстрактный метод, перед нами функциональный интерфейс.

Задача интерфейса — снизить уровень зависимости сущностей друг от друга, добавив больше абстракции.

Основная цель использования интерфейсов — реализация полиморфизма (способность объектов принимать множество форм).

Interface  - это элемент, который содержит объявления методов, но не содержит реализации этих методов. Интерфейс будет определять, что должен делать класс, но он не знает как. Полиморфизм осуществляется за счет элемента interface. 

[к оглавлению](#OOP)

## 26. Перечислите элементы, которые может содержать интерфейс.

+ ***поля*** - константы `public static final`;
+ ***абстрактные методы*** - задают то, как должен работать наш объект, но не определяют как конкретно;
+ ***статические методы*** - можем добавлять с Java 8 как обычные `static` методы. Принадлежат только интерфейсу, в котором объявлены, и не наследуются ни классами, реализующими интерфейс, ни интерфейсами-наследниками.
+ ***дефолтные методы*** - так же, как и статические, они имеют реализацию, но при их объявлении используется ключевое слово default.Главное отличие дефолтного метода в том, что он будет унаследован классом, который реализует данный интерфейс. При этом класс может как переопределить данный метод, так и не переопределять и воспользоваться реализацией по умолчанию.Дефолтные методы удобно использовать, если в классах, имплементирующих один и тот же интерфейс, должен быть объявлен метод с одинаковой реализацией.
+ ***приватные методы*** (Java 9) - могут быть как статическими, так и нестатическими. Эти методы используются в интерфейсах для того, чтобы вынести какую то логику из публичных статических или дефолтных методов, либо для предотвращения дублирования кода. В приватный метод можно убрать все детали реализации, чтобы уменьшить пользовательский код и упростить его читаемость, также в private методы нужно убирать задвоившийся код.
+ интерфейсы могут содержать ***вложенные классы и интерфейсы***, но такие конструкции используются очень редко. Внутренние классы и интерфейсы всегда public и static.
+ ***обобщенные типы (generics)*** используются вместо указания конкретного типа, тем самым интерфейс может работать с разными типами данных, то есть отпадает необходимость писать несколько одинаковых реализаций, отличающихся только типом данных.
+  интерфейсе возможно объявить ***Enum (перечисление)***.

!!Интерфейс не может содержать конструкторов, так как интерфейс - это абсолютная абстракция, то есть вся реализация возложена на классы-реализации. По причине отсутствия конструкторов создать экземпляр интерфейса невозможно.

[к оглавлению](#OOP)

## 27. Можно ли создать объект интерфейса? Если да, то как?

Поскольку, интерфейс содержит только объявление без реализации, то создать экземпляр интерфейса нельзя. Однако, ссылку на интерфейс объявить можно. Но при выделении памяти оператором new должен указываться конструктор класса, который реализует данный интерфейс.

[к оглавлению](#OOP)

## 28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?

***статические методы*** - можем добавлять с Java 8 как обычные `static` методы. Принадлежат только интерфейсу, в котором объявлены, и не наследуются ни классами, реализующими интерфейс, ни интерфейсами-наследниками.

```java
public interface Vehicle extends Fuel {
    int WHEELS = 4;

    void changeGear();

    void accelerate();

    void steer();

    void brake();

    static void getDragCoefficient() {
        System.out.println("Формула расчета коэффициента аэродинамического сопротивления автомобиля");
    }

}
```
***дефолтные методы*** - так же, как и статические, они имеют реализацию, но при их объявлении используется ключевое слово default.Главное отличие дефолтного метода в том, что он будет унаследован классом, который реализует данный интерфейс. При этом класс может как переопределить данный метод, так и не переопределять и воспользоваться реализацией по умолчанию.Дефолтные методы удобно использовать, если в классах, имплементирующих один и тот же интерфейс, должен быть объявлен метод с одинаковой реализацией.

```java
public interface Vehicle extends Fuel {
    int WHEELS = 4;

    void changeGear();

    void accelerate();

    void steer();

    void brake();

    static void getDragCoefficient() {
        System.out.println("Формула расчета коэффициента аэродинамического сопротивления автомобиля");
    }

    default void chargeBattery() {
        System.out.println("Аккумулятор под капотом. Зарядить.");
    }

}
```
***приватные методы*** (Java 9) - могут быть как статическими, так и нестатическими. Эти методы используются в интерфейсах для того, чтобы вынести какую то логику из публичных статических или дефолтных методов, либо для предотвращения дублирования кода. В приватный метод можно убрать все детали реализации, чтобы уменьшить пользовательский код и упростить его читаемость, также в private методы нужно убирать задвоившийся код.

```java
public interface Func1 {

    default double func(double x, double y) {
        return x * x - 2 * y + 30;
    }

    default void funcMessage() {
        System.out.println("Сообщение из Func1");
    }

    default int getDoubleSum(int[] numbers) {
        return getSum(numbers) * 2;
    }

    default double getAverage(int[] numbers) {
        return getSum(numbers) * 1.0 / numbers.length;
    }

    private int getSum(int[] numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }

}
```

[к оглавлению](#OOP)

## 29. Что такое абстракция?

Абстракция - это выделение значимой информации и исключение из рассмотрения незначимой. 

С помощью принципа абстракции программа разбивается на объекты. 
Информация в программе обрабатывается в виде цепочки действий между отдельными объектами. 

Главное достоинство абстракции связано с тем, что она позволяет отделить реализацию объектов от их описания.

**Пример:** описание узлов в автомобиле. Здесь название узла значимая информация, 
а описание обязанностей у каждого узала это второстепенная информация. 
Наример, главной характеристикой для трансмиссии будет то, что этот узел передает крутящий момент от двигателя колесам, 
а как именно (механика, автомат, робот) это уже второстепенная информация (это вопрос конкретной реализации).

Абстракция - это парадигма ООП, которая подразумевает набор важных характеристик объекта, доступных из любого места программы. То есть абстракция выделяет значимые свойства объекта и отбрасывает незначимые.

[к оглавлению](#OOP)

## 30. Что такое абстрактный класс?

Абстрактные классы позволяют описать общее поведение и задать особенное поведение для классов наследников.В нем абстрагируются (выделяются) главные свойства объекта, то есть предоставляется базовый функционал для классов-наследников, которые будут этот функционал реализовывать.Абстрактный класс - это заготовка под будущую реализацию.

Абстрактный класс представляет собой отношение IS-A. IS-A описывает отношение, когда объект B является подтипом объекта А.

+ поля - содержат состояние объекта;
+ конструктор - инициализирует начальное состояние объекта;
+ абстрактные методы - не содержат реализации, а декларируют, что данный метод будет иметь реализацию в наследуемом классе;
+ методы - позволяют выполнять действия над объектом.
```java
public abstract class BaseAction {
    private final int key;
    private final String name;
    
    protected BaseAction(final int key, final String name) {
        this.key = key;
        this.name = name;
    }
    
    public abstract void execute(Input input, Tracker tracker);
    
    public String info() {
        return String.format("%s:%s", this.key, this.name);
    }
}
```

применение:
```java
public class AddItem extends BaseAction {
    public AddItem(int key, String name) {
        super(key, name);
    }
    
    @override
    public abstract void execute(Input input, Tracker tracker) {
        String name = input.ask("Enter name:");
        String desc = input.ask("Enter descriotion:");
        tracker.add(new Item(name, desc));
    }
}
```

+ Чтобы создать абстрактный класс нужно использовать ключевое слово `abstract` перед именем класса. 

+ Нельзя создать объект абстрактного класса.

+ В таком классе могут быть абстрактные методы, которые обязан реализовать дочерний класс.
Абстрактные методы могут быть только в абстрактном классе. ???

+ В абстрактном классе можно создавать обычные методы. 
Они наследуются также, как и для неабстрактных классов.

[к оглавлению](#OOP)

## 31. Сколько абстрактных методов должен и может содержать абстрактный класс?

Согласно документации класс, объявленный как abstract, является абстрактным. Такой класс может включать, а может и не включать абстрактные методы. Обычно класс называют абстрактным, если он имеет хотя бы один абстрактный метод. Все абстрактные методы должны быть переопределены в классах-наследниках. Если какой-то абстрактный метод остается не переопределённым в классе-наследнике, то класс-наследник тоже нужно объявить абстрактным. Если мы объявим абстрактным класс без абстрактных методов, то это не будет иметь смысла и будет только путать, в том числе из-за этого нельзя будет создать экземпляр такого класса, поэтому объявляя класс абстрактным, нужно четко понимать, зачем вы это делаете. 

[к оглавлению](#OOP)

## 32. Может ли абстрактный класс содержать обычные методы?

В абстрактном классе можно создавать обычные методы. Они наследуются также, как и для неабстрактных классов. 

Методы абстрактного класса не обязательно должны быть все абстрактными. Если реализация какого-либо метода общая для всех наследников, можно определить ее в абстрактном классе. 

[к оглавлению](#OOP)

## 33. Сколько объектов абстрактного класса можно создать в программе?

Ни одного. экземпляр/объект абстрактного класса создать нельзя

[к оглавлению](#OOP)

## 34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?

Все абстрактные методы должны быть переопределены в классах-наследниках. Если какой-то абстрактный метод остается не переопределённым в классе-наследнике, то класс-наследник тоже нужно объявить абстрактным.

[к оглавлению](#OOP)

## 35. Чем отличается интерфейс от абстрактного класса?
 
1. Абстрактный класс содержит состояние объекта, что в интерфейсе невозможно,
т.к. поля там являются константами

2. Наследовать `extends` можно только один абстрактный класс, а реализовать `implements` интерфейсов сколько угодно. 
Интерфейс может наследовать другой интерфейс.

3. В интерфейсах нет конструкторов.

Замечание: 

Абстрактные классы используются, когда есть отношение `is-a`, т.е. класс наследник расширяет базовый абстрактный класс.
 Интерфейс же могут быть реализованы разными классами, вовсе не связанными друг с другом.

Поэтому код, написанный на интерфейсах более масштабируем и его легче поддерживать.
При использовании абстрактных классов, а это всегда наследование, мы связываем наш код.

Интерфейсы могут наследовать другие интерфейсы. В данном случае при реализации классом интерфейса-наследника, в этом классе должны быть переопределены методы обоих интерфейсов. Наследовать интерфейсы могут только другие интерфейсы, но не классы.

**Дополнение**
**Отличия интерфейса и абстрактного класса.**

Абстрактный класс - это класс, у которого не реализован один и более методов. Нужен для реализации семейства классов (Отношение IS-A). Выглядит как заготовка под будущую реализацию. Также это средство для повторного использования кода.

Интерфейс - это абстрактный класс, в котором все методы не реализованы (помимо default, private, static), а также нет нестатических переменных. Интерфейс задаёт семантику класса. Вы всегда будете уверены, что класс, который реализует какой-либо интерфейс, реализует и все его методы, то есть поддерживает заданную семантику.

Любой интерфейс - это по существу абстрактный класс, но не наоборот. Несмотря на их схожесть, реального сходства между абстрактным классом и интерфейсом очень мало.

[к оглавлению](#OOP)

## 36. Что такое вложенные классы? Зачем они нужны?

В Java есть возможность определить класс внутри другого класса. Класс, полностью находящийся внутри другого класса, называется вложенным.

Вложенные классы могут быть статическими и нестатическими

Все вложенные классы выглядят как обычные классы - они могут иметь свои переменные и методы. Вложенный класс считается членом внешнего класса. Область видимости вложенных классов ограничена внешним классом (классом, внутри которого они определены). В примере выше это OuterClass. Вложенные классы не могут существовать самостоятельно (то есть их нельзя использовать отдельно от класса, в который они вложены). Вложенные классы имеют прямой доступ к членам внешнего класса (в том числе и private). Внешний класс не имеет прямого доступа к членам вложенных в него классов.

Основные случаи применения вложенных классов (всех видов): 

- Логическая группировка классов, использующихся в одном месте. Если какой-то класс создан для использования только одним другим классом, то стоит вложить его в этот класс, чтобы показать связь этих классов.

- Повышение инкапсуляции. Если класс Y вынужден обращаться к членам класса X, которые иначе были бы объявлены с модификатором private, то следует вложить класс Y  в класс X. В таком случае эти члены можно будет объявить с модификатором private, но класс Y сможет к ним обращаться, а также класс Y будет скрыт от окружающего мира.

- Облегчение чтения и поддержки кода. Небольшие классы можно вложить во внешние классы, поближе к месту их применения.

Вложенные классы применяются, когда нужно написать вспомогательный код для другого класса. Также вложенные классы скрывают переменные и методы от остальной части программы, что является хорошим способом ограничения области их видимости.

[к оглавлению](#OOP)

## 37. Какие типы вложенных классов существуют в Java?

Вложенные классы могут быть статическими и нестатическими

Внутренними (inner) называются нестатические вложенные классы.

Внутренние классы могут быть:

- просто внутренними (обычный нестатический внутренний класс). 

- локальными (класс, находящийся внутри некоторого блока кода другого класса (между фигурными скобками { }).

- анонимными (локальный класс без имени).

![imageTaskSource](https://user-images.githubusercontent.com/97846877/236560262-837b0ff4-9414-43ec-b1d9-256aa498ab06.png)

[к оглавлению](#OOP)

## 38. Что такое внутренний класс? Когда он применяется?

внутренние классы-члены, пример InnerClass:
    ```java
    public class OuterClass { 
         //определены внутри класса
        public class InnerClass{ } 
    } 
    
    //создание экземпляра класса 
    OuterClass outerClass = new OuterClass(); 
    OuterClass.InnerClass innerClass = outerClass.new InnerClass();
    ```

некоторые технические особенности внутренних классов:
- Объект внутреннего класса может обращаться к объекту внешнего класса, но не наоборот.
- Использование нестатических переменных внешнего класса.
- Создание объекта внутреннего класса в static-методе внешнего класса.

Когда применяется? см выше про вложенные классы

**Вложенный класс (InnerClass)**

**Из него видны:**
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

**Его видно:**
— согласно модификатору доступа.

**Может наследовать:**
— обычные классы.
— такие же внутренние классы в OuterClassе и его предках.

**Может быть наследован:**
— таким же внутренним классом в OuterClassе и его наследниках.

**Может имплементировать интерфейс**

**Может содержать:**
— только обычные свойства и методы (не статические).

https://job4j.ru/profile/exercise/20/task-view/1030

https://habr.com/ru/articles/342090/

https://habr.com/ru/post/439648/

[к оглавлению](#OOP)

## 39. Что такое статический вложенный класс? Когда он применяется?

пример StaticInnerClass:
```java
public class OuterClass { 
    //определены внутри класса
    public static class StaticInnerClass{ 
    } 
} 

//создание экземпляра класса 
OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();
```

Cтатическим элементам не требуется ссылка на какой-либо объект. Статический вложенный класс не привязан к объекту, объект статического вложенного класса не хранит в себе ссылку на внешний класс. Статический вложенный класс можно использовать, когда прямая связь между вложенным и внешним классом не требуется. Например, мы можем скрыть во внешнем классе реализацию чего-либо или другую информацию. 

То есть если вложенный класс является неотъемлемой частью внешнего класса, он должен быть внутренним, а если прямой связи нет, то его можно сделать статическим вложенным классом. При этом важно не забывать, что делать классы вложенными требуется только для логической группировки классов (если одни классы являются частью других, либо инкапсулируют что-либо из внешнего класса), чтобы повысить читаемость кода (все связанные классы будут в одном месте), а также повысить инкапсуляцию, вложив одни классы в другие. Если у рассматриваемых классов нет связи между собой, то и делать вложенность не требуется.

Основные свойства статических вложенных классов:

1) Как и другие статические члены, они принадлежат внешнему классу, а не экземпляру класса.
2) В их объявлении может быть указан любой модификатор доступа.
3) Они могут определять как статические, так и нестатические члены.
4) Они имеют доступ только к статическим членам во внешнем классе (включая private).

Выводы по вложенному статическому классу:

- Применяется при отсутствии прямой связи с внешним классом (не является его частью).
- Может содержать в себе статические и нестатические переменные и методы.
- Изнутри этого класса есть доступ только к статическим переменным и методам внешнего класса (в том числе и private). К нестатическим полям и методам внешнего класса доступ можно получить только через ссылку на экземпляр внешнего класса.
- Сам класс виден окружающим согласно установленному модификатору доступа.

**Статический вложенный класс (StaticInnerClass)**

**Из него (самого класса) видны:**
— статические свойства и методы OuterClassа (даже private).
— статические свойства и методы родителя OuterClassа public и protected. То есть те, которые видны в OuterClassе.

**Из его экземпляра видны:**
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

**Его видно:**
— согласно модификатору доступа.

**Может наследовать:**
— обычные классы.
— такие же статические внутренние классы в OuterClassе и его предках.

**Может быть наследован:**
— любым классом:
— вложенным
— не вложенным
— статическим
— не статическим!

**Может имплементировать интерфейс**

**Может содержать:**
— статические свойства и методы.
— не статические свойства и методы.

https://job4j.ru/profile/exercise/20/task-view/1031

[к оглавлению](#OOP)

## 40. Сколько объектов статического вложенного класса можно создать в программе?

Объектов статического вложенного класса можно создать сколько угодно. Не путайте со статической переменной, которая создаётся только одна на всю программу.

[к оглавлению](#OOP)

## 41. Что такое локальный класс? Когда он применяется?

локальные классы, пример LocalClass:
```java
    public class OuterClass { 
        
        public void someMethod() { 
            
            //определены внутри метода или блока кода
            class LocalClass{}  
        }       
    }
```

Локальный класс - это разновидность внутреннего класса, в которой класс объявляется в другом классе внутри какого-либо блока кода (между фигурными скобками { }). Например, в теле оператора if, цикле for, методе, конструкторе и т.д. По своим свойствам локальный класс похож на обычный внутренний класс, но с некоторыми отличиями.

Локальный класс можно объявить везде, где возможно объявить локальную переменную. Область видимости локального класса такая же, как и у локальной переменной. У локальных классов есть имя, и их можно использовать неоднократно.

Область видимости локального класса такая же, как и у обычной локальной переменной - виден только в блоке кода, в котором он объявлен.

Локальные классы связаны с внешним классом (как и внутренние классы), поэтому у них есть доступ ко всем членам внешнего класса (даже к private). Локальные классы содержат ссылку на внешний класс только в нестатическом контексте, подобно обычным внутренним классам.

В объявлении локального класса допустим только один модификатор - final, который имеет обычное значение в виде запрета наследования этого класса. Остальные модификаторы объявить невозможно, так как локальный класс не является членом внешнего класса, а относится к блоку кода, в котором он объявлен.

Время жизни локального класса ограничено блоком кода, в котором он находится, либо пока в программе остаются рабочие ссылки на этот класс. 

Также локальные классы не могут содержать в себе статические объявления (классы, методы и т.д.). Допустимы только переменные-константы.

**Важно!** В Java 16 произошло обновление, начиная с которого все виды внутренних классов поддерживают статические объявления, чтобы иметь возможность объявлять в себе record, enum и локальные интерфейсы, все из которых являются неявно статическими при объявлении их во внутреннем классе.

Если локальный класс находится внутри статического метода, он имеет доступ только к статическим переменным внешнего класса.

За пределами внешнего класса локальные классы недоступны, но экземпляры локальных методов можно использовать как и обычные классы, используя их в качестве аргументов или возвращаемых значений.

У локальных классов есть доступ к локальным effectively final переменным* метода, в котором он определён.

> * ***Effective final переменная*** - это переменная, которая никогда не меняется после её инициализации. Её запись в программе выглядела бы как запись обычной переменной. Главное условие, что она не должна меняться после инициализации

**Когда применяется?**

Локальный класс применяется, когда нужно написать класс, который планируется использовать в пределах одного метода или другого блока кода. Локальные классы следует писать короткими, чтобы не ухудшать читаемость кода.

Локальные классы - это просто способ инкапсуляции некоторого состояния и поведения локально. Применяется очень редко.

**Локальный класс (LocalClass)**

**Из него видны:**
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

**Его видно:**
— только в том методе где он определён.

**Может наследовать:**
— обычные классы.
— внутренние классы в OuterClassе и его предках.
— такие же локальные классы определённые в том же методе.

**Может быть наследован:**
— таким же локальным классом определённом в том же методе.

**Может имплементировать интерфейс**

**Может содержать:**
— только обычные свойства и методы (не статические).

[к оглавлению](#OOP)

## 42. Что такое анонимный класс? Когда он применяется?

**Анонимный класс** - это класс, который сразу создается и реализуется (без имени класса) от суперкласса или интерфейса.

анонимные классы, пример:
```java
    public class OuterClass { 
        
        public void someMethod() { 
            
            Callable callable = new Callable() { 
                @Override 
                public Object call() throws Exception { 
                    return null; 
                } 
            };            
        }         
    }
``` 

Анонимный класс - это локальный класс без имени. Анонимным классом следует пользоваться, если нужен локальный класс для одноразового использования. 

Анонимный класс может обращаться к переменным и методам внешнего класса, в том числе static и private. Цель применения данного класса - это короткая запись, короткий класс для выполнения конкретной разовой задачи. При этом нам не потребуется создавать новые классы в программе для выполнения одной задачи, тем самым загромождая программу классами разового применения, раздувая код. 

Анонимный класс упрощает код и убирает необходимость создавать новые классы для выполнения разовых задач. Анонимные классы следует использовать, когда уже есть тип, который описывает этот класс (либо его родителей), и задача будет выполняться один раз за всю работу программы (то есть нужен всего один экземпляр этого класса). Соответственно, и использоваться этот экземпляр будет в месте его создания, либо сразу после этого. Если подобную задачу нужно выполнять несколько раз, нужно создать локальный класс. Желательно применять анонимные классы к компактным задачам, чтобы не ухудшать чтение кода.

Внутри анонимного класса можно не только переопределять методы родителя, но и писать свои методы. У этих методов есть ограничение: с ними можно работать только внутри анонимного класса.

Анонимные классы могут не только наследовать другие классы, но и реализовывать интерфейсы (интерфейсы мы будем проходить в разделе Полиморфизм). Реализация интерфейсов анонимными классами на практике применяется чаще и полезнее, чем наследование, как в нашем примере.

https://job4j.ru/profile/exercise/20/task-view/1032

**Анонимный класс (имени нет)**

Локальный класс без имени. Наследует какой-то класс, или имплиментирует какой-то интерфейс.

**Из него видны:**
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

**Его видно:**
— только в том методе где он определён.

**Не может быть наследован**

**Может содержать:**
— только обычные свойства и методы (не статические).

[к оглавлению](#OOP)

## 43. Сколько объектов анонимного класса можно создать в программе?

объект анонимного класса может быть только один

[к оглавлению](#OOP)

## 44. Что такое исключения? Какие типы исключительных ситуаций бывают?

**Что такое исключения?**

Исключение — это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:
* Пользователь ввел некорректные данные.
* Файл, к которому обращается программа, не найден.
* Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

**Какие типы исключительных ситуаций бывают?*

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_3.png)
 
подробная иерархия исключений по ссылке
http://i.piccy.info/i9/2579c05514d2f6424a63e4d246ffb0ad/1398970263/143501/740281/exceptions.png

**`Throwable`** - суперкласс исключений. в нем вся логика. Остальные подклассы нужны для того, чтобы определить 
тип исключений:
 
+ **`Error` (unchecked)** - неустранимые (как правило) на уровне JVM проблемы. Согласно спецификации Java, 
не следует пытаться обрабатывать их в собственной программе.
https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html 

   *`OutOfMemoryError`* - ошибка переполнения памяти JVM. Программа дополнительную память всё равно не сможет обеспечить для JVM.
   ThreadDeath - вызывается при неожиданной остановке потока посредством метода `Thread.stop()`.
   
   *`StackOverflowError`* - ошибка переполнение стека. Часто возникает в рекурсивных функциях из-за неправильного условия выхода.

+ **`Exception` (checked)** - являются результатом проблем в программе, которые в принципе решаемые и предсказуемые.
Они обязательны для обработки и обычно связаны с бизнес-логикой приложения.

    + ***`IOException` (checked)*** ошибки созданные неудачными или прерванными операциями ввода-вывода.
    https://docs.oracle.com/javase/8/docs/api/java/io/IOException.html
    
    + ***`SQLException` (checked)*** ошибки доступа к базе данных или другие ошибки, связанных с работой с базами данных.
    https://docs.oracle.com/javase/8/docs/api/java/sql/SQLException.html
    
+ **`RuntimeException` (unchecked)** - результат некорректного программирования, компилятор не требует их обработки. 
    https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html
    
        *`IndexOutOfBoundsException`* - выбрасывается, когда индекс некоторого элемента в структуре данных (массив/коллекция) 
        не попадает в диапазон имеющихся индексов.
        
        *`NullPointerException`* - ссылка на объект, к которому вы обращаетесь хранит `null`.
        
        *`ClassCastException`* – Ошибка приведения типов. Всякий раз при приведении типов делается проверка на 
        возможность приведения (проверка осуществляется с помощью `instanceof`).
        
        *`ArithmeticException`* - бросается когда выполняются недопустимые арифметические операции, например деление на ноль.  

**Проверяемые исключения (checked)** - это те исключения, которые проверяются при компиляции. 
Если вы не обработаете их, вы получите ошибку компиляции.

**Непроверяемые исключения (unchecked)** - это те исключения, которые не проверяются во время компиляции. 
JVM не будет «ругаться», если вы не обработаете такие исключения.

http://javastudy.ru/interview/exceptions/

http://java-online.ru/java-throws.xhtml

http://www.quizful.net/post/java-exceptions#targetText=%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F%20%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9,%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20java.lang.Throwable.&targetText=%D0%9F%D1%80%D1%8F%D0%BC%D1%8B%D0%BC%D0%B8%20%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20Throwable%20%D1%8F%D0%B2%D0%BB%D1%8F%D1%8E%D1%82%D1%81%D1%8F,%D0%B2%D0%BE%D0%B7%D0%BD%D0%B8%D0%BA%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D0%B2%D0%BE%20%D0%B2%D1%80%D0%B5%D0%BC%D1%8F%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F.

**Как обрабатываются исключительные ситуации?**

В Java есть пять ключевых слов для работы с исключениями:

+ `try` — используется для отметки начала блока кода, который потенциально может привести к ошибке.

+ `catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
Последовательность блоков catch должна идти от частного к более общему. В противном случае будет ошибка компиляции.

+ `finally` — ключевое слово для отметки начала блока кода, которой является дополнительным. 
Этот блок помещается после последнего блока `catch`. Управление обычно передаётся в блок `finally` в любом случае.

+ `throw` — служит для генерации исключений.

+ `throws` — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее,
 что метод потенциально может выбросить исключение с указанным типом.

Общий вид конструкции для «поимки» исключительной ситуации выглядит следующим образом:

Для обработки исключений используется конструкция `try-catch-finally` и c 7й Java `try-with-resources`. 

**`try-catch-finally`**:
```java
try { 
    //здесь код, который потенциально может привести к ошибке 
} 
catch(SomeException e) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //здесь описываются действия, направленные на обработку исключений 
} 
finally { 
    //выполняется в любом случае (блок finally  не обязателен) 
}
```
Пример 1.
```java
try{ 
    fis = new FileInputStream(fileName); 
} catch (Exception ex) {    
    //... 
} catch (IOException e) { 
    //... 
} 
```
Пример 2. Начиная с Java 7 можно переотлавливать несколько исключений одни блоком catch.
```java
try {  
    //... 
} catch( IOException | SQLException ex ) {  
    logger.log(ex); 
    throw ex; 
} 
```

**`try-with-resources`**:
```java
try(открываем файл и т.п. здесь) {
    //здесь код, который потенциально может привести к ошибке 
}
//после блока файл закроется автоматически.
```

Пример 1.
```java
BufferedReader br = new BufferedReader(new FileReader(path));
   try {
        return br.readLine();
   } finally {
        if (br != null) {
            br.close();
        }
   }
```
Пример 2. Java 7
```java
try (BufferedReader br = new BufferedReader(new FileReader(path)) ) {
    return br.readLine();
}
```
[к оглавлению](#OOP)

## 45. Назовите основные методы класса Object?

+ `public native int hashCode()` — возвращает хеш-код объекта.

+ `public boolean equals(Object obj)` — сравнивает объекты.

+ `public String toString()` — возвращает строковое представление объекта.

+ `public final native Class getClass()` — возвращает в рантайме класс данного объекта.

+ `protected native Object clone() throws CloneNotSupportedException` — клонирование объекта

+ `public final native void notify()` — просыпается один поток, который ждет на "мониторе" данного объекта.

+ `public final native void notifyAll()` — просыпаются все потоки, которые ждут на "мониторе" данного объекта.

+ `public final native void wait(long timeout) throws InterruptedException` — поток переходит в режим ожидания в 
течение указанного времени.

+ `public final void wait() throws InterruptedException` — приводит данный поток в ожидание, пока другой поток 
не вызовет `notify()` или `notifyAll()` методы для этого объекта.

+ `public final void wait(long timeout, int nanos) throws InterruptedException` — приводит данный поток в ожидание, 
пока другой поток не вызовет `notify()` или `notifyAll()` для этого метода, или пока не истечет указанный промежуток времени.

+ `protected void finalize() throws Throwable` — вызывается сборщиком мусора, когда garbage collector определил, 
что ссылок на объект больше нет.

Модификатор `native` сигнализирует о том, что метод реализован в платформо-зависимом коде, часто на языке С.

http://javastudy.ru/interview/java-oop3/

[к оглавлению](#OOP)

## 46. Что такое шаблоны проектирования?

Шаблон проектирование означает схему решения часто возникающей задачи проектирования. Чтобы не тратить время на решение задачи по проектированию мы используем готовые решения. Все шаблоны разбиты на группы. Группы определяют общую задачу, которую решает этот шаблон.

Есть три основных типа шаблонов проектирования:

* `Структурные шаблоны`, в общем случае, имеют дело с отношениями между объектами, облегчая их совместную работу.
    - ***Adapter (Адаптер)*** - это конвертер между двумя несовместимыми объектами. Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
    - ***Composite (Компоновщик)*** - использует один класс для представления древовидной структуры.
    - ***Proxy (Заместитель)*** - представляет функциональность другого класса.
    - ***Flyweight (Легковес)*** - вместо создания большого количества похожих объектов, объекты используются повторно.
    - ***Facade (Фасад)*** - беспечивает простой интерфейс для клиента, и клиент использует интерфейс для взаимодействия с системой.
    - ***Bridge (Мост)*** - делает конкретные классы независимыми от классов реализации интерфейса.
    - ***Decorator (Декоратор)*** - добавляет новые функциональные возможности существующего объекта без привязки его структуры.
* `Порождающие шаблоны` обеспечивают механизмы инстанцирования, облегчая создание объектов способом, который наиболее соответствует ситуации.
    - ***Singleton (Одиночка)*** - ограничивает создание одного экземпляра класса, обеспечивает доступ к его единственному объекту.
    - ***Factory (Фабрика)*** - используется, когда у нас есть суперкласс с несколькими подклассами и на основе ввода, нам нужно вернуть один из подкласса.
    - ***Abstract Factory (Абстрактная фабрика)*** - используем супер фабрику для создания фабрики, затем используем созданную фабрику для создания объектов.
    - ***Builder (Строитель)*** - используется для создания сложного объекта с использованием простых объектов. Постепенно он создает больший объект от малого и простого объекта.
    - ***Prototype (Прототип)*** - помогает создать дублированный объект с лучшей производительностью, вместо нового создается возвращаемый клон существующего объекта.
* `Поведенческие шаблоны` используются в коммуникации между объектами, делая её более лёгкой и гибкой.
    - ***Template Method (Шаблонный метод)*** - определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
    - ***Mediator (Посредник)*** - предоставляет класс посредника, который обрабатывает все коммуникации между различными классами.
    - ***Chain of Responsibility (Цепочка обязанностей)*** - позволяет избежать жесткой зависимости отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами.
    - ***Observer (Наблюдатель)*** - позволяет одним обьектам следить и реагировать на события, происходящие в других объектах.
    - ***Strategy (Стратегия)*** - алгоритм стратегии может быть изменен во время выполнения программы.
    - ***Command (Команда)*** - интерфейс команды объявляет метод для выполнения определенного действия.
    - ***State (Состояние)*** - объект может изменять свое поведение в зависимости от его состояния.
    - ***Visitor (Посетитель)*** - используется для упрощения операций над группировками связанных объектов.
    - ***Interpreter (Интерпретатор)*** - определяет грамматику простого языка для проблемной области.
    - ***Iterator (Итератор)*** - последовательно осуществляет доступ к элементам объекта коллекции, не зная его основного представления.
    - ***Memento (Хранитель)*** - используется для хранения состояния объекта, позже это состояние можно восстановить.

[к оглавлению](#OOP)

## 47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.

Паттерн декоратор (Decorator) – позволяет динамически добавлять новую функциональность к объектам, не изменяя их исходный код. Это очень удобно, когда нужно добавить дополнительные возможности к уже существующему объекту.

Шаги:

1. Создание интерфейса (компонента) и объявление метода
2. Создние класса реализующего данный интерфес
3. Создание класса декоратора(абстрактный класс) также реализующий интерфейс с ссылкой/указателем интерефейса и инициализация через конструктор
4. Конкретные классы - декораторы с реализациующие новую/дополнительную функциональность

![img](https://upload.wikimedia.org/wikipedia/ru/0/00/Decorator_template.png)

[к оглавлению](#OOP)

## 48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.

*Паттерн стратегия (Strategy)* - поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

*Стратегия* - это шаблон в программировании, при котором происходит объединение нескольких возможных алгоритмов поведения объекта в единый класс. Каждый алгоритм взаимозаменяем и выбирается прямо во время выполнения программы.Пользователи программы, которая использует паттерн «Стратегия», могут выбрать в ней различные варианты для достижения одной и той же цели.

Шаги:

1. Создаем интрефейс 

2. Далле конкретные классы (стратегии) релизуют интерфейс

3. Создается класс содержащий ссылку на интерфейс и метод в который передается конкретная реализация

Пример: сортировка различными способами

![img](https://upload.wikimedia.org/wikipedia/ru/4/4c/Strategy_pattern.PNG)

Пример:\
редактор текста\
html теги\
добавление оповещений (емэйл, смс, )

[к оглавлению](#OOP)

## 49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.

Шаблон проектирования singleton - это порождающий шаблон проектирования, который гарантирует, что в приложении может быть только один экземпляр некоторого класса, а также предоставляет глобальную точку доступа к этому экземпляру через отдельный метод.

Шаблон singleton применяют в проектах, где используются внешние ресурсы: файловая система, база данных,логирование, связь с другими приложениями.В таких проектах доступ к ресурсу нужно ограничить использованием одного объекта на виртуальную машину.Это позволяет экономить ресурсы системы.

Синглтон — это шаблон (паттерн) проектирования, который делает две вещи:
- Дает гарантию, что у класса будет всего один экземпляр класса.
- Предоставляет глобальную точку доступа к экземпляру данного класса.

**Реализация.**
1. Создать явно конструктор и указать у него модификатор private. Таким образом, никто не сможет создать объект этого класса.
2. Так же нужно запретить наследование этого класса. Для этого используем ключевое слово final.
3. Публичный статический метод, который возвращает экземпляр класса. Данный метод называют getInstance. Это глобальная точка доступа к экземпляру класса.

**Вариант: Simple Solution**

```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```
Плюсы:
Простота и прозрачность кода

Потокобезопасность

Высокая производительность в многопоточной среде

Минусы:
Не ленивая инициализация.

**Вариант: Lazy Initialization**

```java
public class Singleton {
  private static Singleton INSTANCE;

  private Singleton() {}

  public static Singleton getInstance() {
    if (INSTANCE == null) {
      INSTANCE = new Singleton();
    }
    return INSTANCE;
  }
}
```
Плюсы:
Ленивая инициализация.

Минусы:
Не потокобезопасно

**Вариант:Synchronized Accessor**

```java
public class Singleton {
  private static Singleton INSTANCE;

  private Singleton() {
  }

  public static synchronized Singleton getInstance() {
    if (INSTANCE == null) {
      INSTANCE = new Singleton();
    }
    return INSTANCE;
  }
}
```

Плюсы:
Ленивая инициализация.

Потокобезопасность

Минусы:
Низкая производительность в многопоточной среде

[к оглавлению](#OOP)

## 50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.

Фабричный метод – это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. В реальности объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод.

Преимущества:
* **Избавление клиентского кода от привязки к конкретным классам продуктов.** Действительно, класс Canvas оперирует абстрактными понятиями ShapeOperator и Shape. То, что в конечном счёте будет построено определяется выбором пользователя в блоке if-else, но можно это сделать и через конфигурационный файл или переменную среды.
* **Выделяет код производства продуктов в одно место, упрощая поддержку кода.** В нашем случае это осуществлено через реализацию фабричного метода createShape() в подклассах TriangleOperator и RectangleOperator.
* **Упрощает добавление новых продуктов в программу.** Допустим что мы захотим добавить поддержку фигуры Круг. Для этого достаточно создать продукт Round, реализующий интерфейс Shape и реализовать для него фабричный метод, например, в классе RoundOperator. Далее можно спокойно передавать в действующий пользовательский код экземпляр этого класса-фабрики, так как он производит продукт типа Shape, который имеет методы draw() и square(), а также реализует общую бизнес-логику: выводит общую информацию о заданной построенной фигуре с помощью метода showInfo().
* **Реализует принцип открытости/закрытости.** В нашем случае, мы можем сколько угодно модифицировать код создания существующих фигур и их методов, а также добавлять сколь угодно много новых фигур, реализующих интерфейс Shape. При этом это никак не отразится на пользовательском коде, оперирующем этими классами. Для него важно, что имеется фигура Shape, которую можно нарисовать и для которой можно найти площадь.
* Преимуществом фабричного метода по сравнению с использованием обычного конструктора является **возможность ограничения создания новых объектов и их повторного использования.** Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, файловой системе и т. д. В фабричном методе можно ограничить создание более чем одного экземпляра или дать возможность создавать новый экземпляр только при условии отсутствия уже созданных и неиспользуемых.

Структура:

*Product (продукт)* - определяет интерфейс объектов, создаваемых абстрактным методом;\
*ConcreteProduct (конкретный продукт)* - реализует интерфейс Product;\
*Creator (создатель)* - объявляет фабричный метод, который возвращает объект типа Product. Может также содержать реализацию этого метода «по умолчанию»;
может вызывать фабричный метод для создания объекта типа Product;\
*ConcreteCreator (конкретный создатель)* - переопределяет фабричный метод таким образом, чтобы он создавал и возвращал объект класса ConcreteProduct.

![](https://upload.wikimedia.org/wikipedia/ru/f/f0/FactoryMethodPattern.png)

[к оглавлению](#OOP)

## 51. Что такое enum? Когда можно его применять?

Enum - это класс-перечисление. Перечисление - это набор констант, связанных между собой по смыслу. Константы здесь - это статические объекты, создающиеся в единственном экземпляре.

Обычно перечисление используют для работы со значениями, которые никогда не меняются. Например, дни недели, времена года, карточные масти или даже записи полей шахматной доски. Перечисление можно использовать и для групп констант другого вида. Например, для перечисления в программе статусов работы в автосервисе ("Принят на сервис", "В работе", "Ожидание запчастей", "Готов" и т.д.). Такие статусы никогда не меняются и имеют логическую связь между собой. 

Перечисление может объявляться отдельно, а может быть объявлено в другом классе в виде внутреннего класса. Если enum вложен в другой класс, он может быть как public, так и private. Если же enum не является внутренним классом, то он может иметь только модификатор public.

Перечисление (enum) наследуется от java.lang.Enum, поэтому он не может наследовать другие классы. Перечисление может реализовывать интерфейсы

Перечисление может содержать поля, методы и конструкторы. 

Конструктор в перечислении неявно имеет модификатор private. Других модификаторов конструктор перечисления иметь не может, соответственно, создать объект перечисления мы можем только внутри него самого. Каждый из экземпляров перечисления создаётся только при первом обращении к нему. Каждое значение (константа) нашего перечисления - это объект анонимного класса.

```java
public static final Status ACCEPTED = new Status("Принят") { };
```
Отсюда следует, что перечисление - это список неизменяемых готовых объектов, которыми можно пользоваться.

```java
package ru.job4j.enumeration;

public enum Status {
    ACCEPTED("Принят") {
        private String message = "Автомобиль принят на СТО";

        @Override
        public String getMessage() {
            return message;
        }

    },
    IN_WORK("В работе") {
        private String message = "Автомобиль в работе";

        @Override
        public String getMessage() {
            return message;
        }
    },
    WAITING("Ожидание") {
        private String message = "Автомобиль ожидает запчасти";

        @Override
        public String getMessage() {
            return message;
        }
    },
    FINISHED("Работы завершены") {
        private String message = "Все работы завершены";

        @Override
        public String getMessage() {
            return message;
        }
    };

    private String info;

    Status(String info) {
        this.info = info;
    }

    public String getInfo() {
        return info;
    }

    public abstract String getMessage();

}
```
**Методы enum.**

Далее представлены некоторые полезные методы класса Enum.

- name() - возвращает имя константы (значения) в том же виде, в каком оно объявлено.
- ordinal() - возвращает порядковый номер константы (значения), по которому её экземпляр находится в перечислении (нумерация с нуля).
- values() - возвращает массив всех элементов перечисления.
- valueOf() - получает объект типа класса перечисления по его строковому представлению.

Также, так как значения enum не меняются, то при работе с ними можно использовать оператор **switch**. 

[к оглавлению](#OOP)

## 52. Что такое record? Когда можно его применять?

Record дает возможность записать стандартную модель данных в виде одной строки, то есть с помощью record можно избавиться от шаблонного кода, который приходится писать в каждой модели данных.

Record - это неизменяемая модель данных, в которой:

- Поля, переданные в параметрах, являются private и final по умолчанию.
- Код имеет канонический конструктор, параметры которого - это все поля данного класса.
- Доступ к полям осуществляется через методы типа имя_поля(). Тот же геттер, только без слова get в имени метода. Методов типа set класс record не имеет, так как все поля объявлены как final, поэтому record является неизменяемым.
- Определены методы equals() и hashcode(), включающие все поля класса.
- Определен шаблонный метод toString() для вывода полей класса на печать.

> Если всё же нужно изменить поле, то потребуется создать новый объект record, скопировать в него значения полей, которые не менялись, и указать новое значение в поле, которое нужно изменить.

Record удобно применять, когда у модели могут добавляться или удаляться поля. Достаточно просто вписать новое поле в запись record и в класс автоматически будут внесены изменения. В случае же с обычным классом нужно будет вручную вписывать поле в модель, менять конструктор, методы equals(), hashcode(), toString(), добавлять или удалять геттеры.

**Особенности.**

Record имеет некоторые особенности, перечисленные ниже:
- В record можно добавлять только статические переменные (как константы, так и обычные статические переменные).
```java
public record PersonRecord(String name, int age) {
    public static int maxAge = 100;
```
- В record можно добавлять свои методы, как нестатические, так и статические.

```java
package ru.job4j.record;

public record PersonRecord(String name, int age) {
    public static int maxAge = 100;

    public static int getMaxAge() {
        return maxAge;
    }
    
    public void info() {
        System.out.println("Напечатать информацию");
    }
}
```

- Record является final, поэтому наследование этого класса невозможно. Сам record наследовать другие классы не может, так он унаследован от java.lang.Record. Но record может реализовывать интерфейсы (интерфейсы мы будем проходить в разделе Полиморфизм, пока что просто можно запомнить, что record работает с интерфейсами).

```java
package ru.job4j.record;

public record PersonRecord(String name, int age) implements Comparable<PersonRecord> {
    @Override
    public int compareTo(PersonRecord o) {
        return name.compareTo(o.name);
    }
}
```

**Конструкторы.**

- По умолчанию record имеет канонический конструктор - это конструктор, принимающий все поля класса в качестве параметров.

```java
public PersonRecord(String name, int age) {
    this.name = name;
    this.age = age;
}
```
Такой же конструктор неявно создается в record по умолчанию. Если его явно объявить в record, то будет использоваться объявленный конструктор вместо канонического. Конструктор по умолчанию при объявлении явного канонического конструктора создан не будет.

- Если нам нужен конструктор с какой-то логикой помимо обычной инициализации полей, можно создать компактный конструктор:

```java
package ru.job4j.record;

public record PersonRecord(String name, int age) {
    public PersonRecord {
        if (age > 101) {
            throw new IllegalArgumentException("Возраст должен быть менее 101");
        }
    }
}
```

Данный конструктор называется компактным, так как в нем поля не инициализируются явным образом. Инициализация проходит неявно перед выполнением команд, находящихся внутри конструктора. Данная инициализация автоматически будет проходить в любом переопределенном конструкторе. Это гарантирует, что все поля будут инициализированы.

Если в record уже объявлен компактный конструктор, то явно объявить еще и канонический конструктор в этом классе невозможно, так как при объявлении компактного конструктора автоматически создается конструктор по умолчанию, чтобы провести инициализацию всех полей перед выполнением команд компактного конструктора, следовательно нельзя еще раз объявить в классе такой же конструктор с теми же параметрами. 

https://job4j.ru/profile/exercise/22/task-view/960

[к оглавлению](#OOP)

## 53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?

Ранее мы познакомились с классом String и объединением строк (конкатенацией) с помощью оператора "+". Но конкатенация в цикле при помощи оператора "+" является плохим решением с точки зрения производительности программы.

**String** - это неизменяемый класс. После создания объект этого класса изменить нельзя. Строка - это неизменяемая последовательность символов. При любых операциях изменения строки типа String будет создан новый объект String с результирующим содержимым.
Пример:

```java
package ru.job4j.concat;

public class ConcatTest {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis(); 
        String str = "Job4j"; 
        for (int index = 0; index < 9999; index++) { 
            str = str + index; 
        }
        System.out.println("Миллисекунд: " + (System.currentTimeMillis() - startTime));
    }
}
```

Последовательность операций в цикле будет такая:

При компиляции кода оператор "+" неявно заменяется на объект StringBuilder, к которому присоединяются эти строки. В первом проходе цикла стартовая строка "Job4j" совмещается со строковым представлением индекса "0" - то есть эти 2 строки будут "склеены" в только что созданном объекте StringBuilder. После слияния StringBuilder будет содержать склеенную строку "Job4j0". Обратите внимание, что при присоединении к строке примитивных типов данных, они будут также преобразованы в строку. В следующем проходе цикла к нашей новой строке "Job4j0" присоединяется следующее число 1 (для этого соединения создается новый StringBuilder), получаем "Job4j01". Далее по тому же сценарию создаются новые строки "Job4j012", "Job4j0123", "Job4j01234" и т.д. до конца цикла. Каждая строка создается отдельно и хранится в памяти в StringPool - специальном разделе памяти для хранения строк. StringPool мы будем проходить в разделе Junior. На моем компьютере данный код выполняется примерно за 60-65 миллисекунд.

**StringBuilder** - это класс, являющийся изменяемой последовательностью символов. Он дает возможность создать объект класса StringBuilder, и добавлять в него другие строки без создания новых объектов.

Еще один способ объединять строки - **String.concat()**. Удобно пользоваться, если у нас уже есть готовые строки, которые мы просто хотим объединить и получит результат. Метод concat() класса String возвращает объект String. Метод concat() можно объединять в цепочку, в результате работы которой будет возвращена новая строка без накладных расходов в виде создания промежуточных строк.

Когда нам нужно объединить 2 и более строки с каким-либо разделителем, например, пробелом, то можно использовать метод **join()** класса String.

В Java есть удобный класс для составления строк - **StringJoiner.** StringJoiner базируется на StringBuilder и имеет удобную возможность соединять строки через разделитель, а также добавлять префикс и/или суффикс к результирующей строке.

Классы StringBuilder и StringJoiner не синхронизированы. Они будут некорректно работать в многопоточной среде. **StringBuffer** - это аналог StringBuilder, только с синхронизированными методами для работы в многопоточном окружении.

https://job4j.ru/profile/exercise/22/task-view/995

https://habr.com/ru/articles/260767/

[к оглавлению](#OOP)

## 54. Чем отличаются StringBuffer и StringBuilder?

**StringBuffer** - это аналог StringBuilder, только с синхронизированными методами для работы в многопоточном окружении.

Как и класс StringBuilder, класс StringBuffer также создает изменяемый строковый объект. И StringBuffer содержит те же методы, что и StringBuilder. Таким образом, разница между ними в том, что класс StringBuffer — потокобезопасный и синхронизированный: экземпляры класса StringBuffer могут совместно использоваться несколькими потоками. Для операций со строками в многопоточных средах стоит использовать StringBuffer.

[к оглавлению](#OOP)

## 55. Каким образом производится экранирование символов и зачем это нужно?

В Java проблему невозможности вывести символ в тексте непосредственно(как есть) решает экранирование символов. Выглядят экранированные символы как наш исходный символ, перед которым стоит обратный слэш "\". Давайте экранируем наши проблемные двойные кавычки в коде.

https://job4j.ru/profile/exercise/22/task-view/996

[к оглавлению](#OOP)

## 56. Что такое управляющие последовательности?

Комбинация в виде обратного слэша и экранируемого им символа называется **управляющей последовательностью** (escape-последовательность). В таком же виде выводятся и спецсимволы, например, \n - переход на новую строку. 

В Java существует 8 видов управляющих последовательностей:

1. **\' - Добавляет одинарную кавычку**
Аналогично выводу двойной кавычки, выводит одиночную кавычку. Имеет смысл при выводе символа одинарной кавычки в одинарных кавычках (аналогично двойной кавычке среди двойных).Внутри текста в двойных кавычках (строкового литерала), экранировать одиночную кавычку не требуется, так же как и двойную кавычку среди одинарных.

2. **\" - Добавляет двойную кавычку**

3. **\\ - Добавляет обратный слэш**
Применяется, например, при передаче пути к файлу или папке в файловой системе.

4. **\r - Возврат курсора в начало строки**
Возвращает курсор в начало строки, "обнуляя" её. Если в строке были данные, они пропадут. В блоке кода ниже первая строка выводится на печать без перевода на новую строку. После возврата курсора данные из второй строки выводятся на печать с начала строки, при этом данных из первой строки в ней уже нет.

5. **\n - Перевод курсора на новую строку**
\n переводит часть строки после себя на новую строку. Можно использовать как в конце строки, так и в любом ее месте

6. **\f - Прогон страницы**
Переводит документ на новую страницу. Неиспользуемый спецсимвол.

7. **\t - Табуляция**
Символ табуляции - это аналог четырех пробелов. Используется для начального отступа в строке и прочих других всевозможных равномерных отступов. Как уже упоминалось выше, символ табуляции - это один символ, несмотря на то, что он заменяет 4 пробела.

8. **\b - Возврат курсора на одну позицию назад**
Работает как BackSpace - стирает один символ позади текущего положения курсора.

https://job4j.ru/profile/exercise/22/task-view/996

[к оглавлению](#OOP)

## 28. Для чего используется конструктор в абстрактном классе?

Для инициализации начальных значений общих переменных, объявленных в абстрактном классе и используемых различными реализациями.

[к оглавлению](#OOP)

## 29. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?

При создании анонимного класса в скобках можно передать аргументы для недефолтового конструктора.

[к оглавлению](#OOP)

## 30. Что такое композиция?

**Ассоциация** - это отношение, при котором объекты одного типа определенным образом связаны с объектами другого типа. 
Так объект одного типа может содержать или использовать объект другого типа. 

Например, когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». 
Автомобиль имеет двигатель.

Выделяют два частных случая ассоциации: композицию и агрегацию.

**Агрегация** - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку 
на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Например, когда экземпляр двигателя создается где-то в другом месте кода, 
и передается в конструктор автомобиля в качестве параметра.
```java
class Engine {
    int power;
    
    public Engine(int p) {
       power = p;
    }
}        

class Car {  
    string model = "Audi";
    Engine engine;
    
    public Car(Engine someEngine) {
         this.engine = someEngine;
    }
}

Engine goodEngine = new Engine(360);
Car audi = new Car(goodEngine);
```

**Композиция** - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть 
контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.

Например, когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью 
управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.
```java
class Engine {
    
    int power;
    
    public Engine(int p) {
        power = p;
    }
}

class Car {
    
    string model = "Audi"; 
    Engine engine;
    
    public Car() {
        this.engine = new Engine(360);
    }
}
```

[к оглавлению](#OOP)

## 31. Что такое агрегация?

подробнее:

https://habr.com/ru/post/354046/

https://ru.wikipedia.org/wiki/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

http://sergeyteplyakov.blogspot.com/2012/12/vs-vs.html

https://ru.stackoverflow.com/questions/596697/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F

http://java-online.ru/java-interview-01.xhtml

[к оглавлению](#OOP)


## 35. ?

## 48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.


[к оглавлению](#OOP)

## FP Lambda Stream API

[1. Что такое lamdba выражение?](#1-Что-такое-lamdba-выражение)

[2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)

[3. Перечислите функциональные интерфейсы из пакета java.util.function?](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)

[4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)

[5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)

[6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)

[7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)

[8. Расскажите о зоне видимости переменных в lambda - выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)

[9. Как быть в ситуации, если внутри lambda - выражении операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражении-операторы-могут-выкинуть-исключение)

[10. Что такое Stream API?](#10-Что-такое-Stream-API)

[11. Расскажите, какой шаблон проектирования используется внутри Stream API?](#11-Расскажите-какой-шаблон-проектирования-используется-внутри-Stream-API)

[12. Объясните, где они используются в Stream API](#12-Объясните-где-они-используются-в-Stream-API)

[13. Что такое конвейерные и терминальные операции?](#13-Что-такое-конвейерные-и-терминальные-операции)

[14. Перечислите конвейерные (промежуточные) методы Stream API](#14-Перечислите-конвейерные-методы-Stream-API)

[15. Перечислите терминальные методы Stream API](#15-Перечислите-терминальные-методы-Stream-API)

[16. Что такое отложенный выполнение lamdba?](#16-Что-такое-отложенный-выполнение-lamdba)

[17. Что делает метод filter?](#17-Что-делает-метод-filter)

[18. Что делает метод map.](#18-Что-делает-метод-map)

[19. Что делает метод flatMap?](#19-Что-делает-метод-flatMap)

[20. Что делает метод collect?](#20-Что-делает-метод-collect)

[21. Что делает метод findFirst?](#21-Что-делает-метод-findFirst)

[22. Что делает метод reduce?](#22-Что-делает-метод-reduce)

[23. Что делают методы min и max?](#23-Что-делают-методы-min-и-max)

[24. Что делают методы count, sum, average?](#24-Что-делают-методы-count-sum-average)

[25. Что делают методы forEach и peek?](#25-Что-делают-методы-forEach-и-peek)

[26. Что делают методы skip и limit?](#26-Что-делают-методы-skip-и-limit)

[27. Что делают методы allMatch(), noneMatch() и anyMatch()?](#27-Что-делают-методы-allMatch-noneMatch-и-anyMatch)

[28. Что делают методы mapToInt, flatMapToInt, mapToObj?](#28-Что-делают-методы-mapToInt-flatMapToInt-mapToObj)

[29. Что такое числовой поток?](#29-Что-такое-числовой-поток)

[30. Чем отличается Stream< Integer> от IntStream< int>?](#30-Чем-отличается-Stream<Integer>-от-IntStream<int>)

[31. Что делает метод boxed?](#31-Что-делает-метод-boxed)

[32. Возможно ли прервать выполнение потока по аналогии с break?](#32-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)

[33. Возможно ли пропустить элемент потока по аналогии с continue?](#33-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)

[34. Что такое Optional?](#34-Что-такое-Optional)

[35. Перечислите методы Optional?](#35-Перечислите-методы-Optional)

[36. Расскажите про фабричные методы List.of, Set.of, Map.of?](#36-Расскажите-про-фабричные-методы-Listof-Setof-Mapof)

[37. Для чего используется ключевое слово var?](#37-Для-чего-используется-ключевое-слово-var)

[38. В каких случаях можно использовать var?](#38-В-каких-случаях-можно-использовать-var)

[25. ](#25-)

## 1. Что такое lamdba выражение?

Лямбда-выражение представляет собой блок кода, который можно передать в другое место, поэтому он может быть выполнен 
позже один или несколько раз. По сути это функция, которая существует, но в данный момент времени не может быть вычислена.

В программировании термин лямбда обозначает возможность передать в качестве параметра блок кода. Переданный блок кода может быть вызван в любой момент времени или не вызван вообще.

По существу является анонимным (безымянным) методом, который реализует метод, определенный в функциональном интерфейсе.
```java
(входящие параметры через запятую без указания типа) -> {
    операторы;
    return вычисленное значение;
}
```
Если функция не принимает параметры, то указываем пустые скобки. Если не возвращает, то не указываем `return`.

*основное предназначение - преобразования lambda выражений в функциональный интерфейс

https://www.ibm.com/developerworks/ru/library/j-java8lambdas/index.html

[к оглавлению](#FP-Lambda-Stream-API)

## 2. Что такое функциональные интерфейсы?

Функциональным называется интерфейс, который содержит только 1 абстрактный метод. 
Такой интерфейс описыват классическую математическую функцию.

Основное назначение – использование в лямбда выражениях, method reference или ссылок на конструкторы.
Функциональный интерфейс может содержать так же `default` и `static` методы.
К функциональному интерфейсу можно добавить аннотацию `@FunctionalInterface`

В функциональном интерфейсе может быть также дополнительно объявлено один или несколько абстрактных методов, которые по сигнатуре совпадают с методом из класса java.lang.Object, в таком случае они не влияют на ограничение в один абстрактный метод для функционального интерфейса. Такое вы можете увидеть в интерфейсе Comparator, если обратитесь к исходникам.

[к оглавлению](#FP-Lambda-Stream-API)

## 3. Перечислите функциональные интерфейсы из пакета javautilfunction?

В JDK в пакете java.util.function встроены готовые функциональные интерфейсы, описывающие всевозможные варианты.
Это `Consumer<T>`, `Function<T,R>`, `Predicate<T>`, `Supplier<T>`, `UnaryOperator<T>`, `BinaryOperator<T>` и их `Bi` – формы

+ **Predicate< T>** - проверяет соблюдение некоторого условия.
Если оно соблюдается, то возвращается значение `true`. В качестве параметра лямбда-выражение принимает объект типа `T`

```java
@FunctionalInterface
public interface Predicate<T> {

    boolean test(T t);
}
@FunctionalInterface
public interface BiPredicate<T, U> {

    boolean test(T t, U u);
}
```

+ **Function< T,R>** - представляет функцию перехода от объекта типа `T` к объекту типа `R`.

```java
@FunctionalInterface
public interface Function<T, R> {

    R apply(T t);
}
@FunctionalInterface
public interface BiFunction<T, U, R> {

    R apply(T t, U u);
}
```

+ **Consumer< T>** - принимает 1,2 аргумента, выполняет некоторое действие над объектом типа `T`, при этом ничего не возвращая.

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);
}
```

+ **Supplier< T>** - не принимает никаких аргументов, но должен возвращать объект типа `T`.

```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

UnaryOperator и BinaryOperator – это разновидность Function, в которых входные и выходные обобщенные параметры должны совпадать.

+ **BinaryOperator< T>** - принимает в качестве параметра два объекта типа `T`, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа `T`.

+ **UnaryOperator< T>** - принимает в качестве параметра объект типа `T`,
выполняет над ними операции и возвращает результат операций в виде объекта типа `T`.

подробнее https://metanit.com/java/tutorial/9.3.php

[к оглавлению](#FP-Lambda-Stream-API)

## 4. Что такое функции высшего порядка?

Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают 
другие функции в качестве своих результатов.

У языка Java — возможно, последнего среди популярных языков — наконец-то появились функции высшего порядка 
в форме так называемых лямбда-выражений.

Основная идея: функции имеют тот же статус, что и другие объекты данных.
```java
Function<Integer,Integer>   f = x -> x + 3;
BiFunction<Function<Integer,Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
System.out.println(g.apply(f,7));
```

**Ответ 2**

Функции высшего порядка - это функции, зависящие от других функций. В программировании функции высшего порядка описываются через композицию.

[к оглавлению](#FP-Lambda-Stream-API)

## 5. Какие функциональные интерфейсы из пакета javautilfunction поддерживают функции высшего порядка?

Predicate метод Predicate and(Predicate other) - and(Predicate< ? super T> other)

Consumer Метод Consumer andThen(Consumer after) - default Consumer< T> andThen(Consumer< ? super T> after)

Function Метод Function compose(Function before) default < V> Function< V,R> compose(Function< ? super V,? extends T> before)

Supplier метод Supplier and(Supplier other) ???

Также метод в Java может возвращать лямбда-выражение.

[к оглавлению](#FP-Lambda-Stream-API)

## 6. Что такое ссылки на методы?

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод.
В принципе данный способ аналогичен передаче в метод лямбда-выражения.

Ссылка на метод - это компактное лямбда-выражение, которое позволяет передавать ссылки на методы или конструкторы.

Если вся лямбда - это вызов другого метода, то такой код можно упростить с помощью ссылки на метод

Иногда уже есть метод, который осуществляет именно те действия, которые вы хотели бы передать в другое место.

`Выражение System.out::println является ссылкой на метод, который эквивалентен лямбда-выражению x -> System.out.println(x)`

Ссылка на метод передается в виде:
+ `имя_класса::имя_статического_метода` ссылка на статический метод.

для нестатических методов:
+ `объект_класса::имя_метода` на метода конкретного объекта (экземпляра).
+ `тип_объекта::имя_метода` на метод произвольного объекта конкретного типа.
+ `название_класса::new` ссылка на конструктор.

Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом ссылки на метод
`method reference` для непосредственной передачи этого метода.

[к оглавлению](#FP-Lambda-Stream-API)

## 7. Что такое ссылки на конструкторы?

Можно в качестве параметров использовать конструкторы: `название_класса::new`, для дженериков `название_класса<T>::new`.

При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
что и конструкторы класса, и должны возвращать объект данного класса.

Аналогично ссылкам на методы, с которыми мы познакомились в предыдущем уроке, ссылки также можно объявлять и на конструкторы. 

Ссылки на конструкторы создаются так же, как и на методы:

```java
ИмяКласса::new
```

Такую ссылку можно присвоить любой ссылке на функциональный интерфейс, где определяется метод, совместимый с конструктором. При этом "ИмяКласса" не может быть интерфейсом или абстрактным классом.

можно сформировать ссылки на конструкторы с типом массивов. Например, int[]::new является ссылкой на конструктор с одним параметром: длиной массива. Это равносильно лямбда-выражению x -> new int[x].

Если конструкторов несколько , то нужный выбирается из контекста

[к оглавлению](#FP-Lambda-Stream-API)

## 8. Расскажите о зоне видимости переменных в lambda выражениях?

Лямбда-выражения имеют доступ к переменным в области видимости, в которой их определили.
Но доступ возможен только при условии, что переменные являются `effective final`,
то есть либо явно имеют модификатор `final`, либо не меняют своего значения после инициализации (константы).
Если переменной присваивается значение во 2й раз, то лямбда-выражение вызовет ошибку компиляции.

Можно ссылаться на:
+ `effective final` локальные переменные;
+ поля примитивных типов;
+ статические переменные.

1. Переменная, объявленная внутри лямбда-выражения, доступна только в самом лямбда-выражении.
2. Переменная, объявленная вне лямбда-выражения, доступна как внутри лямбда-выражения, так и вне его.

    >В лямбда-выражении могут использоваться переменные, объявленные за пределами самого лямбда-выражения. Например, на уровне класса или метода, где находится лямбда-выражение.  
    >Важно! Способ использования переменных в лямбда-выражениях зависит от того, где определена переменная - на уровне класса или на уровне метода, в котором находится лямбда-выражение.

    * статические переменные и переменные экземпляра (поля класса), могут быть использованы и изменены в лямбда-выражении.
    
Если в лямбда-выражении используется локальная переменная, объявленная на уровне класса вне этого выражения (то есть локальная переменная метода), то это называется захватом переменной. Захваченную переменную, в нашем случае это переменная ауууу, изменять нельзя, так как в лямбда-выражении захваченная переменная не может быть изменена после своей инициализации. Можно использовать либо переменные с модификатором final, либо effective final переменные. effective final - это обычные переменные, только которые больше не изменяются после своей инициализации.

Если надо использовать в лямбда-выражении внешние переменные, которые были изменены после их первоначальной инициализации, то используйте вместо них промежуточные переменные, специально объявленные и инициализированные нужным значением непосредственно перед лямбда-выражением

https://job4j.ru/profile/exercise/33/task-view/245

[к оглавлению](#FP-Lambda-Stream-API)

## 9. Как быть в ситуации, если внутри lambda выражении операторы могут выкинуть исключение?

Лямбда-выражение может генерировать исключение.
+ если тело лямбда-выражения может бросить проверяемое `checked` исключение, то оно должно быть объявлено в 
абстрактном методе целевого функционального интерфейса в выражении `throws`.
+ либо должно быть обработано внутри лямбда-выражения с помощью конструкции `try-catch-finally`.

Как известно из функциональных интерфейсов в `Stream API` нельзя выбрасывать контролируемые исключения.
Если по каким-то причинам это необходимо (например, работа с файлами, базами данных или по сети),
приходится оборачивать их в `RuntimeException`.

Лямбда-выражение может генерировать исключение. Если это исключение является проверяемым (Checked), то оно должно быть совместимо с исключениями, которые перечислены в выражении throws в объявлении абстрактного метода в функциональном интерфейсе, который эта лямбда реализует, иначе программа не скомпилируется. 

Проверяемые исключения можно так же обработать в блоке try-catch

подробней https://www.codeflow.site/ru/article/java-lambda-exceptions

[к оглавлению](#FP-Lambda-Stream-API)

## 10. Что такое Stream API?

Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности, 
упростить операции фильтрации, сортировки и другие манипуляции с данными.

Каждый элемент коллекции проходит 3 стадии.

1. Фильтрация;
2. Преобразование;
3. Упрощение или аккумуляция.

Каждая стадия может использоваться отдельно или совместно.

Вся основная функциональность данного API сосредоточена в пакете `java.util.stream`. 
Ключевым понятием в Stream API является поток данных. 
Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Все операции над потоками бывают 2х видов:
+ `terminal` терминальные или конечные операции возвращают конкретный результат (`void` или результат определенного типа).
+ `intermediate` промежуточные или конвейерные операции возвращают трансформированный поток.


Все потоки производят вычисления, в т.ч. в промежуточных операциях, только когда к ним применяется терминальная операция.
Т.е. в данном случае применяется отложенное выполнение.

Потоки не могут быть использованы повторно - как только была вызвана конечная операция, поток закрывается.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно
сократить запись выполняемых действий. Т.е. Stream API позволяет взаимодействовать с данными в функциональном стиле, 
пердставляя их в качестве конечного потока данных.

Javadoc https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Полное руководство по Java 8 Stream API в картинках и примерах https://annimon.com/article/2778

Шпаргалка Java программиста 4. Java Stream API https://habr.com/ru/company/luxoft/blog/270383/

[к оглавлению](#FP-Lambda-Stream-API)

## 11. Расскажите какой шаблон проектирования используется внутри Stream API?

(Builder, Strategy, Decorator, Factory Method,     Pipeline).

**Строитель (Builder)** - это порождающий шаблон проектирования, который позволяет создавать сложные объекты пошагово. Строитель позволяет использовать один и тот же код построения объекта для получения разных представлений объектов.

Если мы посмотрим на интерфейс Stream, то в нем определен вложенный интерфейс Builder. Для построения потоков при работе со Stream используется шаблон проектирования Builder (в переводе на русский - Строитель).

Когда стоит использовать шаблон проектирования Builder (Строитель):

1. Когда мы хотим избавиться от конструктора с большим количеством параметров (случай описанный в задании);
2. Когда код должен создавать разные представления какого-то объекта. Например, когда нам надо инициализировать лишь несколько полей из всего набора;
3. Когда нам необходимо собирать сложные объекты, т.е. когда поля в классе являются экземплярами других классов.

Преимущества использования шаблона Строитель:

1. Позволяет создавать объекты пошагово;
2. Позволяет использовать один и тот же код для создания различных объектов - если использовать не класс Builder, а interface с таким именем, тогда можно создавать различные имплементации этого интерфейса (в данном задании мы это не рассматривали);
3. Сложный код сборки объекта от основной бизнес логики будет изолирован.

**Фабричный метод (Factory Method)** – это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

метод range() класса IntStream основан на фабричном патерне

```java
String[] letters = {"A", "B", "C", "D"};
List<String> listLetters =
    IntStream.range(0, 10)
             .mapToObj(index -> letters[index % letters.length])
             .collect(Collectors.toList());
System.out.println("listLetters = " + listLetters);
```

**Стратегия (Strategy)** Интерфейс, определяющий контракт всех стратегий, то есть какой функционал должна предоставлять любая стратегия.

Шаблон **Декоратор (Decorator)** добавляет новую логику в существующий метод

шаблон **Pipeline**, опять же см. https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Для выполнения вычислений потоковые операции составляются в потоковый конвейер. 
Потоковый конвейер состоит из источника (который может быть массивом, коллекцией, функцией генератора, каналом ввода-вывода и т.д.), 
нуля или более промежуточных операций (которые преобразуют поток в другой поток, например `filter(Predicate)`), 
и терминальной операции (которая производит результат или побочный эффект, такой как `count()` или `forEach(Consumer)`). 
Потоки ленивы - вычисление исходных данных выполняется только тогда, когда инициируется работа терминала, а исходные 
элементы потребляются только по мере необходимости.

еще о паттерне pipeline от индуса https://medium.com/@deepakbapat/the-pipeline-design-pattern-in-java-831d9ce2fe21

[к оглавлению](#FP-Lambda-Stream-API)

## 12. Объясните, где они используются в Stream API

используются для построения потоков при работе со Stream используется шаблон проектирования Builder (в переводе на русский - Строитель).

вложенный статический класс Класса Streams реализует Stream.Builder< T>

```java
static final class StreamBuilderImpl< T>
            extends AbstractStreamBuilderImpl< T, Spliterator < T>>
            implements Stream.Builder< T> {
```

[к оглавлению](#FP-Lambda-Stream-API)

## 13. Что такое конвейерные и терминальные операции? 

В Java Stream API представлены 2 типа методов:

- Промежуточные (конвейерные). Преобразовывают элементы потока, возвращая новый преобразованный поток. Методов данного типа может быть сколько угодно в цепочке преобразований элементов потока. Данные методы ленивы, то есть отрабатывают только когда для потока вызван конечный метод. Промежуточных методов у потока может и не быть. Промежуточные операции не выполняются без конечных! Промежуточные методы ленивы - они начинают вычисляться только когда начнется терминальная операция, то есть вычисление происходит только тогда, когда оно нужно.

- Конечные (терминальные). Метод данного типа всегда один, располагается в конце цепочки промежуточных методов (если они есть). Данный метод возвращает другой тип объекта (например, Optional, коллекцию и т.д.). То есть конечный метод собирает результаты обработки элементов потока и возвращает единый результат. Конечный метод для завершения потока обязателен.

[к оглавлению](#FP-Lambda-Stream-API)

##  14. Перечислите конвейерные методы Stream API

Промежуточные (конвейерные) методы:

- filter() - фильтрует элементы потока, возвращая только элементы, удовлетворяющие условию.
- map() - преобразует каждый элемент потока.
- mapToInt() - тот же map(), но возвращает поток примитивов int (также есть соответствующие mapToDouble() и mapToLong()).
- flatMap() - трансформирует каждый объект потока в поток других объектов, то есть все элементы коллекции коллекций или потока потоков трансформирует в единый поток. (также поддерживает возврат потоков примитивов с помощью методов flatMapToInt(), flatMapToDouble(), flatMapToLong()). Может преобразовывать элементы, применяя указанную функцию к каждому элементу. 
- peek() - применяет функцию Consumer к каждому элементу потока.
- sorted() - сортирует элементы потока по возрастанию. Возможна сортировка по убыванию при передаче соответствующего компаратора.
-  skip() - пропускает указанное число элементов с начала потока.
- limit() - делает выборку первых элементов из родного потока в указанном количестве (отбирает элементы из потока, пока не достигнет указанного количества).
- distinct() - убирает дубликаты из потока.
- mapToObj() - трансформирует числовой поток в объектный.

[к оглавлению](#FP-Lambda-Stream-API)

## 15. Перечислите терминальные методы Stream API

Конечные (терминальные) методы:

- forEach() - применяет функцию к каждому элементу потока.
- collect() - собирает все элементы потока в структуру данных.
- toArray() - собирает элементы потока в массив.
- countz) - возвращает количество элементов в потоке.
- min() - возвращает минимальный элемент (условие передается в компараторе).
- max() - возвращает максимальный элемент (условие передается в компараторе).
- sum() - возвращает сумму всех элементов потока (только для числовых потоков).
- average() - возвращает среднее арифметическое всех элементов потока (только для числовых потоков).
- allMatch() - возвращает true, если все элементы удовлетворяют условию.
- noneMatch() - возвращает true, если все элементы не удовлетворяют условию.

Конечные (терминальные) методы, делающие обход потока только до нахождения элемента, удовлетворяющего условию:

- findFirst() - возвращает Optional с первым элементом потока (если он есть), иначе возвращает пустой Optional.
- findAny() - возвращает Optional со случайным элементом потока.
- anyMatch() - возвращает true, если хотя бы один элемент удовлетворяет условию.

[к оглавлению](#FP-Lambda-Stream-API)

## 16. Что такое отложенный выполнение lamdba?

Одним из ключевых моментов в использовании лямбд является отложенное выполнение (deferred execution). То есть мы определяем в одном месте программы лямбда-выражение и затем можем его вызывать при необходимости неопределенное количество раз в различных частях программы. Отложенное выполнение может потребоваться, к примеру, в следующих случаях:

- Выполнение кода отдельном потоке
- Выполнение одного и того же кода несколько раз
- Выполнение кода в результате какого-то события
- Выполнение кода только в том случае, когда он действительно необходим и если он необходим

Лямбда обладает свойством отложенного выполнения (deferred execution). У отложенного выполнения есть и "брат-близнец" - ленивая загрузка (lazy load).

Разница между ними в том, что отложенное исполнение начинает вычисление только тогда, когда пользователь запросил его результат, а ленивая загрузка подразумевает, что работа не будет производиться, пока она не понадобится.

Ленивая загрузка упоминается чаще в контексте загрузки элементов или объектов. Например, загрузка классов ссылочных полей загружаемого класса будет выполняться только тогда, когда к ним произойдёт явное обращение в программе. (Другой способ - это eager (энергичная) загрузка, когда вся последовательность элементов загружается сразу, а не только когда элемент необходим).

Отложенное выполнение более точно описывает процесс, происходящий в лямбде - код внутри неё начнет выполняться только тогда, когда произойдёт обращение за его результатом. 

Лямбда вычисляется, когда вызывается метод у функционального интерфейса.

https://job4j.ru/profile/exercise/33/task-view/243

## 17. Что делает метод filter?

`filter` промежуточная операция, используется для фильтрации через функцию.

Он принимает в качестве параметра некоторое условие в виде объекта `Predicate<T>`
и возвращает новый поток из элементов, которые удовлетворяют этому условию.

[к оглавлению](#FP-Lambda-Stream-API)

## 18. Что делает метод map?

`map` промежуточная операция. Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
то есть получить из элемента одного типа элемент другого типа.

`<R> Stream<R> map(Function<? super T, ? extends R> mapper) `
Передаваемая в метод `map` функция задает преобразование от объектов типа `T` к типу `R`.
И в результате возвращается новый поток с преобразованными объектами.

[к оглавлению](#FP-Lambda-Stream-API)

## 19. Что делает метод flatMap?

Метод flatMap() -  принимает элемент потока и преобразовывает его в новый поток.

`flatMap` промежуточная операция. Плоское отображение похоже на `map`, но может создавать из одного элемента несколько. 
Т.е. каждый объект будет преобразован в 0, 1 или несколько других объектов, поддерживаемых потоком. 

`<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`

Например, мы хотим установить для каждого телефона цену со скидкой и цену без скидки.
Т.е. из одного объекта Phone нам надо получить два объекта с информацией в виде строки.
```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                    new Phone("Samsung Galaxy S 6", 40000));
    phoneStream
        .flatMap(p->Stream.of(
                String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
                String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
        ))
        .forEach(s->System.out.println(s));
```

https://job4j.ru/profile/exercise/3/task-view/255

[к оглавлению](#FP-Lambda-Stream-API)

## 20. Что делает метод collect?

`collect` терминальная операция, преобразует поток в коллекцию. 

Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций, 
определенных в классе `Collectors`:
+ `toList()` преобразование к типу `List`
+ `toSet()` преобразование к типу `Set`
+ `toMap()` преобразование к типу `Map`

[к оглавлению](#FP-Lambda-Stream-API)

## 21. Что делает метод findFirst?

`findFirst` терминальная операция, возвращает первый элемент из стрима в виде обертки `Optional`

Метод Optional.orElse() проверяет возвращенное методом findFirst() значение типа Optional на его наличие, и если оно есть, то возвращает его, а если его нет, то возвращает значение, указанное по умолчанию. Обратите внимание, что терминальная операция в этом примере - метод findFirst() , в результате чего возвращается значение в типе Optional , из которого мы сразу же достаем значение с помощью метода orElse()., то есть сам поток фактически завершается после исполнения метода findFirst().

[к оглавлению](#FP-Lambda-Stream-API)

## 22. Что делает метод reduce?

`reduce` позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат.
Т.е. позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов.
```java
    int sum = Stream.of(1,2,3,4,5).
        reduce(10, (acc, x) -> acc + x)); //10+1+2+3+4+5=25
```

Метод `reduce` выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
Он имеет следующие формы:
1. `Optional< T> reduce(BinaryOperator< T> accumulator)`
2. `T reduce(T identity, BinaryOperator< T> accumulator)`
3. `U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator< U> combiner)`

Первая форма возвращает результат в виде объекта `Optional<T>`. Например, вычислим произведение набора чисел:

```java
    Stream< Integer> numbersStream = Stream.of(1,2,3,4,5,6);
    Optional< Integer> result = numbersStream.reduce((x,y)->x*y);
    System.out.println(result.get()); // 720
```

Объект `BinaryOperator< T>` представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
и следующему элементу в наборе бинарную операцию.

Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую
версию метода `reduce()`, которая в качестве первого параметра принимает `T identity`.
Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:

```java
    List<Integer> nums = Arrays.asList(1, 2, 3, 4);
        int sum = nums.stream() 
                .reduce(2, (a, b) -> a + b);
        System.out.println(sum);
```

- reduce (U identity, BiFunction< U, ? super T,U> accumulator, BinaryOperator< U> combiner) - расширенная версия второй формы. accumulator здесь позволяет выполнить промежуточное действие над элементами потока, после чего к ним будет применена агрегатная операция combiner. Данная форма метода аналогична комбинации методов map() и второй формы reduce(), то есть если нам нужно вернуть тип данных, отличный от входящего, то нужно использовать эту версию метода reduce().

```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000),
                new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000),
                new Phone("LG G 4", 32000));
    int sum = phoneStream.reduce(0,
                (x,y)-> {
                        if(y.getPrice()<50000)
                            return x + y.getPrice();
                        else
                            return x + 0;
                },
                (x, y)->x+y);
    System.out.println(sum); // 117000
```

Важно! Полноценная работа этой версии метода reduce(), а точнее работа combiner раскрывается только при выполнении вычислений потока (stream) в многопоточной среде.

[к оглавлению](#FP-Lambda-Stream-API)

## 23. Что делают методы min и max?

Методы min()/max() - агрегатные метод потоков. эти методы являются терминальными и сводят все элементы потока к одному значению.

- min() - возвращает минимальный элемент потока. Наименьший элемент определяется с помощью компаратора, который передается в параметр метода.

```java
public static void main(String[] args) {
        List<Integer> list = Arrays.asList(4, 5, 1, 3, 2);
        Optional<Integer> minEl = list.stream() 
                .min(Comparator.naturalOrder()); 
        System.out.println(minEl.get()); 
    }
```

Компаратор нужно передавать, чтобы метод понимал по какому принципу сравнивать объекты. Если метод min() применяется к потоку примитивных чисел, то можно использовать его без компаратора+

- max() - возвращает максимальный элемент потока. Наибольший элемент определяется с помощью компаратора, который передается в параметр метода. Работает аналогично методу min().

[к оглавлению](#FP-Lambda-Stream-API)

## 24. Что делают методы count, sum, average?

 - **count()** - возвращает число элементов в потоке.
 
 ```java
 List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);
        long sum = nums.stream() 
                .filter(el -> el % 2 == 0) 
                .count(); 
        System.out.println(sum); 
 ```
 
 - **sum()** - суммирует все элементы потока. Применяется только к числовым потокам.

```java
List<Person> people = Arrays.asList(
                new Person("Михаил", 35),
                new Person("Ольга", 26),
                new Person("Антон", 20),
                new Person("Виктор", 16),
                new Person("Анна", 29)
        );
        int sum = people.stream() 
                .mapToInt(Person::getAge) 
                .sum(); 
        System.out.println(sum);
```

- average() - возвращает среднее арифметическое всех элементов потока. Применяется только к числовым потокам. Метод возвращает OptionalDouble (Значение double, обернутое в Optional). 

```java
List<Person> people = Arrays.asList(
                new Person("Михаил", 35),
                new Person("Ольга", 26),
                new Person("Антон", 20),
                new Person("Виктор", 16),
                new Person("Анна", 29)
        );
        OptionalDouble average = people.stream() 
                .mapToInt(Person::getAge) 
                .average(); 
        double avg = average.getAsDouble(); 
        System.out.println(avg);
```

[к оглавлению](#FP-Lambda-Stream-API)

## 25. Что делают методы forEach и peek?

Оба этих метода выполняют одну и ту же функцию - применяют действие ко всем элементам потока. 

peek() - это промежуточная операция. Выполняет действие для каждого элемента потока, возвращая поток, состоящий из измененных элементов. *void forEach(Consumer< ? super T> action)*

forEach() - это конечная операция. Выполняет действие для каждого элемента потока, завершая поток. *Stream< T> peek(Consumer< ? super T> action)*

https://job4j.ru/profile/exercise/3/task-view/1004

[к оглавлению](#FP-Lambda-Stream-API)

## 26. Что делают методы skip и limit?

Процесс работы потока - это последовательный перебор всех элементов указанной структуры данных с применением к ним промежуточных операций после того, как запущена конечная операция. Из-за отсутствия индексов мы не можем таким образом выборочно работать с элементами, но в Java Stream API существуют методы, которыми можно вручную ограничить диапазон перебираемых элементов - skip() и limit().

- **skip(n)** - промежуточная операция, пропускает первые n элементов с начала потока. То есть задает начальную границу диапазона перебираемых элементов. Параметром нельзя задать отрицательное число, а если заданное значение параметра равно или превышает число элементов в исходной структуре данных, то будет возвращен пустой поток.

Важно! Числа, передающиеся в параметрах методов потоков, начинают отсчет с 1, так как исчисляется количество элементов. Не путать с индексом, где нумерация начинается с 0.

- **limit(n)** - промежуточная операция, возвращает новый поток, содержащий только первые n элементов из исходного потока, то есть задает конечную границу диапазона перебираемых элементов. Нельзя задать отрицательное значение параметра. Этот метод перебирает элементы, пока не накопит указанное количество элементов, после чего завершает перебор исходной структуры данных и возвращает новый поток из собранных элементов.

Таким образом, с помощью методов skip() и limit() можно вручную ограничить диапазон перебираемых элементов. Данный способ определения диапазона элементов часто применяется для нарезки страниц при постраничной навигации, чтобы выводить только определенное их количество на сайте.

https://job4j.ru/profile/exercise/3/task-view/1005

[к оглавлению](#FP-Lambda-Stream-API)

## 27. Что делают методы allMatch, noneMatch и anyMatch?

Методы проверки элементов потока на соответствие условию 

Все эти методы принимают Predicate в качестве параметра (условия для проверки). Также все 3 метода являются конечными (терминальными).

- **noneMatch()** - возвращает true, если ни один из элементов потока не удовлетворяет условию. *boolean noneMatch(Predicate< ? super T> predicate)*

```java
public static void main(String[] args) {
        List< String> strings = Arrays.asList("Один", "Два", "Три", "Четыре", "Пять");
        boolean rsl = strings
               .stream() 
               .noneMatch("Шесть"::contains); 
        System.out.println(rsl); 
    }
```

- **anyMatch()** -  возвращает true, если как минимум один из элементов потока удовлетворяет условию. *boolean anyMatch(Predicate< ? super T> predicate)*

```java
public static void main(String[] args) {
        List<String> strings = Arrays.asList("Один", "Два", "Три", "Четыре", "Пять");
        boolean rsl = strings
               .stream() 
               .anyMatch(e -> e.endsWith("ь")); 
        System.out.println(rsl); 
    }
```

- **allMatch()** - возвращает true, если все элементы потока удовлетворяют условию. *boolean allMatch(Predicate< ? super T> predicate)*

```java
public static void main(String[] args) {
        List<String> strings = Arrays.asList("Трижды", "Три", "Триста", "Три тысячи");
        boolean rsl = strings
                .stream() 
                .allMatch(e -> e.startsWith("Три")); 
        System.out.println(rsl);
    }
```

[к оглавлению](#FP-Lambda-Stream-API)

 ## 28. Что делают методы mapToInt, flatMapToInt, mapToObj?
 
 Методы преобразования потоков объектов в потоки примитивы и наоборот
 
 - **mapToInt()** - преобразовывает поток объектов в поток примитивных чисел типа int. Является промежуточной операцией. Применяется, если исходящий поток состоит из элементов-объектов, а в результате их обработки будет получен примитивный тип int. Метод mapToInt возвращает объект интерфейса IntStream (числовой поток), который в дальнейшем обрабатывается как поток примитивных чисел.

```java
List<String> strings = Arrays.asList("1", "2", "3", "4", "5"); 
        strings.stream() 
               .mapToInt(Integer::parseInt) 
                .filter(e -> e % 2 == 0)
                .forEach(System.out::println); 
```

метод mapToInt преобразовывает объекты типа String в примитивное значение int, создавая новый поток int (IntStream)

Класс Stream помимо метода mapToInt() также имеет аналогичные ему методы mapToDouble() и mapToLong(), работающие с Double и Long типами соответственно. 

- **flatMapToInt()** - трансформирует поток массивов в поток примитивных чисел int. Работает как mapToInt(), но возвращает не одно преобразованное в int значение, а поток примитивов int. Является промежуточной операцией.

```java
int[] array1 = {1, 2, 3};
        int[] array2 = {4, 5, 6};
        int[] array3 = {7, 8, 9};
        List<Integer> list = Stream.of(array1, array2, array3) 
                .flatMapToInt(Arrays::stream) 
                .boxed() 
                .collect(Collectors.toList()); 
        System.out.println(list);
```
метод flatMapToInt() последовательно запускает поток из каждого массива исходящего потока, в результате чего все элементы этих массивов объединяются в один общий поток примитивных чисел int.

примитивные числа не являются объектами, поэтому для того, чтобы собрать в List наш поток элементов типа int, нужно обернуть их в тип Integer. Это можно сделать с помощью метода boxed().

Класс Stream помимо метода flatMapToInt() также имеет аналогичные ему методы  flatMapToDouble() и flatMapToLong(), работающие с Double и Long типами соответственно. 

- **mapToObj()** - преобразует поток примитивных чисел в поток объектов. Является промежуточной операцией.

```java
List<String> list = IntStream.rangeClosed(1, 5) 
                .mapToObj(String::valueOf) 
                .collect(Collectors.toList()); 
        System.out.println(list);
```

[к оглавлению](#FP-Lambda-Stream-API)

## 29. Что такое числовой поток?

поток примитивных чисел int, double, long

interface IntStream - A sequence of primitive int-valued elements supporting sequential and parallel aggregate operations. This is the int primitive specialization of Stream.

[к оглавлению](#FP-Lambda-Stream-API)

## 30. Чем отличается Stream< Integer> от IntStream< int>?

`IntStream` поток примитивных int значения.

`Stream< Integer>` это поток Integer объекты.

Отличаетс список методов. У `IntStream` есть встроенные методы range(), sum() и тд. У Stream можно решить эту проблему через reduce(), но все же

Упаковка и распаковка требует времени. Множество временных упакованных объектов часто вызывают сборщик мусора, особенно если объектов действительно много.

Но большей проблемой являетс занимаемая память int занимает 4 байта, тогда как объект Integer 4 байта отводит на ссылку плюс 16 байт на сам объект, итого суммарно 20 байт, те в 4 раза больше памяти.

Это особенно актуально, если вы вызываете toArray(), поскольку существует большая разница между int[] и Integer[] 

[к оглавлению](#FP-Lambda-Stream-API)

## 31. Что делает метод boxed?

абстрактный метод интрефейса `IntStream` *Stream< Integer> boxed()* - Возвращает Stream, состоящий из элементов этого потока, каждый из которых упакован в Integer. Является промежуточной операцией

примитивные числа не являются объектами, поэтому для того, чтобы собрать в List наш поток элементов типа int, нужно обернуть их в тип Integer. Это можно сделать с помощью метода boxed()

[к оглавлению](#FP-Lambda-Stream-API)

## 32. Возможно ли прервать выполнение потока по аналогии с break?

Stream может выполнятся в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.

С Java 9 можно использовать `java takeWhile` - промежуточная операция, возвращает элементы до тех пор, пока они
удовлетворяют условию, т.е. предикат возвращает `true`.

Stream.takeWhile - это метод позволяет получать поток данных до тех пор, пока он проходит фильтр.

```java
List.of(1, 2, 3, 4).stream()
                .takeWhile(v -> v < 3)
                .map(v -> "Результат: " + v)
                .forEach(System.out::println);
```

Лучше использовать итератор:
```java
    Iterator<BuyOrderType> iter = market.buyOrders() // replace BuyOrderType with correct type here
                .stream()
                .filter(buyOrder -> buyOrder.price >= sellOrder.price)
                .sorted(BY_ASCENDING_PRICE).iterator();
    while (iter.hasNext()) {
        BuyOrderType buyOrder = iter.next()  // replace BuyOrderType with correct type here
        double tradeVolume = Math.min(buyOrder.quantity, sellOrder.quantity);
        double price = buyOrder.price;
        buyOrder.quantity -= tradeVolume;
        sellOrder.quantity -= tradeVolume;
        Trade trade = new Trade.Builder(market, price, tradeVolume, Trade.Type.SELL).build();
        CommonUtil.convertToJSON(trade);
        if (sellOrder.quantity == 0) {
            System.out.println("order fulfilled");
            break;
        }
    }
```

[к оглавлению](#FP-Lambda-Stream-API)

## 33. Возможно ли пропустить элемент потока по аналогии с continue?

Вместо этого можно использовать `filter` - промежуточная операция, фильтрует элементы по условию.

А также `return`:
```java
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");
        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.
            System.out.println(str); // a c
        });
    }
```

collection.stream().skip(N) - позволяет пропустить N первых элементов./ промежуточная операция, пропускает первые n элементов с начала потока.

[к оглавлению](#FP-Lambda-Stream-API)

## 34. Что такое Optional?

Класс java.util.Optional - это обертка на null.

В релизе Java 8 появился новый класс `Optional` призванный помочь разработчикам в обработке `NullPointerException`.

Опциональное значение `Optional` - это контейнер для объекта. Он может содержать значение или некоторый тип `<T>`, или
просто быть `null`.

Такая обертка является удобным средством предотвращения `NullPointerException`, т.к. имеет некоторые функции высшего 
порядка, избавляющие от добавления повторяющихся `if null/not null` проверок, что позволяет фокусироватья на 
выполнении непосредственной задачи.

```java
    //Пустой Optional объект
    Optional<Person> optionalPerson = Optional.empty();
    
    //Optional объект с ненулевым значением
    Optional<Person> optionalNonNull = Optional.of(somePerson);
    
    //Optional объект с возможностью нулевого значения
    Optional<Person> optionalNullable = Optional.ofNullable(somePerson);
```

Метод `ifPresent()` позволяет также устранить некоторую избыточность кода, следующего вида:
```java
     if(person != null) {
    	System.out.println(person);
     }
```
Те же действия, но с использованием `Optional`: `person.ifPresent(System.out::println);`

`orElse()`, `orElseThrow()`:

Как было раньше:`java Person personNew = person != null ? person : new Person();`

То же самое, но с использованием `Optional`: `java Person personNew = person.orElse(new Person());`

Или, если не хотим создавать объект, можно выбросить исключение:
`java Person personNewThrow = person.orElseThrow(Exception::new);`

[к оглавлению](#FP-Lambda-Stream-API)

## 35. Перечислите методы Optional?

+ `Optional.empty()` - возвращает `Optional` с `null` внутри.
+ `Optional.of(T value)` - возвращает `Optional` с `not null` значением внутри.
+ `Optional.ofNullable(T value)` - возвращает `Optional` который может содержать `null` значение внутри.

Методы конкретного объекта `Optional`:
+ `filter(Predicate<? super T> predicate)` - дает возможность отфильтровать значение опционального типа.
Мы передаем ему в параметр `Predicat` (это стандартный функциональный интерфейс), он возвращает булево значение. 
Если значение `true`, то возвращается этот же опционал, 
если значение `false`, то возвращается пустой опционал `Optional.empty()`.

+ `flatMap(Function<? super T,Optional<U>> mapper)` - применяется для изменения значения установленного в опционале. 
Функция которая передается в метод `flatMap` должна возвращать опционал. 
Если значение не установлено, вернется `Optional.empty()`.

+ `get()` - возвращает значение из объекта `Optional`. Нужно аккуратно использовать этот метод, т.к. он может бросить 
исключение `NoSuchElementException`, если значение в опционале равно `null`.
Чтобы безопасно использовать этот метод, перед его вызовом надо вызвать метод `isPresent()`.

+ `isPresent()` - возвращает булево значение `true`, если в опционале значение есть и возвращает `false`,
 если в опционале значение `null`.

+ `orElse(T other)` - используется для того, чтобы установить значение по-умолчанию в том случае,
если значение в опционале отсутствует.

+ `orElseGet(Supplier<? extends T> other)` - это аналог метода `orElse`,
только принимает в себя функциональный интерфейс, который должен вернуть значение.

+ `orElseThrow(Supplier<? extends X> exceptionSupplier)` - используется для того, чтобы бросить исключение,
которое передается в метод `orElseThrow`, если значения в опционале не установлено.

+ `ifPresent(Consumer<? super T> consumer)` - исполняет функциональный интерфейс `Consumer`, если значение в опционале 
присутствует. Т.е. в `ifPresent` передается фуекция, которая принимает один параметр - значение из `Optional`.

подробнее https://habr.com/ru/post/346782/

[к оглавлению](#FP-Lambda-Stream-API)

## 36. Расскажите про фабричные методы Listof Setof Mapof?

С приходом Java 9 создавать неизменяемые `immutable` коллекции `List`, `Set`, `Map` стало намного проще.
Фабричные методы позволяют преобразовывать элементы в потоки.

1. Создание списка `List<Integer> nums = List.of(1,2,3,4,5);`

    Метод `of()` в интерфейсе `List` перегружен и принимает от одного до десяти элементов. 
Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с `varargs`:
`static <E> List<E> of(E... elements)`. Это сделано с целью оптимизации, т.к. при каждом вызове метода c `varargs` 
будет создаваться новый массив

2. Создание множества `Set<String> questions = Set.of("What?", "Where?", "When?");`

    Метод `of()` также имеет перегруженные методы, но в отличии от `List`, если передать дубликат в метод `of()`, то получим исключение
`Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What?`

3. Создание карты `Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried");`

    Последовательности идут парами `key`, `value`. Всего таких пар может быть 10, в отличии от `List` и `Set`,
если в последовательности будут повторения ключей - получим исключение
`Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально`

Обратите внимание:
+ Вышеупомянутые коллекции нельзя изменить, при попытке получим `UnsupportedOperationException`.
+ В метод `of()` нельзя передать `null`, во всех коллекциях получим `NullPointerException`.
+ Метод `of()` не создает привычные `ArrayList`, `HashSet` или `HashMap`. В Java 9 были созданы специальные 
`ImmutableCollections` которые и возвращаются.
+ `ImmutableCollections` являются сериализуемыми, если содержимое тоже является сериализуемым.

[к оглавлению](#FP-Lambda-Stream-API)

## 37. Для чего используется ключевое слово var?

Нововведение Java 10 `var` аббревеатура `Local Variable Type-Inference`, 
используется для вывода типов локальных переменных.

Дает возможность сократить объявления переменных используя ключевое слово `var`.
При обработке `var`, компилятор просматривает правую часть объявления,
так называемый инициализатор и использует его тип для переменной.

`var` доступна только для локальных переменных с инициализатором. 
```java
     var first = 1;
     var second = 2;
     var rst = first + second;
     System.out.println(rst);
     
     var list = List.of(1, 2, 5);
     
     for(var item : items) {
        System.out.println(item);
     }
```

`var` это зарезервированное имя, но не ключевое слово (наряду с `true`, `false`, и `null`), что обеспечивает обратную 
совестимость программ, использующих его.

`var` нельзя использовать для:
+ полей класса;
+ параметров методов;
+ переменных без знания (т.е. без инициализатора).

также `var`:
+ не будет работать, если инициализируется `null`.
+ не будет работать для нелокальных переменных.
+ нельзя использовать в лямбда-выражениях, т.к. им нужен явный целевой тип.
+ нельзя использовать в случае инициализации массива.

[к оглавлению](#FP-Lambda-Stream-API)

## 38. В каких случаях можно использовать var?

`var` доступна только для локальных переменных

`var` может использоваться только в сочетании с данными, т.е. нужно обязательно инициализировать переменную.
Компилятору нужно знать тип переменной, а тип можно извлечь только из значения.

[к оглавлению](#FP-Lambda-Stream-API)

## 25. ?



[к оглавлению](#FP-Lambda-Stream-API)

## Источники:

Изменения в языке Java 8 
https://www.ibm.com/developerworks/ru/library/j-java8lambdas/index.html

Встроенные функциональные интерфейсы
https://metanit.com/java/tutorial/9.3.php

Исключения в лямбда-выражениях Java 8
https://www.codeflow.site/ru/article/java-lambda-exceptions

Javadoc `Interface Stream<T>` 
https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Полное руководство по Java 8 Stream API в картинках и примерах 
https://annimon.com/article/2778

Шпаргалка Java программиста 4. Java Stream API 
https://habr.com/ru/company/luxoft/blog/270383/

паттерне pipeline 
https://medium.com/@deepakbapat/the-pipeline-design-pattern-in-java-831d9ce2fe21

Optional: Кот Шрёдингера в Java 8
https://habr.com/ru/post/346782/

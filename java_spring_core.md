## Spring Core

[1. Что такое Spring? Какие основные задачи выполняет этот фреймворк?](#1-Что-такое-Spring-Какие-основные-задачи-выполняет-этот-фреймворк)

[2. Что такое IoC и DI? В чем отличие этих терминов?](#2-Что-такое-IoC-и-DI-В-чем-отличие-этих-терминов)

[3. Перечислите основные модули Spring фреймворка.](#3-Перечислите-основные-модули-Spring-фреймворка)

[4. Что такое фабрика бинов  BeanFactory?](#4-Что-такое-фабрика-бинов-BeanFactory)

[5. Перечислите способы внедрения зависимостей и объясните их отличия друг от друга.](#5-Перечислите-способы-внедрения-зависимостей-и-объясните-их-отличия-друг-от-друга)

[6. Что такое ApplicationContext? Когда он создается?](#6-Что-такое-ApplicationContext-Когда-он-создается)

[7. С какой целью выполняется конфигурирование контекста, какими способами это конфигурирование может производиться и какие отличия есть между ними.](#7-С-какой-целью-выполняется-конфигурирование-контекста-какими-способами-это-конфигурирование-может-производиться-и-какие-отличия-есть-между-ними)

[8. Где и для чего применяются аннотации @Configuration, @ComponentScan, @PropertySource. Что в них должно быть указано?](#8-Где-и-для-чего-применяются-аннотации-Configuration-ComponentScan-PropertySource-Что-в-них-должно-быть-указано)

[9. Можно ли использовать несколько конфигурационных файлов? Если да, то как это сделать? Если нет, то почему?](#9-Можно-ли-использовать-несколько-конфигурационных-файлов-Если-да-то-как-это-сделать-Если-нет-то-почему)

[10. Расскажите, что такое Spring Bean.](#10-Расскажите-что-такое-Spring-Bean)

[11. Когда необходимо объект делать бином?](#11-Когда-необходимо-объект-делать-бином)

[12. Какие существуют способы создания бинов? Чем они друг от друга отличаются?](#12-Какие-существуют-способы-создания-бинов-Чем-они-друг-от-друга-отличаются)

[13. Опишите стратегию нейминга (присвоения имени бину) в Spring](#13-Опишите-стратегию-нейминга-присвоения-имени-бину-в-Spring)

[14. Каким образом можно самостоятельно присвоить имя бину?](#14-Каким-образом-можно-самостоятельно-присвоить-имя-бину)

[15. Опишите жизненный цикл Spring Bean. Каким образом можно изменять этот жизненный цикл?](#15-Опишите-жизненный-цикл-Spring-Bean-Каким-образом-можно-изменять-этот-жизненный-цикл)

[16. Опишите предназначение каждого этапа жизненного цикла бина](#16-Опишите-предназначение-каждого-этапа-жизненного-цикла-бина)

[17. Какие аннотации являются стереотипными? Почему они имеют такое название? Какие особенности в поведение бина они привносят?](#17-Какие-аннотации-являются-стереотипными-Почему-они-имеют-такое-название-Какие-особенности-в-поведение-бина-они-привносят)

[18. Объясните для чего используются аннотации @Autowired, @Qualifier, @Primary, @Resource. Когда какую нужно использовать?](#18-Объясните-для-чего-используются-аннотации-Autowired-Qualifier-Primary-Resource-Когда-какую-нужно-использовать)

[19. Что такое AOP и для чего используется модуль Spring AOP](#19-Что-такое-AOP-и-для-чего-используется-модуль-Spring-AOP)

[20. Назовите основные аннотации, используемые в модуле AOP](#20-Назовите-основные-аннотации-используемые-в-модуле-AOP)

[21. Как подключить AOP к проекту?](#21-Как-подключить-AOP-к-проекту)

[22. Что означает термин "Аспект" в парадигме AOP?](#22-Что-означает-термин-Аспект-в-парадигме-AOP)

[23. Что означает термин "advice" (совет)  в парадигме AOP?](#23-Что-означает-термин-advice-совет-в-парадигме-AOP)

[24. Какие бывают виды advice? В чем их отличие друг от друга?](#24-Какие-бывают-виды-advice-В-чем-их-отличие-друг-от-друга)

[25. Что такое PointCut?](#25-Что-такое-PointCut)

[26. Опишите, каким образом происходит работа Srping при использовании модуля AOP](#26-Опишите-каким-образом-происходит-работа-Srping-при-использовании-модуля-AOP)

## 1. Что такое Spring? Какие основные задачи выполняет этот фреймворк?

Фреймворк Spring (или просто Spring) — это прикладной фреймворк, который является частью экосистемы Java. В настоящее время Spring используется для написания самых разных программ, от крупных серверных решений до средств автоматизации тестирования.

Прикладной фреймворк — это пакет типичных функций программного обеспечения, образующих базовую структуру для разработки приложения. Он позволяет тратить меньше усилий при написании приложения, так как не приходится создавать весь код программы с нуля.  Прикладной фреймворк  предоставляет широкий набор инструментов и функций, которые можно применять в разработке. Вы не обязаны использовать их все. В зависимости от требований, предъявляемых к разрабатываемому приложению, вы будете выбирать ту часть фреймворка, которая вам нужна.

Концепция фреймворка не нова. На протяжении всей истории разработки ПО программисты замечали, что многие фрагменты написанного ими кода можно использовать повторно в других приложениях. Поначалу, когда приложений было мало, каждое из них было уникально и писалось с нуля на том или ином языке программирования. По мере того, как область применения программного обеспечения расширялась и на рынке появлялось все больше продуктов, стало еще заметнее, как много приложений имеют сходные требования. Вот некоторые из них:

- в каждом приложении предусмотрены уведомления при ошибках входа, предупреждения и информационные сообщения;

- в большинстве приложений для обработки изменений данных используются транзакции. Транзакции являются важным механизмом, который обеспечивает целостность данных;

- в большинстве приложений применяются механизмы защиты от одних и тех же распространенных уязвимостей;

- в большинстве приложений используются одни и те же механизмы обмена данными с другими приложениями;

- в большинстве приложений есть одни и те же механизмы повышения производительности, такие как кеширование и сжатие данных;

В сущности, код бизнес-логики, реализованной в приложении, значительно меньше, чем вся эта внутренняя начинка.

Функционал, не относящийся к бизнес-логике, может многократно внедряться в разные приложения. Имеет ли смысл каждый раз заново его переписывать? Разумеется, нет. Эту задачу берет на себя фреймворк.

[к оглавлению](#Spring-Core)

## 2. Что такое IoC и DI? В чем отличие этих терминов?

**Инверсия управления (Inversion of Control).**

Spring Core — это та часть фреймворка Spring, которая обеспечивает фундаментальные механизмы его интеграции в приложение. Spring работает по принципу инверсии управления (inversion of control, IoC): вместо того чтобы приложение само контролировало свое выполнение, управление передается некоторому другому программному обеспечению — в данном случае фреймворку Spring. 

Посредством системы настроек мы предоставляем фреймворку Spring инструкции о том, как распоряжаться написанным нами кодом, что и определяет логику работы приложения. Именно это и подразумевается под «инверсией» в аббревиатуре IoC: мы не позволяем приложению управлять собственным выполнением посредством его же кода или использовать зависимости. Вместо этого мы передаем фреймворку (зависимости) управление приложением и его кодом. В этом контексте «управление» означает такие действия, как «создание экземпляра» или «вызов  метода». 

**Внедрение зависимости (Dependency Injection)**

Внедрение зависимости — это инициализация полей объекта другими объектами.

Помимо создания объектов, Spring-контейнер внедряет эти объекты в другие объекты, то есть делает их полями других объектов. Детали внедрения для нас как разработчиков не важны, главное знать, как объяснить фреймворку, какие объекты вы хотите отдать под его управление, и в какие поля других объектов вы хотите их внедрить. Шаблон Dependency Injection не привязан к Spring, это всего лишь инициализация поля класса. Этот шаблон часто встречается в коде (внедрение через конструктор либо сеттер) любых приложений, не обязательно Spring. В связи со Spring это название используется часто потому, что внедрение выполняет Spring, а программист должен указывать Spring'у конфигурацию внедрения этих зависимостей. 

[к оглавлению](#Spring-Core)

## 3. Перечислите основные модули Spring фреймворка.

Spring — это целая экосистема фреймворков. Как правило, когда разработчики упоминают фреймворк Spring, они имеют в виду часть программного функционала, которая включает в себя следующее:

1.  Spring Core — фундаментальная часть Spring, в которой реализован его базовый функционал. Одной из этих функций является контекст Spring - это фундаментальная функциональная возможность, благодаря которой Spring может управлять экземплярами приложения. Также частью функционала Spring  являются аспекты Spring. С ними Spring может перехватывать определенные в приложении методы и манипулировать ими . Еще один компонент - это Spring Expression Language (SpEL). Он позволяет описывать конфигурации Spring с помощью специального языка. 

2. Spring MVC (model-view-controller, «модель — представление — контроллер»). Эта часть фреймворка Spring позволяет создавать веб-приложения, обрабатывающие HTTP-запросы. 

3. Spring Data Access — еще одна базовая часть Spring. Она предоставляет основные инструменты для соединения с базами данных SQL, что позволяет реализовать уровень доступа к данным в приложении. 

4 Spring Testing. Эта часть фреймворка включает в себя инструменты, позволяющие писать тесты для Spring-приложения. 

Экосистема Spring — это гораздо больше, чем просто функции, описанные выше. Она включает в себя множество других фреймворков, хорошо интегрированных между собой, как Spring Data, Spring Security, Spring Cloud, Spring Batch, Spring Boot и т.д. Полный список  проектов на официальном сайте Spring - https://spring.io/projects/

- ---------------------------

https://tproger.ru/articles/spring-modules-overview

Spring — это фреймворк для разработки приложений на языке Java. Он состоит из нескольких модулей, которые можно использовать в зависимости от потребностей проекта. Ниже перечислены основные модули Spring:

1. Spring Core — модуль, который содержит основные классы и интерфейсы фреймворка, такие как SpringApplication, BeanFactory и ApplicationContext.

2. Spring AOP — модуль, который позволяет добавлять функциональность Aspect-Oriented Programming (AOP) в приложение Spring.

3. Spring MVC — модуль, который предоставляет компоненты для создания веб-приложений на основе фреймворка Spring.

4. Spring Data — модуль, который предоставляет различные модули для работы с базами данных, такие как Spring JDBC, Spring Hibernate и Spring Data JPA.

5. Spring Security — модуль, который обеспечивает безопасность приложения, позволяя контролировать доступ к ресурсам и защищать их от несанкционированного доступа.

[к оглавлению](#Spring-Core)

## 4. Что такое фабрика бинов  BeanFactory?

Базовый интерфейс к Spring DI является интерфейс BeanFactory.

BeanFactory содержит методы получения бинов из контекста. 

Интерфейс BeanFactory имеет множество реализаций. В это примере мы рассмотрим самый примитивный - DefaultListableBeanFactory:

```java
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import ru.job4j.di.model.StartUI;
import ru.job4j.di.model.Store;

public class BeanFactoryDI {
    public static void main(String[] args) {
        DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory();
        BeanDefinition storeDefinition = BeanDefinitionBuilder.rootBeanDefinition(Store.class).getBeanDefinition();
        BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(StartUI.class).getBeanDefinition();
        defaultListableBeanFactory.registerBeanDefinition("store", storeDefinition);
        defaultListableBeanFactory.registerBeanDefinition("ui", beanDefinition);
        StartUI ui = defaultListableBeanFactory.createBean(StartUI.class);
        ui.add("Petr Arsentev");
        ui.add("Ivan ivanov");
        ui.print();
    }
}
```

BeanDefinition - описывает bean-компоненты. Создается на основе разобранной мета-информации.

BeanFactory - это интерфейс который создает и предоставляет bean-компоненты на основе BeanDefinition-ов. Он является ядром ApplicationContext.

- --------------------------

Фабрика бинов (BeanFactory) — это основной компонент фреймворка Spring, который отвечает за управление бинами (Bean) в приложении. Фабрика бинов создает, уничтожает и управляет бинами в приложении. Она также отвечает за настройку бинов и предоставление их клиентам.

BeanFactory — это интерфейс, который определяет основные методы для работы с бинами. Он может быть реализован различными способами, например, как Singleton или как прототип. Фабрика бинов обычно создается в начале работы приложения и существует на протяжении всего его жизненного цикла.

BeanFactory используется для определения и регистрации бинов в приложении. При регистрации бина в Factory, он становится доступным для клиентов, которые могут его использовать для получения экземпляров бинов.

BeanFactory также может использоваться для настройки бинов с помощью конфигурационных свойств. Это позволяет определить различные параметры и свойства бина, такие как его класс, зависимости, методы и т.д.

В общем, Фабрика бинов является центральным элементом фреймворка Spring, который обеспечивает управление и доступ к бинам в приложении.

[к оглавлению](#Spring-Core)

## 5. Перечислите способы внедрения зависимостей и объясните их отличия друг от друга.

Преимущества и недостатки различных способов внедрения бинов.

1.Внедрение в поле - преимущество в отсутствии дополнительного кода, недостаток в том, что поле нельзя объявить final, соответственно объект нельзя выполнить неизменяемым. Плюс сложности при тестировании класса - для внедрения зависимости надо поднимать контекст.

```java
@Autowired
private Dog dog;
```

2.Внедрение с помощью метода -  главный недостаток в том, что нельзя создать неизменяемый объект.

```java
@Autowired
public void setBird(Bird bird) {
    this.bird = bird;
}
```

3.Внедрение с помощью конструктора - наиболее рекомендуемый способ внедрения. Можно создавать неизменяемые объекты, простой процесс тестирования.

```java
@Autowired
public Man(Cat cat) {
    this.cat = cat;
}
```

![image](https://github.com/artemaverin/summary/assets/97846877/88a3aebe-f54e-4e98-8610-096cf370020e)


[к оглавлению](#Spring-Core)

## 6. Что такое ApplicationContext? Когда он создается?

ApplicationContext — это контекст, который используется в Spring Framework для управления приложением. Он содержит все необходимые бины (объекты, которые могут быть использованы в приложении), которые были загружены и инициализированы во время процесса инициализации приложения.

ApplicationContext создается в начале работы приложения, когда Spring Framework запускает процесс инициализации. В этот момент все бины, которые были определены в конфигурационном файле Spring, загружаются и инициализируются, а затем помещаются в ApplicationContext. После этого ApplicationContext может быть использован для получения доступных бинов, которые могут быть использованы в приложении.

BeanFactory содержит только методы получения бинов. У BeanFactory есть расширенный интерфейс ApplicationContext. 

Отличия BeanFactory и ApplicationContext.
Интерфейс BeanFactory — это самая базовая версия контейнеров IoC, а интерфейс ApplicationContext - это один из потомков, который расширяет возможности BeanFactory .
BeanFactory загружает компоненты по запросу, а ApplicationContext загружает все компоненты при запуске . Таким образом, BeanFactory легче по сравнению с ApplicationContext .
ApplicationContext обладает гораздо более широким функционалом, чем BeanFactory.

[к оглавлению](#Spring-Core)

## 7. С какой целью выполняется конфигурирование контекста, какими способами это конфигурирование может производиться и какие отличия есть между ними.

https://job4j.ru/profile/exercise/202/task/1155/471495

Для создания контекста Spring'у  требуются классы объектов и метаинформация об этих классах. Метаинформацию мы предоставляем в специальном конфигурационном файле. 

При создании метаинформации о бинах надо разрешить два вопроса.  Первый - какую именно информацию о бине надо передавать? Второй -  каким способом передать эту информацию?

Давайте последовательно ответим на эти вопросы.

**Первый вопрос. Какая информация о бине требуется фреймворку.**

После создания бина в контексте вся ранее предоставленная информация о нем содержится в виде объектов класса BeanDefinition. Соответственно, эту информацию  и надо передать в конфигурационном файле:

- имя класса с указанием пакета: обычно это фактический класс реализации определяемого компонента.

 - элементы конфигурации поведения компонента, которые указывают, как компонент должен вести себя в контейнере (область действия, обратные вызовы жизненного цикла и т. д.).

- ссылки на другие bean-компоненты, необходимые для работы bean-компонента. Эти ссылки также называются соавторами или зависимостями.

- другие параметры конфигурации, которые необходимо установить во вновь созданном объекте — например, предельный размер пула или количество подключений для использования в bean-компоненте, который управляет пулом подключений.

Эти метаданные транслируются в набор свойств, составляющих каждое определение компонента. 

**Class.**  Это единственное обязательное свойство, которое мы должны указать при создании бина.  Здесь мы указываем адрес класса, в котором происходит создание бина. Если создание бина производится с помощью конструктора (оператором new...), то достаточно указать только адрес класса. Если создание бина происходит с помощью статичесвкого фаричного метода, то указываем класс и имя фабричного метода. Если бин создается с помощью соответствующего метода фабрики экземпляров, то сначала регистрируем бин фабрики, а затем используем бин фабрики и имя метода.

**Name.** Это необязательное свойство. Контейнер сам присвоит уникальное имя бину в соответствии со своей стратегией наименования. Однако, если нам надо обращаться к этому бину по имени, то мы должны указать имя. Каждому бину мы можем указать его ID, имя name и псевдонимы alias. 

**Scope.** Область применения бина. Это необязательное свойство. Если его не указать явно, контейнер создаст этот бин как singleton. Мы можем изменить его, указав свойство как prototype. Отличие между ними в следующем: если бин объявлен как singleton, то он создается в контексте в одном экземпляре, и на все запросы контекст вернет единственный экземпляр бина. Если же  бин объявлен как  prototype, то на каждый запрос будет создан новый экземпляр и контекст будет возвращать каждый раз новый экземпляр этого бина. Кроме singleton и  prototype, есть еще такие области, как request, session, application и webSocket. Они используются в веб-ориентированном приложении и ограничиваются соответственно запросом, сессией, длительностью работы приложения и сокета.

**Constructor arguments  и Properties .** Эти свойства описывают порядок внедрения зависимостей - других бинов.

**Autowiring mode.** Устанавливает для бина режим автоматического связывания (внедрения) других бинов. Это необязательное свойство. По умолчанию этот режим отключен (установлен в no). В этом режиме нам надо самостоятельно определять бины, которые надо использовать для внедрения. Режим byname. Автосвязывание производится по имени свойства. Spring ищет bean-компонент с тем же именем, что и свойство, которое необходимо автоматически связать. Например, если определение компонента настроено на автосвязывание по имени и оно содержит свойство master (то есть у него есть метод setMaster(..)), Spring ищет определение компонента с именем master и использует его для установки свойства. 

**Lazy initialization mode.** Режим ленивой загрузки. Это необязательное свойство, по умолчанию Spring устанавливает это свойство в режим false. Это означает, что бин будет создан в контексте сразу при поднятии контекста. Если указать lazy = true, то бин будет создан только тогда, когда он реально потребуется. 

**Initialization method, Destruction method.** Эти свойства необязательные. Если нами определены эти методы обратного вызова, то указываются имена этих методов.

**Второй вопрос. Каким способом передать информацию фреймворку.**

Есть три варианта. 

**XML-based configuration.** В этом случае конфигурация описывается в xml-файле, код java-классов получается отделен от фреймворка - в них нет ни аннотаций, ни иных указаний на Spring. Этот вариант конфигурирования применялся с самого начала возникновения Spring и сейчас считается устаревшим.

**Annotation-based configuration.** В этом случае конфигурация описывается в xml-файле, но часть бинов может быть описана стереотипными аннотациями в java-коде, и в xml-файле указываются пакеты, в которых эти классы находятся.

**Java-based configuration.** Это современный подход, в котором отсутствует конфигурационный xml-файл, а вся конфигурация контекста описывается аннотациями в java-коде классов. 

[к оглавлению](#Spring-Core)

## 8. Где и для чего применяются аннотации @Configuration, @ComponentScan, @PropertySource. Что в них должно быть указано?

Аннотация @Configuration указывает на то, что в этом классе содержится конфигурационная информация.

Аннотация @ComponentScan(basePackages = "annotation")  указывает Spring'у пакет, в котором находятся классы компонентов.

Аннотация @Configuration сообщает фреймворку, что этот класс содержит конфигурационную информацию, аннотация @ComponentScan дает информацию о пакете, который фреймворк должен просканировать при поиске компонентов, аннотация @PropertySource сообщает, что программе требуется информация из файла свойств application.properties.
- -------------------------------

Аннотации `@Configuration`, `@ComponentScan` и `@PropertySource` используются в Spring Framework для облегчения процесса конфигурации и управления компонентами приложения.

1. `@Configuration`: Эта аннотация указывает Spring, что класс является конфигурационным. Spring будет использовать этот класс для настройки приложения. В классе, помеченном этой аннотацией, вы можете определить различные аспекты конфигурации, такие как управление бинами, определение методов управления и т.д.

2. `@ComponentScan`: Эта аннотация позволяет Spring сканировать пакет или класс на наличие компонентов, которые нужно автоматически зарегистрировать в среде выполнения. Это упрощает процесс управления бинами, так как вам не нужно явно регистрировать каждый компонент в файле конфигурации.

3. `@PropertySource`: Эта аннотация позволяет вам указать Spring, откуда он должен загружать свойства. Вы можете использовать это для загрузки свойств из файлов конфигурации, базы данных или других источников. В классе, помеченном этой аннотацией, вы должны определить методы getProperty(), которые будут возвращать свойства.

В каждой из этих аннотаций должно быть указано соответствующее значение, которое определяет, как именно Spring должен обрабатывать конфигурацию или сканирование компонентов. Например, в `@Configuration` вы можете определить методы, которые будут возвращать бины, которые нужно использовать в приложении. В `@ComponentScan` вы можете указать пакет или класс, который нужно сканировать, а в `@PropertySource` вы можете указать источник свойств, который нужно использовать.

[к оглавлению](#Spring-Core)

## 9. Можно ли использовать несколько конфигурационных файлов? Если да, то как это сделать? Если нет, то почему?

web.xml

Да, для чего используется contextConfigLocation. С его помощью вы сможете задать несколько файлов конфигурации, указывая параметры через пробел либо запятую:

![image](https://github.com/artemaverin/summary/assets/97846877/2e2d7f13-8ccb-4ce6-b3d2-26e5e603b7ce)

Важно отметить, что есть возможность указать нескольких корневых файлов конфигурации:

![image](https://github.com/artemaverin/summary/assets/97846877/e71b50ed-f98a-48c9-953c-3455e53667cc)

- -----------------------

можно использовать SpringApplicationBuilder для того, чтоб создать несколько контекстов объедененых в иерархию:

```java
new SpringApplicationBuilder(ParentConfig.class)
   .child(ChildConfig.class)
   .run(args);
```
Или вообще два независимых контекста (и значит два независимых spring boot приложения в одном java процессе):

```java
SpringApplicationBuilder applicationBuilder = new SpringApplicationBuilder()
    .sources(ParentConfig.class);
applicationBuilder.child(Application1Config.class).run(args);
applicationBuilder.child(Application2Config.class).run(args);
```
- ----------------------------

Да, в Spring можно использовать несколько конфигурационных файлов. Это может быть полезно в больших приложениях, где один файл конфигурации может стать слишком объемным и сложным для управления.

Spring предоставляет несколько способов разделения конфигурации на несколько файлов:

1.  *  * Вложенные конфигурационные файлы *  * : Вы можете хранить несколько конфигурационных файлов в одной каталоговой структуре и использовать теги <context:component-scan> и <context:include-filter> для загрузки всех конфигурационных файлов в иерархию приложений.

2.  *  * Конфигурационные файлы по месту *  * : Вы можете хранить конфигурационные файлы в разных каталогах, соответствующих различным частям вашего приложения. Spring загрузит все файлы, находящиеся в каталоге, соответствующем месту, где выполняется приложение.

3.  *  * Конфигурационные файлы по профилю *  * : Spring позволяет вам определять разные конфигурации для разных профилей. Вы можете хранить разные конфигурационные файлы для каждого профиля и использовать тег <beans:profile> для указания, какой файл конфигурации использовать для каждого профиля.

Почему Spring позволяет использовать несколько конфигурационных файлов? Основная причина заключается в том, что это делает процесс управления конфигурацией более гибким и масштабируемым. Разделение конфигурации на несколько файлов позволяет лучше структурировать и организовать конфигурацию, что упрощает ее поддержку и изменение

[к оглавлению](#Spring-Core)

## 10. Расскажите, что такое Spring Bean.

Фреймворк Spring работает только с теми объектами, которые являются частью фреймворка. Поэтому объекты, которые предполагается  отдать под управление фреймворку, надо поместить в так называемый контекст. Контекст - это IoC-контейнер ( IoC - Inversion-of-Control - передача управления),  - это сущность, в которой происходит перехват Spring'ом управления над объектом. Соответственно **бином**  называется объект, переданный в контекст или самостоятельно созданный фреймворком из  соответствующего класса. 

[к оглавлению](#Spring-Core)

## 11. Когда необходимо объект делать бином?

Когда мы хотим передать управление и внедрение зависимостей через Spring (Context)

[к оглавлению](#Spring-Core)

## 12. Какие существуют способы создания бинов? Чем они друг от друга отличаются?

https://manremont.ru/sposoby-sozdaniya-binov-spring/

**#1. Через XML**

1. Создать файл конфигурации XML, который обычно имеет расширение .xml.
2. В файле конфигурации определить бин с помощью тега <bean>. В атрибуте id указывается уникальный идентификатор бина, а в атрибуте class указывается полное имя класса, который будет создаваться.
3. Если требуется использовать конструктор с параметрами, то необходимо указать типы и значения параметров внутри тега <constructor-arg>.
4. Опционально можно указать другие настройки для бина, такие как зависимости и их значения.

**#2 с помощью компонентного сканирования**

Spring Framework предоставляет мощный механизм для автоматического создания бинов с помощью компонентного сканирования. Вместо того чтобы явно объявлять каждый бин в файле конфигурации, можно использовать аннотацию @Component или ее производные для указания, что класс должен быть создан как бин.

Когда компоненты сканируются, Spring Framework автоматически создает экземпляры классов, помеченных аннотацией @Component. Это упрощает процесс конфигурации и уменьшает количество кода, который нужно написать.

Чтобы включить компонентное сканирование, нужно добавить следующую строку в файл конфигурации Spring:

<context:component-scan base-package="com.example.package" />

Здесь com.example.package — это базовый пакет, в котором нужно искать компоненты. Spring Framework сканирует этот пакет и его подпакеты в поисках классов, помеченных аннотацией @Component.

Для инъекции зависимостей в эти бины можно использовать аннотацию @Autowired.

Также в коде Config(@Configuration) 
@ComponentScan("название пакета")

**#3 Создание бинов с помощью Java Config**

Java Config — это альтернативный способ определения бинов в Spring Framework. Вместо использования XML-файлов конфигурации, при использовании Java Config, вы можете создавать бины с помощью Java-кода.

Для создания бина с помощью Java Config, необходимо создать класс, отмеченный аннотацией @Configuration. Эта аннотация говорит Spring Framework, что класс содержит конфигурацию бинов.

После того, как вы создали класс конфигурации, вы можете определить бины, используя методы, отмеченные аннотацией @Bean. Эти методы должны возвращать объекты, которые будут управляться как бины.

```java
@Configuration
public class AppConfig {
@Bean
public UserService userService() {
return new UserServiceImpl();
}
@Bean
public ItemService itemService() {
return new ItemServiceImpl();
}
}
```

В приведенном выше примере, мы определяем два бина — userService и itemService. Методы userService() и itemService() возвращают объекты типа UserService и ItemService соответственно.

Когда Spring Framework инициализирует контейнер, он будет автоматически создавать экземпляры бинов, определенные в классе конфигурации.

**#4 Применение фабричных методов для создания бинов**

Фабричные методы, или методы-фабрики, представляют удобный способ создания бинов в Spring Framework. Они позволяют создавать объекты, основываясь на заданных параметрах или условиях, и возвратить уже готовый экземпляр бина.

Используя фабричные методы, вы можете создавать бины с различными настройками или условиями, динамически адаптируя их поведение в зависимости от контекста выполнения. Такой подход особенно полезен в ситуациях, когда создание бина требует сложной инициализации или когда необходимо сгенерировать экземпляр на основе внешних данных.

Реализация фабричных методов в Spring очень проста. Для начала, вам необходимо определить класс-фабрику, который будет содержать методы для создания бинов. Этот класс должен быть помечен аннотацией @Configuration, чтобы Spring мог узнать о его существовании.

Далее, каждый фабричный метод должен быть помечен особой аннотацией @Bean и возвращать экземпляр нужного бина. Внутри метода можно выполнять необходимую инициализацию объекта и настройку его свойств.
```java
@Configuration
public class MyBeanFactory {
@Bean
public MyBean createMyBean() {
MyBean myBean = new MyBean();
// настройка свойств бина
myBean.setProperty1("Value1");
myBean.setProperty2(42);
return myBean;
}
@Bean
public AnotherBean createAnotherBean() {
AnotherBean anotherBean = new AnotherBean();
// настройка свойств бина
anotherBean.setSomeProperty("Value2");
return anotherBean;
}
}
```

В приведенном примере MyBeanFactory содержит два фабричных метода createMyBean() и createAnotherBean(), каждый из которых создает и возвращает экземпляр соответствующего бина.

Теперь эти бины можно использовать в других компонентах приложения, указывая их имена как зависимости. Spring сам автоматически выполнит создание и настройку объектов на основе фабричных методов.

Примечание: Вместо классов-фабрик можно использовать статические фабричные методы в классе бина. В таком случае, нужно пометить фабричный метод статическим и использовать аннотацию @Configuration на классе-конфигурации.

Использование фабричных методов для создания бинов в Spring позволяет гибко настраивать объекты и снижает сложность кода за счет явного разделения логики создания и настройки бинов.

[к оглавлению](#Spring-Core)

## 13. Опишите стратегию нейминга (присвоения имени бину) в Spring

Spring автоматически дает бинам наименования по такому принципу: 

 - если бин создан с помощью аннотации @Component, то имя бина будет именем класса с заменой первой буквы с прописной на строчную (например, имя бина из класса Cat будет "cat");
- если бин создан с помощью аннотации @Bean, то он получит в качестве имени наименование метода, в котором он создан (например, первый бин из класса Config получит имя "getAlfaDog").

[к оглавлению](#Spring-Core)

## 14. Каким образом можно самостоятельно присвоить имя бину?

@Bean(name = "ИмяБина")

@Component("ИмяБина")

[к оглавлению](#Spring-Core)

## 15. Опишите жизненный цикл Spring Bean. Каким образом можно изменять этот жизненный цикл?

https://job4j.ru/profile/exercise/202/task-view/1151

Жизненный цикл бина в Spring состоит из трех этапов - создание, использование и уничтожение. Фреймворк сам выполняет запуск каждого этапа.

![image](https://github.com/artemaverin/summary/assets/97846877/c91aca48-2bcc-400e-99ef-1c044e128b48)

Однако, у программиста есть возможность изменить этапы создания и уничтожения бина, применив так называемые "обратные вызовы". Обратными эти вызовы называют потому, что после создания бина из конструктора и внедрения зависимостей, Spring вынужден заново (то есть обратно) вернуться к процессу создания бина и внести в него изменения, указанные программистом в обратных вызовах. 
Рассмотрим схемы выполнения обратных вызовов.

- при создании бина обратные вызовы представлены в пунктах 2, 3, 4 и 5:

![image](https://github.com/artemaverin/summary/assets/97846877/1f4c5406-1a19-4c9e-b42f-446101ea4683)

- при уничтожении бина обратные вызовы представлены в пункте 6:

![image](https://github.com/artemaverin/summary/assets/97846877/d6fd319a-838b-4751-ad4b-979d84e3786d)

[к оглавлению](#Spring-Core)

## 16. Опишите предназначение каждого этапа жизненного цикла бина

**1 этап :**

                Загрузка описаний бинов, создание графа зависимостей(между бинами)

                Создание и запуск BeanFactoryPostProcessors

                Создание бинов

                Spring внедряет значения и зависимости в свойства бина

**2 этап :** 

                Если бин реализует интерфейс NameBeanAware, то Spring передает имя бина в метод setBeanName() в качестве аргумента.

                Если бин реализует интерфейс BeanFactoryAware, то Spring передает ссылку на bean factory через метод setBeanFactory().

                Если бин реализует интерфейс ApplicationContextAware, то Spring передает ссылку на ApplicationContext через метод                  setApplicationContext().

**3 и 5 этапы:** 

                BeanPostProcessor это специальный интерфейс, и Spring позволяет бинам имплементировать этот интерфейс. Реализуя метод postProcessBeforeInitialization(), можно изменить экземпляр бина перед его(бина) инициализацией (установка свойств и т.п.), а реализуя метод postProcessAfterInitialization() можно изменить экземпляр бина после его(бина) инициализации

**4 этап:**

        Указать Spring'у метод, который должен быть выполнен при инициализации бина, можно следующими способами - с помощью аннотации @PostConstruct; или реализовать интерфейс InitializingBean и переопределить метод afterPropertiesSet(), или указать метод в аннотации @Bean в свойстве initMethod. Если эти методы определены, то Spring вызывает их. 

После выполнения 5 этапа бин готов к использованию. Его можно получить с помощью метода ApplicationContext#getBean().

После того как контекст будет закрыт(метод close() из ApplicationContext), бин уничтожается.

**6 этап:** 

        Указать Spring'у метод, выполняемый перед уничтожением бина, можно такими способами: - с помощью аннотации @PreDestroy; или реализовать интерфейс DisposableBean и переопределить его метод destroy() , или указать метод в аннотации @Bean в свойстве destroyMethod. Если эти методы определены, то Spring вызывает их. 

[к оглавлению](#Spring-Core)

## 17. Какие аннотации являются стереотипными? Почему они имеют такое название? Какие особенности в поведение бина они привносят?

стереотипные аннотации — это те, которые находятся в пакете stereotype (org.springframework.beans.factory.stereotype.Service)

В Spring Framework есть несколько аннотаций, которые являются стереотипными. Вот некоторые из них:

1. @Autowired: Эта аннотация используется для автоматического связывания зависимостей. Она указывает, что данный компонент должен быть автоматически связан с другим компонентом. Название "Autowired" происходит от английского "auto-wiring", что означает автоматическую связку. Эта аннотация упрощает процесс конфигурации и позволяет избежать явного связывания зависимостей в коде.

2. @Service: Эта аннотация используется для обозначения классов, которые представляют сервисы в приложении. Она указывает, что данный класс является сервисом и должен быть управляем Spring Framework. Название "Service" происходит от английского "service", что означает службу или сервис. Эта аннотация помогает организовать код и упрощает процесс конфигурации.

3. @Repository: Эта аннотация используется для обозначения классов, которые представляют репозитории данных. Она указывает, что данный класс является репозиторием и должен быть управляем Spring Framework. Название "Repository" происходит от английского "repository", что означает хранилище или репозиторий. Эта аннотация помогает организовать код и упрощает процесс конфигурации.

4. @Controller: Эта аннотация используется для обозначения классов, которые представляют контроллеры в веб-приложении. Она указывает, что данный класс является контроллером и должен быть управляем Spring Framework. Название "Controller" происходит от английского "controller", что означает контроллер. Эта аннотация помогает организовать код и упрощает процесс конфигурации.

Все эти аннотации имеют название, которое отражает их основное назначение и поведение. Они помогают упростить процесс конфигурации и организации кода, а также обеспечивают стандартизацию и согласованность в приложении.

[к оглавлению](#Spring-Core)

## 18. Объясните для чего используются аннотации @Autowired, @Qualifier, @Primary, @Resource. Когда какую нужно использовать?

Аннотация **@Primary** используется для указания Spring'у, какой именно бин использовать при внедрении при наличии нескольких подходящих бинов-кандидатов.

```java
@Configuration
@ComponentScan(basePackages = "annotation")
public class Config {

    @Bean
    @Primary
    public Dog getAlfaDog() {
        return new Dog("AlfaDog");
    } 
```

Другой способ - Аннотация **@Qualifier**

Изменим класс Man - добавим еще одно поле типа Dog и укажем конкретное имя нужного бина с помощью аннотации @Qualifier("SecondDog"):

```java
@Component
public class Man {
    @Autowired
    private Dog dog;
    
    @Autowired
    @Qualifier("SecondDog")
    private Dog dog1;
    /* далее без изменений */

    public void print() {
        System.out.printf("My Dog: %s%n", dog.print());
        System.out.printf("My SecondDog: %s%n", dog1.print());
        /* далее без изменений */        
    }
```

Аннотация **@Resource**

В предыдущем примере мы использовали связку аннотаций   @Autowired + @Qualifier. Вместо них можно использовать аннотацию @Resource.

```java
@Component
public class Man {
    @Autowired
    private Dog dog;
    @Resource(name = "someDog")
    private Dog dog1; 
```

**@Autowired** используется для автоматического внедрения зависимостей в поля, методы, конструктор класса. Если несколько компонентов претендуют на одну и ту же зависимость, то Spring бросает исключение.

**@Qualifier** позволяет вам предоставить дополнительную информацию для автоматического внедрения, чтобы Spring знал, какую именно зависимость следует внедрить. Вы указываете имя квалификатора, которое затем используется при поиске соответствующего бина.

**@Primary** указывает, что данный бин является первичным (primary) для данной зависимости. Если существует несколько бинов с одной и той же зависимостью, то будет использоваться первичный бин.

**@Resource** аналогична @Autowired, но используется для внедрения различных ресурсов, таких как соединения JDBC, файловые дескрипторы и т. д. Также она может использоваться для внедрения ресурсов JNDI.

[к оглавлению](#Spring-Core)

## 19. Что такое AOP и для чего используется модуль Spring AOP

AOP -  это парадигма программирования, основанная на идее разделения основного и служебного функционала. 

При этом служебный функционал записывается в так называемые Aspect-классы.

AOP (Aspect-Oriented Programming) - это подход к программированию, который позволяет отделить логику, связанную с конкретными аспектами поведения системы, от основного кода приложения. AOP позволяет управлять этими аспектами независимо от основного кода, что упрощает разработку и поддержку сложных систем.

Модуль Spring AOP - это часть Spring Framework, который предоставляет поддержку AOP. Он позволяет разработчикам добавлять аспектно-ориентированные функции в свои приложения, написанные на Java.

Spring AOP использует механизм внедрения зависимостей (Dependency Injection) для связывания аспектов с целевыми объектами. Это позволяет разработчикам добавлять функциональность, такую как логирование, безопасность, транзакции и т.д., без необходимости изменять основной код приложения.

Spring AOP предоставляет следующие возможности:

1. Аспектно-ориентированное программирование: позволяет разработчикам отделить логику, связанную с конкретными аспектами поведения системы, от основного кода приложения.

2. Интеграция с другими фреймворками: Spring AOP может быть интегрирован с другими фреймворками, такими как AspectJ, для более мощной поддержки AOP.

3. Поддержка различных типов аспектов: Spring AOP поддерживает различные типы аспектов, такие как передовой аспект (before advice), после аспект (after advice), вокруг аспект (around advice) и т.д.

4. Поддержка различных типов точек: Spring AOP поддерживает различные типы точек, такие как методы, классы, интерфейсы и т.д.

5. Управление конфигурацией: Spring AOP предоставляет гибкие возможности для управления конфигурацией аспектов и целевых объектов.

В целом, модуль Spring AOP предоставляет мощные инструменты для управления аспектами поведения системы, что упрощает разработку и поддержку сложных приложений.

[к оглавлению](#Spring-Core)

## 20. Назовите основные аннотации, используемые в модуле AOP

Основные аннотации, используемые в модуле Spring AOP, включают:

1. **@Aspect**: Эта аннотация используется для обозначения класса, который содержит аспекты. Она указывает, что данный класс является аспектом и должен быть управляем Spring AOP.

2. **@Before**: Эта аннотация используется для обозначения передового аспекта. Она указывает, что данный метод должен быть выполнен перед вызовом целевого метода.

3. **@After**: Эта аннотация используется для обозначения после аспекта. Она указывает, что данный метод должен быть выполнен после вызова целевого метода.

4. **@AfterReturning**: Эта аннотация используется для обозначения после возвращающего аспекта. Она указывает, что данный метод должен быть выполнен после успешного возврата из целевого метода.

5. **@AfterThrowing**: Эта аннотация используется для обозначения после бросающего аспекта. Она указывает, что данный метод должен быть выполнен после того, как целевой метод вызовет исключение.

6. **@Around**: Эта аннотация используется для обозначения вокруг аспекта. Она указывает, что данный метод должен быть выполнен вокруг вызова целевого метода.

7. **@Pointcut**: Эта аннотация используется для определения точки (pointcut) в коде, где должен быть применен аспект. Она указывает, что данный метод или класс является точкой, где должен быть применен аспект.

8. **@DeclareParents**: Эта аннотация используется для добавления новых интерфейсов к существующим классам. Она указывает, что данный класс должен быть дополнен новым интерфейсом.

Эти аннотации позволяют разработчикам добавлять аспектно-ориентированные функции в свои приложения, написанные на Java, с помощью Spring AOP.

[к оглавлению](#Spring-Core)

## 21. Как подключить AOP к проекту?

1. Добавить зависимость в pom.xml

```java
<dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>6.0.10</version>
        </dependency>
```

2. В классе Config.java добавим аннотацию @EnableAspectJAutoProxy
```java
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackages = "ru.job4j.aop")
@EnableAspectJAutoProxy
public class Config {
}
```

3. добавить класс BeforeAndAfterLoggingAspect.java

```java
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import java.util.Arrays;

@Aspect
@Component
public class BeforeAndAfterLoggingAspect {
    private static final Logger LOG = LoggerFactory.getLogger(BeforeAndAfterLoggingAspect.class.getName());

    @Before("execution(* ru.job4j.aop.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        Signature signature = joinPoint.getSignature();
        Object[] argsObj = joinPoint.getArgs();
        String args = Arrays.toString(argsObj);
        String methodName = signature.toShortString();
        LOG.info("Вызван метод:  {}", methodName );
        LOG.info("аргументы: {}", args);
    }

    @AfterReturning(pointcut = "execution(int ru.job4j.aop.service.*.*(..))", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, int result) {
        Signature signature = joinPoint.getSignature();
        String methodName = signature.toShortString();
        LOG.info("Метод завершил работу: {}", methodName);
        LOG.info("с результатом: {}", result);
    }
}
```
Мы выделили служебную логику (логирование в данном примере) в отдельные объекты - аспекты, связали эти аспекты  с методами бизнес-логики и указали фреймворку, когда именно применить аспекты.

[к оглавлению](#Spring-Core)

## 22. Что означает термин "Аспект" в парадигме AOP?

Aspect - это собственно код, в котором заключена служебная логика.

![image](https://github.com/artemaverin/summary/assets/97846877/4ae67d6e-bd61-47b1-adf4-ceb6b0f2ca8a)

[к оглавлению](#Spring-Core)

## 23. Что означает термин "advice" (совет)  в парадигме AOP?

advice - этой аннотацией мы указываем Spring'у, когда именно выполнять аспект - перед, или после, или вместо выполнения целевого метода. Еще это понятие имеет название "совет".

Термин "advice" (совет) в парадигме AOP означает часть кода, которая будет выполнена в определенный момент времени в контексте целевого метода. Advice может быть выполнен до, после, вокруг или вместо вызова целевого метода.

Вот некоторые примеры советов:

1. Передовой совет (before advice): выполняется перед вызовом целевого метода.

2. После совет (after advice): выполняется после вызова целевого метода.

3. После возвращающий совет (after returning advice): выполняется после успешного возврата из целевого метода.

4. После бросающий совет (after throwing advice): выполняется после того, как целевой метод вызовет исключение.

5. Вокруг совет (around advice): выполняется вокруг вызова целевого метода.

Советы позволяют разработчикам добавлять функциональность, такую как логирование, безопасность, транзакции и т.д., без необходимости изменять основной код приложения. Они позволяют управлять аспектами поведения системы независимо от основного кода, что упрощает разработку и поддержку сложных систем.

[к оглавлению](#Spring-Core)

## 24. Какие бывают виды advice? В чем их отличие друг от друга?

ипы Advice.

@Before - выполняется перед исполнением целевого метода.

@AfterReturning - выполняется  только после нормального (без выбрасывания исключения) завершения работы целевого метода, но до присвоения результата работы метода какой-либо переменной. Поэтому с помощью @AfterReturning мы можем изменять содержание  возвращаемого результата работы метода.

@AfterTrowing  - выполняется только если целевой метод завершился выбросом исключения. При этом мы можем получить доступ к параметрам исключения, но не можем его обработать или как-то повлиять на дальнейшее выполнение программы.

@After - выполняется после завершения работы целевого метода, при этом не важно, было ли выброшено исключение или метод завершился в нормальном режиме. В этом совете мы не можем получить доступ к результату работы метода и не можем получить доступ к исключению, если оно было выброшено целевым методом.

@Around  - выполняется вместо целевого метода. При этом внутри этого аспекта мы имеем доступ к аргументам, с которыми вызывается целевой метод (а, следовательно, мы можем их изменить), мы можем самостоятельно вызвать целевой метод (а, следовательно, можем и не вызывать целевой метод), и мы имеем доступ к возвращаемому результату работы целевого метода (и можем его изменить). Также мы можем выполнить нужные нам действия перед и/или после целевого метода. Если целевой метод выбросит исключение, мы можем его пробросить дальше или обработать в блоке catch. 

[к оглавлению](#Spring-Core)

## 25. Что такое PointCut?

join point - это событие, запускающее выполнение аспекта. В Spring этим событием всегда является вызов целевого метода.
pointCut - это наименования методов, выполнение которых Spring должен перехватить и запустить выполнение аспектов. Еще имеет название как "срез".

![image](https://github.com/artemaverin/summary/assets/97846877/ac1dead4-2fc6-4cf8-a273-e48ad7d51a74)

**PointCut**
В этом параметре указываются методы, для которых будет активирован аспект. 
На рисунке показана расшифровка среза из примера:

![image](https://github.com/artemaverin/summary/assets/97846877/3d012351-df47-4963-81f0-eb5e04f2cc6a)

Вместо звездочек можно указать конкретные значения. Например, для приведенного примера pointCut можно записать в таком виде:
```java
int ru.job4j.aop.service.ProcessComment.deleteComment(int)
```
Обратите внимание, что в аргументах метода указываются только типы передаваемых значений.

[к оглавлению](#Spring-Core)

## 26. Опишите, каким образом происходит работа Srping при использовании модуля AOP

Мы выделили служебную логику (логирование в данном примере) в отдельные объекты - аспекты, связали эти аспекты  с методами бизнес-логики и указали фреймворку, когда именно применить аспекты.

Spring, используя эту информацию, выполняет следующие действия.

Как только фреймворк обнаруживает вызов целевого метода **publishingComment()**,  он осуществляет перехват управления, выполняет логику аспекта logBefore() , затем возвращает управление методу main() - происходит выполнение целевого метода.

То же самое происходит и при обнаружении вызова целевого метода **deleteComment()** - перед ним выполняется аспект **logBefore()**, но, в момент окончания работы целевого метода, происходит опять перехват управления и выполняется аспект **logAfterReturning()**, и только после выполнения кода аспекта происходит возврат управления методу main(), который только теперь получает результаты работы целевого метода.

Подробнее разберем шаги, как мы это осуществили.
1. Добавили зависимость spring-aspects в pom.xml и аннотацию **@EnableAspectJAutoProxy** в конфигурационный класс Config.java, тем самым подключили и активировали механизм аспектов.
2. Создали новый класс и объявили перед ним аннотацию **@Aspect**. Затем внедрили этот класс в контекст фреймворка, используя стереотипную аннотацию @Component.
3. Определили конкретные методы, в которых будет реализована логика аспектов, и с помощью аннотаций @Before (а также **@AfterReturning**) сообщили фреймворку Srping, когда и какие целевые методы (то есть методы с бизнес-логикой) следует перехватить.
4. Реализовали саму логику аспектов.

[к оглавлению](#Spring-Core)

## Spring Core

[1. Что такое Spring? Какие основные задачи выполняет этот фреймворк?](#1-Что-такое-Spring-Какие-основные-задачи-выполняет-этот-фреймворк)

[2. Что такое IoC и DI? В чем отличие этих терминов?](#2-Что-такое-IoC-и-DI-В-чем-отличие-этих-терминов)

[3. Перечислите основные модули Spring фреймворка.](#3-Перечислите-основные-модули-Spring-фреймворка)

[4. Что такое фабрика бинов  BeanFactory?](#4-Что-такое-фабрика-бинов-BeanFactory)

[5. Перечислите способы внедрения зависимостей и объясните их отличия друг от друга.](#5-Перечислите-способы-внедрения-зависимостей-и-объясните-их-отличия-друг-от-друга)

[6. Что такое ApplicationContext? Когда он создается?](#6-Что-такое-ApplicationContext-Когда-он-создается)

[7. С какой целью выполняется конфигурирование контекста, какими способами это конфигурирование может производиться и какие отличия есть между ними.](#7-С-какой-целью-выполняется-конфигурирование-контекста-какими-способами-это-конфигурирование-может-производиться-и-какие-отличия-есть-между-ними)

[8. Где и для чего применяются аннотации @Configuration, @ComponentScan, @PropertySource. Что в них должно быть указано?](#8-Где-и-для-чего-применяются-аннотации-Configuration-ComponentScan-PropertySource-Что-в-них-должно-быть-указано)

[9. Можно ли использовать несколько конфигурационных файлов? Если да, то как это сделать? Если нет, то почему?](#9-Можно-ли-использовать-несколько-конфигурационных-файлов-Если-да-то-как-это-сделать-Если-нет-то-почему)

[10. Расскажите, что такое Spring Bean.](#10-Расскажите-что-такое-Spring-Bean)

[11. Когда необходимо объект делать бином?](#11-Когда-необходимо-объект-делать-бином)

## 1. Что такое Spring? Какие основные задачи выполняет этот фреймворк?

Фреймворк Spring (или просто Spring) — это прикладной фреймворк, который является частью экосистемы Java. В настоящее время Spring используется для написания самых разных программ, от крупных серверных решений до средств автоматизации тестирования.

Прикладной фреймворк — это пакет типичных функций программного обеспечения, образующих базовую структуру для разработки приложения. Он позволяет тратить меньше усилий при написании приложения, так как не приходится создавать весь код программы с нуля.  Прикладной фреймворк  предоставляет широкий набор инструментов и функций, которые можно применять в разработке. Вы не обязаны использовать их все. В зависимости от требований, предъявляемых к разрабатываемому приложению, вы будете выбирать ту часть фреймворка, которая вам нужна.

Концепция фреймворка не нова. На протяжении всей истории разработки ПО программисты замечали, что многие фрагменты написанного ими кода можно использовать повторно в других приложениях. Поначалу, когда приложений было мало, каждое из них было уникально и писалось с нуля на том или ином языке программирования. По мере того, как область применения программного обеспечения расширялась и на рынке появлялось все больше продуктов, стало еще заметнее, как много приложений имеют сходные требования. Вот некоторые из них:

- в каждом приложении предусмотрены уведомления при ошибках входа, предупреждения и информационные сообщения;

- в большинстве приложений для обработки изменений данных используются транзакции. Транзакции являются важным механизмом, который обеспечивает целостность данных;

- в большинстве приложений применяются механизмы защиты от одних и тех же распространенных уязвимостей;

- в большинстве приложений используются одни и те же механизмы обмена данными с другими приложениями;

- в большинстве приложений есть одни и те же механизмы повышения производительности, такие как кеширование и сжатие данных;

В сущности, код бизнес-логики, реализованной в приложении, значительно меньше, чем вся эта внутренняя начинка.

Функционал, не относящийся к бизнес-логике, может многократно внедряться в разные приложения. Имеет ли смысл каждый раз заново его переписывать? Разумеется, нет. Эту задачу берет на себя фреймворк.

[к оглавлению](#Spring-Core)

## 2. Что такое IoC и DI? В чем отличие этих терминов?

**Инверсия управления (Inversion of Control).**

Spring Core — это та часть фреймворка Spring, которая обеспечивает фундаментальные механизмы его интеграции в приложение. Spring работает по принципу инверсии управления (inversion of control, IoC): вместо того чтобы приложение само контролировало свое выполнение, управление передается некоторому другому программному обеспечению — в данном случае фреймворку Spring. 

Посредством системы настроек мы предоставляем фреймворку Spring инструкции о том, как распоряжаться написанным нами кодом, что и определяет логику работы приложения. Именно это и подразумевается под «инверсией» в аббревиатуре IoC: мы не позволяем приложению управлять собственным выполнением посредством его же кода или использовать зависимости. Вместо этого мы передаем фреймворку (зависимости) управление приложением и его кодом. В этом контексте «управление» означает такие действия, как «создание экземпляра» или «вызов  метода». 

**Внедрение зависимости (Dependency Injection)**

Внедрение зависимости — это инициализация полей объекта другими объектами.

Помимо создания объектов, Spring-контейнер внедряет эти объекты в другие объекты, то есть делает их полями других объектов. Детали внедрения для нас как разработчиков не важны, главное знать, как объяснить фреймворку, какие объекты вы хотите отдать под его управление, и в какие поля других объектов вы хотите их внедрить. Шаблон Dependency Injection не привязан к Spring, это всего лишь инициализация поля класса. Этот шаблон часто встречается в коде (внедрение через конструктор либо сеттер) любых приложений, не обязательно Spring. В связи со Spring это название используется часто потому, что внедрение выполняет Spring, а программист должен указывать Spring'у конфигурацию внедрения этих зависимостей. 

[к оглавлению](#Spring-Core)

## 3. Перечислите основные модули Spring фреймворка.

Spring — это целая экосистема фреймворков. Как правило, когда разработчики упоминают фреймворк Spring, они имеют в виду часть программного функционала, которая включает в себя следующее:

1.  Spring Core — фундаментальная часть Spring, в которой реализован его базовый функционал. Одной из этих функций является контекст Spring - это фундаментальная функциональная возможность, благодаря которой Spring может управлять экземплярами приложения. Также частью функционала Spring  являются аспекты Spring. С ними Spring может перехватывать определенные в приложении методы и манипулировать ими . Еще один компонент - это Spring Expression Language (SpEL). Он позволяет описывать конфигурации Spring с помощью специального языка. 

2. Spring MVC (model-view-controller, «модель — представление — контроллер»). Эта часть фреймворка Spring позволяет создавать веб-приложения, обрабатывающие HTTP-запросы. 

3. Spring Data Access — еще одна базовая часть Spring. Она предоставляет основные инструменты для соединения с базами данных SQL, что позволяет реализовать уровень доступа к данным в приложении. 

4 Spring Testing. Эта часть фреймворка включает в себя инструменты, позволяющие писать тесты для Spring-приложения. 

Экосистема Spring — это гораздо больше, чем просто функции, описанные выше. Она включает в себя множество других фреймворков, хорошо интегрированных между собой, как Spring Data, Spring Security, Spring Cloud, Spring Batch, Spring Boot и т.д. Полный список  проектов на официальном сайте Spring - https://spring.io/projects/

- ---------------------------

https://tproger.ru/articles/spring-modules-overview

Spring — это фреймворк для разработки приложений на языке Java. Он состоит из нескольких модулей, которые можно использовать в зависимости от потребностей проекта. Ниже перечислены основные модули Spring:

1. Spring Core — модуль, который содержит основные классы и интерфейсы фреймворка, такие как SpringApplication, BeanFactory и ApplicationContext.

2. Spring AOP — модуль, который позволяет добавлять функциональность Aspect-Oriented Programming (AOP) в приложение Spring.

3. Spring MVC — модуль, который предоставляет компоненты для создания веб-приложений на основе фреймворка Spring.

4. Spring Data — модуль, который предоставляет различные модули для работы с базами данных, такие как Spring JDBC, Spring Hibernate и Spring Data JPA.

5. Spring Security — модуль, который обеспечивает безопасность приложения, позволяя контролировать доступ к ресурсам и защищать их от несанкционированного доступа.

[к оглавлению](#Spring-Core)

## 4. Что такое фабрика бинов  BeanFactory?

Базовый интерфейс к Spring DI является интерфейс BeanFactory.

BeanFactory содержит методы получения бинов из контекста. 

Интерфейс BeanFactory имеет множество реализаций. В это примере мы рассмотрим самый примитивный - DefaultListableBeanFactory:

```java
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import ru.job4j.di.model.StartUI;
import ru.job4j.di.model.Store;

public class BeanFactoryDI {
    public static void main(String[] args) {
        DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory();
        BeanDefinition storeDefinition = BeanDefinitionBuilder.rootBeanDefinition(Store.class).getBeanDefinition();
        BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(StartUI.class).getBeanDefinition();
        defaultListableBeanFactory.registerBeanDefinition("store", storeDefinition);
        defaultListableBeanFactory.registerBeanDefinition("ui", beanDefinition);
        StartUI ui = defaultListableBeanFactory.createBean(StartUI.class);
        ui.add("Petr Arsentev");
        ui.add("Ivan ivanov");
        ui.print();
    }
}
```

BeanDefinition - описывает bean-компоненты. Создается на основе разобранной мета-информации.

BeanFactory - это интерфейс который создает и предоставляет bean-компоненты на основе BeanDefinition-ов. Он является ядром ApplicationContext.

- --------------------------

Фабрика бинов (BeanFactory) — это основной компонент фреймворка Spring, который отвечает за управление бинами (Bean) в приложении. Фабрика бинов создает, уничтожает и управляет бинами в приложении. Она также отвечает за настройку бинов и предоставление их клиентам.

BeanFactory — это интерфейс, который определяет основные методы для работы с бинами. Он может быть реализован различными способами, например, как Singleton или как прототип. Фабрика бинов обычно создается в начале работы приложения и существует на протяжении всего его жизненного цикла.

BeanFactory используется для определения и регистрации бинов в приложении. При регистрации бина в Factory, он становится доступным для клиентов, которые могут его использовать для получения экземпляров бинов.

BeanFactory также может использоваться для настройки бинов с помощью конфигурационных свойств. Это позволяет определить различные параметры и свойства бина, такие как его класс, зависимости, методы и т.д.

В общем, Фабрика бинов является центральным элементом фреймворка Spring, который обеспечивает управление и доступ к бинам в приложении.

[к оглавлению](#Spring-Core)

## 5. Перечислите способы внедрения зависимостей и объясните их отличия друг от друга.

Преимущества и недостатки различных способов внедрения бинов.

1.Внедрение в поле - преимущество в отсутствии дополнительного кода, недостаток в том, что поле нельзя объявить final, соответственно объект нельзя выполнить неизменяемым. Плюс сложности при тестировании класса - для внедрения зависимости надо поднимать контекст.

```java
@Autowired
private Dog dog;
```

2.Внедрение с помощью метода -  главный недостаток в том, что нельзя создать неизменяемый объект.

```java
@Autowired
public void setBird(Bird bird) {
    this.bird = bird;
}
```

3.Внедрение с помощью конструктора - наиболее рекомендуемый способ внедрения. Можно создавать неизменяемые объекты, простой процесс тестирования.

```java
@Autowired
public Man(Cat cat) {
    this.cat = cat;
}
```

[к оглавлению](#Spring-Core)

## 6. Что такое ApplicationContext? Когда он создается?

ApplicationContext — это контекст, который используется в Spring Framework для управления приложением. Он содержит все необходимые бины (объекты, которые могут быть использованы в приложении), которые были загружены и инициализированы во время процесса инициализации приложения.

ApplicationContext создается в начале работы приложения, когда Spring Framework запускает процесс инициализации. В этот момент все бины, которые были определены в конфигурационном файле Spring, загружаются и инициализируются, а затем помещаются в ApplicationContext. После этого ApplicationContext может быть использован для получения доступных бинов, которые могут быть использованы в приложении.

BeanFactory содержит только методы получения бинов. У BeanFactory есть расширенный интерфейс ApplicationContext. 

Отличия BeanFactory и ApplicationContext.
Интерфейс BeanFactory — это самая базовая версия контейнеров IoC, а интерфейс ApplicationContext - это один из потомков, который расширяет возможности BeanFactory .
BeanFactory загружает компоненты по запросу, а ApplicationContext загружает все компоненты при запуске . Таким образом, BeanFactory легче по сравнению с ApplicationContext .
ApplicationContext обладает гораздо более широким функционалом, чем BeanFactory.

[к оглавлению](#Spring-Core)

## 7. С какой целью выполняется конфигурирование контекста, какими способами это конфигурирование может производиться и какие отличия есть между ними.

https://job4j.ru/profile/exercise/202/task/1155/471495

Для создания контекста Spring'у  требуются классы объектов и метаинформация об этих классах. Метаинформацию мы предоставляем в специальном конфигурационном файле. 

При создании метаинформации о бинах надо разрешить два вопроса.  Первый - какую именно информацию о бине надо передавать? Второй -  каким способом передать эту информацию?

Давайте последовательно ответим на эти вопросы.

**Первый вопрос. Какая информация о бине требуется фреймворку.**

После создания бина в контексте вся ранее предоставленная информация о нем содержится в виде объектов класса BeanDefinition. Соответственно, эту информацию  и надо передать в конфигурационном файле:

- имя класса с указанием пакета: обычно это фактический класс реализации определяемого компонента.

 - элементы конфигурации поведения компонента, которые указывают, как компонент должен вести себя в контейнере (область действия, обратные вызовы жизненного цикла и т. д.).

- ссылки на другие bean-компоненты, необходимые для работы bean-компонента. Эти ссылки также называются соавторами или зависимостями.

- другие параметры конфигурации, которые необходимо установить во вновь созданном объекте — например, предельный размер пула или количество подключений для использования в bean-компоненте, который управляет пулом подключений.

Эти метаданные транслируются в набор свойств, составляющих каждое определение компонента. 

**Class.**  Это единственное обязательное свойство, которое мы должны указать при создании бина.  Здесь мы указываем адрес класса, в котором происходит создание бина. Если создание бина производится с помощью конструктора (оператором new...), то достаточно указать только адрес класса. Если создание бина происходит с помощью статичесвкого фаричного метода, то указываем класс и имя фабричного метода. Если бин создается с помощью соответствующего метода фабрики экземпляров, то сначала регистрируем бин фабрики, а затем используем бин фабрики и имя метода.

**Name.** Это необязательное свойство. Контейнер сам присвоит уникальное имя бину в соответствии со своей стратегией наименования. Однако, если нам надо обращаться к этому бину по имени, то мы должны указать имя. Каждому бину мы можем указать его ID, имя name и псевдонимы alias. 

**Scope.** Область применения бина. Это необязательное свойство. Если его не указать явно, контейнер создаст этот бин как singleton. Мы можем изменить его, указав свойство как prototype. Отличие между ними в следующем: если бин объявлен как singleton, то он создается в контексте в одном экземпляре, и на все запросы контекст вернет единственный экземпляр бина. Если же  бин объявлен как  prototype, то на каждый запрос будет создан новый экземпляр и контекст будет возвращать каждый раз новый экземпляр этого бина. Кроме singleton и  prototype, есть еще такие области, как request, session, application и webSocket. Они используются в веб-ориентированном приложении и ограничиваются соответственно запросом, сессией, длительностью работы приложения и сокета.

**Constructor arguments  и Properties .** Эти свойства описывают порядок внедрения зависимостей - других бинов.

**Autowiring mode.** Устанавливает для бина режим автоматического связывания (внедрения) других бинов. Это необязательное свойство. По умолчанию этот режим отключен (установлен в no). В этом режиме нам надо самостоятельно определять бины, которые надо использовать для внедрения. Режим byname. Автосвязывание производится по имени свойства. Spring ищет bean-компонент с тем же именем, что и свойство, которое необходимо автоматически связать. Например, если определение компонента настроено на автосвязывание по имени и оно содержит свойство master (то есть у него есть метод setMaster(..)), Spring ищет определение компонента с именем master и использует его для установки свойства. 

**Lazy initialization mode.** Режим ленивой загрузки. Это необязательное свойство, по умолчанию Spring устанавливает это свойство в режим false. Это означает, что бин будет создан в контексте сразу при поднятии контекста. Если указать lazy = true, то бин будет создан только тогда, когда он реально потребуется. 

**Initialization method, Destruction method.** Эти свойства необязательные. Если нами определены эти методы обратного вызова, то указываются имена этих методов.

**Второй вопрос. Каким способом передать информацию фреймворку.**

Есть три варианта. 

**XML-based configuration.** В этом случае конфигурация описывается в xml-файле, код java-классов получается отделен от фреймворка - в них нет ни аннотаций, ни иных указаний на Spring. Этот вариант конфигурирования применялся с самого начала возникновения Spring и сейчас считается устаревшим.

**Annotation-based configuration.** В этом случае конфигурация описывается в xml-файле, но часть бинов может быть описана стереотипными аннотациями в java-коде, и в xml-файле указываются пакеты, в которых эти классы находятся.

**Java-based configuration.** Это современный подход, в котором отсутствует конфигурационный xml-файл, а вся конфигурация контекста описывается аннотациями в java-коде классов. 

[к оглавлению](#Spring-Core)

## 8. Где и для чего применяются аннотации @Configuration, @ComponentScan, @PropertySource. Что в них должно быть указано?

Аннотация @Configuration указывает на то, что в этом классе содержится конфигурационная информация.

Аннотация @ComponentScan(basePackages = "annotation")  указывает Spring'у пакет, в котором находятся классы компонентов.

Аннотация @Configuration сообщает фреймворку, что этот класс содержит конфигурационную информацию, аннотация @ComponentScan дает информацию о пакете, который фреймворк должен просканировать при поиске компонентов, аннотация @PropertySource сообщает, что программе требуется информация из файла свойств application.properties.
- -------------------------------

Аннотации `@Configuration`, `@ComponentScan` и `@PropertySource` используются в Spring Framework для облегчения процесса конфигурации и управления компонентами приложения.

1. `@Configuration`: Эта аннотация указывает Spring, что класс является конфигурационным. Spring будет использовать этот класс для настройки приложения. В классе, помеченном этой аннотацией, вы можете определить различные аспекты конфигурации, такие как управление бинами, определение методов управления и т.д.

2. `@ComponentScan`: Эта аннотация позволяет Spring сканировать пакет или класс на наличие компонентов, которые нужно автоматически зарегистрировать в среде выполнения. Это упрощает процесс управления бинами, так как вам не нужно явно регистрировать каждый компонент в файле конфигурации.

3. `@PropertySource`: Эта аннотация позволяет вам указать Spring, откуда он должен загружать свойства. Вы можете использовать это для загрузки свойств из файлов конфигурации, базы данных или других источников. В классе, помеченном этой аннотацией, вы должны определить методы getProperty(), которые будут возвращать свойства.

В каждой из этих аннотаций должно быть указано соответствующее значение, которое определяет, как именно Spring должен обрабатывать конфигурацию или сканирование компонентов. Например, в `@Configuration` вы можете определить методы, которые будут возвращать бины, которые нужно использовать в приложении. В `@ComponentScan` вы можете указать пакет или класс, который нужно сканировать, а в `@PropertySource` вы можете указать источник свойств, который нужно использовать.

[к оглавлению](#Spring-Core)

## 9. Можно ли использовать несколько конфигурационных файлов? Если да, то как это сделать? Если нет, то почему?

web.xml

Да, для чего используется contextConfigLocation. С его помощью вы сможете задать несколько файлов конфигурации, указывая параметры через пробел либо запятую:

![image](https://github.com/artemaverin/summary/assets/97846877/2e2d7f13-8ccb-4ce6-b3d2-26e5e603b7ce)

Важно отметить, что есть возможность указать нескольких корневых файлов конфигурации:

![image](https://github.com/artemaverin/summary/assets/97846877/e71b50ed-f98a-48c9-953c-3455e53667cc)

- -----------------------

можно использовать SpringApplicationBuilder для того, чтоб создать несколько контекстов объедененых в иерархию:

```java
new SpringApplicationBuilder(ParentConfig.class)
   .child(ChildConfig.class)
   .run(args);
```
Или вообще два независимых контекста (и значит два независимых spring boot приложения в одном java процессе):

```java
SpringApplicationBuilder applicationBuilder = new SpringApplicationBuilder()
    .sources(ParentConfig.class);
applicationBuilder.child(Application1Config.class).run(args);
applicationBuilder.child(Application2Config.class).run(args);
```
- ----------------------------

Да, в Spring можно использовать несколько конфигурационных файлов. Это может быть полезно в больших приложениях, где один файл конфигурации может стать слишком объемным и сложным для управления.

Spring предоставляет несколько способов разделения конфигурации на несколько файлов:

1.  *  * Вложенные конфигурационные файлы *  * : Вы можете хранить несколько конфигурационных файлов в одной каталоговой структуре и использовать теги <context:component-scan> и <context:include-filter> для загрузки всех конфигурационных файлов в иерархию приложений.

2.  *  * Конфигурационные файлы по месту *  * : Вы можете хранить конфигурационные файлы в разных каталогах, соответствующих различным частям вашего приложения. Spring загрузит все файлы, находящиеся в каталоге, соответствующем месту, где выполняется приложение.

3.  *  * Конфигурационные файлы по профилю *  * : Spring позволяет вам определять разные конфигурации для разных профилей. Вы можете хранить разные конфигурационные файлы для каждого профиля и использовать тег <beans:profile> для указания, какой файл конфигурации использовать для каждого профиля.

Почему Spring позволяет использовать несколько конфигурационных файлов? Основная причина заключается в том, что это делает процесс управления конфигурацией более гибким и масштабируемым. Разделение конфигурации на несколько файлов позволяет лучше структурировать и организовать конфигурацию, что упрощает ее поддержку и изменение

[к оглавлению](#Spring-Core)

## 10. Расскажите, что такое Spring Bean.

Фреймворк Spring работает только с теми объектами, которые являются частью фреймворка. Поэтому объекты, которые предполагается  отдать под управление фреймворку, надо поместить в так называемый контекст. Контекст - это IoC-контейнер ( IoC - Inversion-of-Control - передача управления),  - это сущность, в которой происходит перехват Spring'ом управления над объектом. Соответственно **бином**  называется объект, переданный в контекст или самостоятельно созданный фреймворком из  соответствующего класса. 

[к оглавлению](#Spring-Core)

## 11. Когда необходимо объект делать бином?

Когда мы хотим передать управление и внедрение зависимостей через Spring (Context)

[к оглавлению](#Spring-Core)

## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).](#6-Опишите-как-вставить-удалить-обновить-данные-в(из)-таблицу(ы))

## 1. Что такое SQL?
SQL - это декларативный язык программирования, который используется для создания, модификации и управления данными в реляционной БД, управляемой системой управления базами данных (СУБД). С помощью SQL-запросов можно добавлять, изменять, получать или удалять данные из БД.

## 2. Что такое DML и DDL?
![image](https://github.com/artemaverin/summary/assets/97846877/3bd0357e-64ec-4edf-98fb-be075f6e041c)

Операции бывают двух видов: над структурой данных и над самими данными. К первым относятся операции, касающиеся создания, удаления, изменения и т.д. таблиц и баз данных. Ко вторым относятся создание, удаление, получение, обновление самих данных. В профильной литературе можно встретить понятия DDL и DML. 

DDL – Data Definition Language, характеризует операции над структурой данных.

DML – Data Manipulation Language, представляет операции над самими данными.

## 3. Что такое первичный ключ?
первичный ключ (primary key) - это поле в таблице, однозначно идентифицирующее каждую строку (запись) в таблице БД. Первичный ключ должен содержать уникальные значения. Также не может содержать null. В таблице может быть только один первичный ключ. Ключ может состоять из одного и более полей. Первичный ключ, состоящий из нескольких полей, называется составным ключом.

Первичный ключ выбирается так, чтобы он состоял из минимально возможного количества полей. Например, если есть поля "имя", "фамилия", "дата рождения" и "номер телефона", нет смысла делать составной ключ из нескольких полей, так как имеется поле "номер телефона", и по нему одному мы можем в будущем уникально идентифицировать записи, так как номер телефона не может повторяться.

Так как в реляционных БД все таблицы почти всегда связаны друг с другом, первичные ключи используются для однозначной организации этой связи.

## 4. Что такое внешний ключ?

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

## 5. Какие виды связей между таблицами существуют и как они организуются?

**many-to-one и one-to-many**

Пример:

Должность и Сотрудник. Одну должность могут иметь несколько сотрудников, причем сотрудник может иметь одну должность. 

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Особое внимание стоит уделить столбцу position_id. Для связи таблиц между собой используется ключевое слово REFERENCES. Это значит, что значения данного столбца - значения связываемой таблицы. В данном случае это можно трактовать как столбец position_id содержит значения из таблицы positions, а именно из столбца id. Общий синтаксис связи при создании таблицы выглядит следующим образом:

имя_столбца тип REFERENCES связываемая_таб(столбец_св_табл)

Слово REFERENCES с английского переводится как "ссылается". Что это значит? При выполнении запроса извлечения всех работников видим, что в таблице position_id стоит какое-то значение. Мы можем перейти к соответствующей таблице, на которую ссылаемся, и найти запись по этому столбцу. Таким образом, мы как бы «переходим» по ссылке. Через SQL это записано последним запросом.

![image](https://github.com/artemaverin/summary/assets/97846877/d09061fa-36aa-488a-97c3-974422840f98)

Обратите внимание, что стрелка идет от сущности, которая many, к сущности, которая one. Либо же можно рассуждать так: где у нас стоит REFERENCES связь начинается, а стрелка будет указывать на сущность, на которую мы ссылаемся.

**many-to-many**

Пример:

Человек и Курс. Человек может проходить много курсов (one-to-many), в то же время курс могут проходить много человек (many-to-one).

Данная связь организуется с помощью вспомогательной таблицы, т.к. на уровне БД мы имеем только связь many-to-one.

![image](https://github.com/artemaverin/summary/assets/97846877/100ab40a-1180-4e3b-b169-5b4f4d5934dd)

Как видно по коду, здесь идет двойное применение REFERENCES, т.е. у нас есть два внешних ключа во вспомогательной таблице. Один ссылается на таблицу курсов, другой на таблицу людей.

**one-to-one**

Пример:

Очевидно, что паспорт и человек, это связь один к одному. У каждого человека есть только один паспорт. У паспорта может быть только один владелец.

Организуется эта связь немного сложнее, чем первые две. В первую очередь тут стоит задать вопрос: какую связь мы хотим? Однонаправленную (unidirectional) или двунаправленную (bidirectional)? Т.е. как мы хотим извлекать данные? В контексте примера: мы хотим по паспорту получать человека или наоборот? Или и так и так?

Если нам нужно получать паспорт по человеку, то мы можем поступить так

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255),
    passport_id int references passport(id) unique
);
```

Обратите внимание, что рядом с внешним ключом стоит unique. Это значит, что данное значение уникально среди всех записей данного столбца. Без этого ограничения(constraint) мы получим связь many-to-one. Теперь по записи в таблице людей мы можем перейти в таблицу паспорта для уточнения данных. Аналогично мы могли бы поступить в случае, если бы нам нужно было получать человека по паспорту. Такая организация связи является однонаправленной. Обратите внимание, что на связи указано 1, это значит, что связь один-к-одному, мы не можем писать unique, т.к. это относится к спецификации БД.

![image](https://github.com/artemaverin/summary/assets/97846877/674e1b19-41d1-450c-b41a-f05b1a5914c8)

Если нам нужно получать данные и так, и так (человека по паспорту и паспорт по человеку), то мы можем сделать так:

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255)
);

create table passport_people(
    id serial primary key,
    passport_id int references passport(id) unique,
    people_id int references people(id) unique
);
```

Данный способ использует, как и many-to-many, вспомогательную таблицу, но опять же используется ограничения на внешние ключи unique. Иначе мы получим связь many-to-many - как на рисунке ниже - обратите внимание, над связями нет символов "1".  

![image](https://github.com/artemaverin/summary/assets/97846877/951b8949-1f44-4ee7-a052-a742bba07bf5)

## 6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).

Для того, чтобы создать таблицы в простейшем виде, можно использовать подобный синтаксис:

create table имя_таблицы(

      id serial primary key,

      имя_атрибута1 тип_данных,

      имя_атрибутаN тип_данных

);

указание id является обязательным, ключевые слова primary key говорят о том, что данный атрибут является идентификатором. Во-вторых, используется ключевое слово serial, что значит, что генерацией id будет заниматься БД, причем генерироваться он будет последовательно, т.е. 1, 2, 3 и т.д.

**Вставка данных**

Как создать структуру - разобрались. Давайте теперь вставим данные в БД. Синтаксис следующий:

insert into имя_таблицы(имя_атр1, имя_атрN) values(значение_атр1, значение_атрN);

**Обновление данных**

Для обновления данных используется оператор update. Синтаксис такой:

update имя_таблицы set имя_атр1 = зн_атр1, имя_атрN = зн_атрN;

*Обратите внимание*, что если выполнить эту команду без условия, то обновятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

**Удаление данных**

Чтобы удалить данные, нужно использовать оператор delete. Синтаксис такой:

delete from имя_таблицы;

*Обратите внимание*, что если выполнить эту команду без условия, то удалятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

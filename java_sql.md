## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).](#6-Опишите-как-вставить-удалить-обновить-данные-в(из)-таблицу(ы))

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

[8. Что такое денормализация БД? Для чего она нужна?](#8-Что-такое-денормализация-БД-Для-чего-она-нужна)

[9. Что такое кластерный и некластерный индексы?](#9-Что-такое-кластерный-и-некластерный-индексы)

## 1. Что такое SQL?
SQL - это декларативный язык программирования, который используется для создания, модификации и управления данными в реляционной БД, управляемой системой управления базами данных (СУБД). С помощью SQL-запросов можно добавлять, изменять, получать или удалять данные из БД.

## 2. Что такое DML и DDL?
![image](https://github.com/artemaverin/summary/assets/97846877/3bd0357e-64ec-4edf-98fb-be075f6e041c)

Операции бывают двух видов: над структурой данных и над самими данными. К первым относятся операции, касающиеся создания, удаления, изменения и т.д. таблиц и баз данных. Ко вторым относятся создание, удаление, получение, обновление самих данных. В профильной литературе можно встретить понятия DDL и DML. 

DDL – Data Definition Language, характеризует операции над структурой данных.

DML – Data Manipulation Language, представляет операции над самими данными.

## 3. Что такое первичный ключ?
первичный ключ (primary key) - это поле в таблице, однозначно идентифицирующее каждую строку (запись) в таблице БД. Первичный ключ должен содержать уникальные значения. Также не может содержать null. В таблице может быть только один первичный ключ. Ключ может состоять из одного и более полей. Первичный ключ, состоящий из нескольких полей, называется составным ключом.

Первичный ключ выбирается так, чтобы он состоял из минимально возможного количества полей. Например, если есть поля "имя", "фамилия", "дата рождения" и "номер телефона", нет смысла делать составной ключ из нескольких полей, так как имеется поле "номер телефона", и по нему одному мы можем в будущем уникально идентифицировать записи, так как номер телефона не может повторяться.

Так как в реляционных БД все таблицы почти всегда связаны друг с другом, первичные ключи используются для однозначной организации этой связи.

## 4. Что такое внешний ключ?

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

## 5. Какие виды связей между таблицами существуют и как они организуются?

**many-to-one и one-to-many**

Пример:

Должность и Сотрудник. Одну должность могут иметь несколько сотрудников, причем сотрудник может иметь одну должность. 

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Особое внимание стоит уделить столбцу position_id. Для связи таблиц между собой используется ключевое слово REFERENCES. Это значит, что значения данного столбца - значения связываемой таблицы. В данном случае это можно трактовать как столбец position_id содержит значения из таблицы positions, а именно из столбца id. Общий синтаксис связи при создании таблицы выглядит следующим образом:

имя_столбца тип REFERENCES связываемая_таб(столбец_св_табл)

Слово REFERENCES с английского переводится как "ссылается". Что это значит? При выполнении запроса извлечения всех работников видим, что в таблице position_id стоит какое-то значение. Мы можем перейти к соответствующей таблице, на которую ссылаемся, и найти запись по этому столбцу. Таким образом, мы как бы «переходим» по ссылке. Через SQL это записано последним запросом.

![image](https://github.com/artemaverin/summary/assets/97846877/d09061fa-36aa-488a-97c3-974422840f98)

Обратите внимание, что стрелка идет от сущности, которая many, к сущности, которая one. Либо же можно рассуждать так: где у нас стоит REFERENCES связь начинается, а стрелка будет указывать на сущность, на которую мы ссылаемся.

**many-to-many**

Пример:

Человек и Курс. Человек может проходить много курсов (one-to-many), в то же время курс могут проходить много человек (many-to-one).

Данная связь организуется с помощью вспомогательной таблицы, т.к. на уровне БД мы имеем только связь many-to-one.

![image](https://github.com/artemaverin/summary/assets/97846877/100ab40a-1180-4e3b-b169-5b4f4d5934dd)

Как видно по коду, здесь идет двойное применение REFERENCES, т.е. у нас есть два внешних ключа во вспомогательной таблице. Один ссылается на таблицу курсов, другой на таблицу людей.

**one-to-one**

Пример:

Очевидно, что паспорт и человек, это связь один к одному. У каждого человека есть только один паспорт. У паспорта может быть только один владелец.

Организуется эта связь немного сложнее, чем первые две. В первую очередь тут стоит задать вопрос: какую связь мы хотим? Однонаправленную (unidirectional) или двунаправленную (bidirectional)? Т.е. как мы хотим извлекать данные? В контексте примера: мы хотим по паспорту получать человека или наоборот? Или и так и так?

Если нам нужно получать паспорт по человеку, то мы можем поступить так

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255),
    passport_id int references passport(id) unique
);
```

Обратите внимание, что рядом с внешним ключом стоит unique. Это значит, что данное значение уникально среди всех записей данного столбца. Без этого ограничения(constraint) мы получим связь many-to-one. Теперь по записи в таблице людей мы можем перейти в таблицу паспорта для уточнения данных. Аналогично мы могли бы поступить в случае, если бы нам нужно было получать человека по паспорту. Такая организация связи является однонаправленной. Обратите внимание, что на связи указано 1, это значит, что связь один-к-одному, мы не можем писать unique, т.к. это относится к спецификации БД.

![image](https://github.com/artemaverin/summary/assets/97846877/674e1b19-41d1-450c-b41a-f05b1a5914c8)

Если нам нужно получать данные и так, и так (человека по паспорту и паспорт по человеку), то мы можем сделать так:

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255)
);

create table passport_people(
    id serial primary key,
    passport_id int references passport(id) unique,
    people_id int references people(id) unique
);
```

Данный способ использует, как и many-to-many, вспомогательную таблицу, но опять же используется ограничения на внешние ключи unique. Иначе мы получим связь many-to-many - как на рисунке ниже - обратите внимание, над связями нет символов "1".  

![image](https://github.com/artemaverin/summary/assets/97846877/951b8949-1f44-4ee7-a052-a742bba07bf5)

## 6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).

Для того, чтобы создать таблицы в простейшем виде, можно использовать подобный синтаксис:

create table имя_таблицы(

      id serial primary key,

      имя_атрибута1 тип_данных,

      имя_атрибутаN тип_данных

);

указание id является обязательным, ключевые слова primary key говорят о том, что данный атрибут является идентификатором. Во-вторых, используется ключевое слово serial, что значит, что генерацией id будет заниматься БД, причем генерироваться он будет последовательно, т.е. 1, 2, 3 и т.д.

**Вставка данных**

Как создать структуру - разобрались. Давайте теперь вставим данные в БД. Синтаксис следующий:

insert into имя_таблицы(имя_атр1, имя_атрN) values(значение_атр1, значение_атрN);

**Обновление данных**

Для обновления данных используется оператор update. Синтаксис такой:

update имя_таблицы set имя_атр1 = зн_атр1, имя_атрN = зн_атрN;

*Обратите внимание*, что если выполнить эту команду без условия, то обновятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

**Удаление данных**

Чтобы удалить данные, нужно использовать оператор delete. Синтаксис такой:

delete from имя_таблицы;

*Обратите внимание*, что если выполнить эту команду без условия, то удалятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

## 7. Что такое нормализация БД?

https://job4j.ru/profile/exercise/179/task-view/819

Нормализация БД – это процесс организации данных определенным образом и рекомендации по проектированию. Т.е. таблицы и связи между ними (отношения) создаются в соответствии с правилами. В результате обеспечивается некоторый уровень безопасности данных. К тому же устраняются несогласованные зависимости и избыточность.

Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.

избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управление данными не гибким и не очень удобным. Отсюда можно сделать вывод, что нормализация нужна для:

- Устранения аномалий
- Повышения производительности
- Повышения удобства управления данными

Нормальная форма базы данных – это набор правил и критериев, которым должна отвечать база данных.

Процесс нормализации – это последовательный процесс приведения базы данных к эталонному виду, т.е. переход от одной нормальной формы к следующей.

* Ненормализованная форма или нулевая нормальная форма (UNF)
* Первая нормальная форма (1NF)
* Вторая нормальная форма (2NF)
* Третья нормальная форма (3NF)
* Нормальная форма Бойса-Кодда (BCNF)
* Четвертая нормальная форма (4NF)
* Пятая нормальная форма (5NF)
* Доменно-ключевая нормальная форма (DKNF)
* Шестая нормальная форма (6NF)

**первая нормальная форма (1NF)**

Переменная отношения находится в первой нормальной форме (далее – 1НФ) тогда и только тогда, когда каждый атрибут отношения содержит строго одно атомарное значение.

Если упростить, то можно сказать, что каждый атрибут отношения атомарен (неделим) и система управления БД (далее - СУБД) не должна оперировать отдельной частью атрибута.

https://info-comp.ru/first-normal-form

Требование первой нормальной формы (1NF) очень простое и оно заключается в том, чтобы таблицы соответствовали реляционной модели данных и соблюдали определённые реляционные принципы.

Таким образом, чтобы база данных находилась в 1 нормальной форме, необходимо чтобы ее таблицы соблюдали следующие реляционные принципы:

- В таблице не должно быть дублирующих строк
- В каждой ячейке таблицы хранится атомарное значение (одно не составное значение)
- В столбце хранятся данные одного типа
- Отсутствуют массивы и списки в любом виде

Правило: **Строки, столбцы и ячейки в таблицах необходимо использовать строго по назначению.**

* Назначение строк – хранить данные
* Назначение столбцов – хранить структурную информацию
* Назначение ячеек – хранить атомарное значение

**вторая нормальная форма (2NF)**

Переменная отношения находится во второй нормальной форме (далее – 2НФ) тогда и только тогда, когда она находится в 1НФ и каждый ее неключевой атрибут функционально полно зависит от любого потенциального ключа.

Т.е. ни один атрибут, не входящий в состав потенциального ключа, не должен функционально зависеть от части какого бы то ни было из потенциальных ключей.

https://info-comp.ru/second-normal-form

Чтобы база данных находилась во второй нормальной форме (2NF), необходимо чтобы ее таблицы удовлетворяли следующим требованиям:

- Таблица должна находиться в первой нормальной форме
- Таблица должна иметь ключ
- Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)

Если ключ составной, т.е. состоит из нескольких столбцов, то все остальные неключевые столбцы должны зависеть от всего ключа, т.е. от всех столбцов в этом ключе. Если какой-то атрибут (столбец) зависит только от одного столбца в ключе, значит, база данных не находится во второй нормальной форме.

Иными словами, в таблице не должно быть данных, которые можно получить, зная только половину ключа, т.е. только один столбец из составного ключа.

Главное правило второй нормальной формы (2NF) звучит следующим образом
```
Таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку.
```

**третья нормальная форма (3NF)**

Переменная отношения находится в третьей нормальной форме (далее – 3НФ) тогда и только тогда, когда она находится во второй нормальной форме, и каждый ее неключевой атрибут нетранзитивно зависит от первичного ключа. Т.е. в отношении не должно быть атрибутов, которые не входят в состав первичного ключа и при этом транзитивно зависящих от первичного ключа.

https://info-comp.ru/third-normal-form

Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.

Транзитивная зависимость – это когда неключевые столбцы зависят от значений других неключевых столбцов.

Если: 
- в первой нормальной форме наше внимание было нацелено на ***соблюдение реляционных принципов***, 
- во второй нормальной форме в центре нашего внимания был ***первичный ключ***,
- то в третьей нормальной форме все наше внимание уделено ***столбцам***, которые ***не являются первичным ключом***, т.е. неключевым столбцам.

Иными словами, неключевые столбцы не должны пытаться играть роль ключа в таблице, т.е. они действительно должны быть неключевыми столбцами, такие столбцы не дают возможности получить данные из других столбцов, они дают возможность посмотреть на информацию, которая в них содержится, так как в этом их назначение.

Главное правило третьей нормальной форме (3NF) звучит следующим образом:

```
Таблица должна содержать правильные неключевые столбцы
```

***Нормальная форма Бойса-Кодда (BCNF)***

https://info-comp.ru/boyes-codd-normal-form

Требования нормальной формы Бойса-Кодда следующие:

- Таблица должна находиться в третьей нормальной форме. Здесь все как обычно, т.е. как и у всех остальных нормальных форм, первое требование заключается в том, чтобы таблица находилась в предыдущей нормальной форме, в данном случае в третьей нормальной форме;
- Ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов.
- 
Отсюда следует, что требования нормальной формы Бойса-Кодда предъявляются только к таблицам, у которых первичный ключ составной. Таблицы, у которых первичный ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной форме Бойса-Кодда.

Главное правило нормальной формы Бойса-Кодда (BCNF) звучит следующим образом:
```
Часть составного первичного ключа не должна зависеть от неключевого столбца.
```

## 8. Что такое денормализация БД? Для чего она нужна?

https://job4j.ru/profile/exercise/179/task-view/820

Оптимизация БД – очень важный шаг для повышения производительности приложения. Обычно разработчики нормализуют реляционную БД, т.е. реструктурируют ее таким образом, чтобы уменьшить избыточность данных и повысить целостность данных. Однако бывают ситуации, когда нормализации недостаточно и в этом случае для повышения производительности БД в дальнейшем разработчики прибегают к *денормализации* БД.

Основная цель денормализации – значительно ускорить получение данных. Однако необходимо понимать, что денормализация – это не волшебная таблетка и необходимо использовать ее осторожно. Разработчики должны использовать этот инструмент только для определенных целей

**1. Для повышения производительности запросов.**

Обычно нормализованная БД требует объединения множества таблиц для получения результата запросов. Однако, чем больше соединений, тем медленнее выполняется запрос. Поэтому мы можем добавить избыточность в БД, скопировав значения между родительской и дочерней таблицами. Таким образом мы уменьшим количество соединений, которые необходимы для запроса.

**2. Сделать БД более удобной в управлении.**

Нормализованная БД не имеет значений, которые являются расчетными и очень часто необходимы для приложений. Расчет таких значений на лету потребует времени и, соответственно, замедлит выполнение запроса.

В таком случае можно денормализовать БД, чтобы получить рассчитываемые значения, добавив для них отдельные столбцы. После того как такие значения рассчитаны и добавлены в таблицы, становится очень удобным создавать необходимые разработчикам отчеты и значительно упрощают написание запросов.

**3. Упростить и ускорить составление отчетов.**

Часто приложению необходимо предоставлять много аналитической и статистической информации. Создание отчетов из оперативных данных занимает много времени и отрицательно влияет на производительность системы.

Эту проблему может помочь решить денормализация БД. Например, нам необходимо предоставить общую сводку продаж для одного или нескольких пользователей: нормализованная БД будет агрегировать и вычислять все детали счетов несколько раз. Чтобы ускорить этот процесс, можно сохранить сводку продаж за год до текущей даты в таблице, в которой хранятся сведения о пользователях.

Стоит подчеркнуть один очень важный факт – необходимо отличать денормализованную схему БД (которая сначала была нормализована и только потом денормализована) от просто недостаточно нормализованной схемы: первое – хорошо, а второе – просто пример плохого дизайна.

Недостатки:


**- дополнительное место для хранения.**

Когда мы денормализуем БД, придется дублировать много данных. Соответственно, нашей БД потребуется больше места для хранения.

**- дополнительная документация.**

Каждый шаг, который мы делаем во время денормализации, необходимо должным образом задокументировать. Если когда-либо позже мы изменим структуру БД, необходимо будет пересмотреть все правила, которые были созданы ранее.

**- возможные аномалии данных.**

При денормализации БД необходимо понимать, что мы получаем больше данных которые можно изменить. Следовательно, нам необходимо заботиться о каждом отдельном случае дублирования данных. В таком случае необходимо использовать триггеры, хранимые процедуры и транзакции, чтобы избежать аномалий данных.

**- приходится писать больше кода**

При денормализации БД мы изменяем SELECT запросы и, хотя это дает некоторые преимущества, оно имеет свою цену – необходимо писать дополнительный код. К тому же необходимо обновить значения в новых столбцах, которые мы добавляем к существующим записям.

**- более медленные операции**

Денормализация БД может ускорить извлечение данных, но в то же время замедляет обновление. Если в приложении необходимо выполнять много операций записи в БД, то оно может показывать более низкую производительность, чем аналогичная нормализованная БД. Поэтому прежде чем использовать денормализацию, необходимо убедиться в том, что это не принесет ущерба для нашего приложения.

## 9. Что такое кластерный и некластерный индексы?

**Кластерный индекс** – это индекс, который физически упорядочивает данные (фактически биты на диске) определенным образом. Когда в таблицу поступают новые данные, то они сохраняются в том же порядке.

Ограничение в отношении кластерного индекса заключается в том, что для таблицы БД можно создать только один кластерный индекс. Это происходит из-за его природы – кластерные индексы обеспечивают соблюдение порядка данных. К тому же кластерные индексы увеличивают время записи, поскольку при добавлении новых данных все данные необходимо переупорядочить. Однако кластерные индексы могут значительно увеличить скорость чтения данных из таблицы.
```
Таким образом, главное, что необходимо понимать – это то, что кластерные индексы упорядочивают данные физически (на диске) в кластерах.
```
В большинстве систем управления базами данных (далее – СУБД) кластерный индекс строится автоматически на основании первичного ключа. Если в таблице нет первичного ключа, то для построения кластерного индекса будет использовано поле, объявленное как UNIQUE. Если же в таблице нет уникального поля, то можем создать индекс на основании любого из полей, по которому мы желаем сортировать данные в таблице.

По умолчанию кластерный индекс создается на основе B-tree, т.е. самобалансирующееся дерево. B-деревья стараются оставаться сбалансированными. При этом количество данных в каждой ветви дерева примерно одинаково. Следовательно, количество уровней, которые необходимо пройти, чтобы найти строки, всегда примерно одинаково. Такие индексы можно эффективно использовать для запросов на равенство и диапазона. Они могут работать со всеми типами данных, а также могут быть использованы для получения значений NULL.

**Некластерные индексы** – это индексы, которые хранят отдельный список упорядочивания, в котором есть указатели на физические строки. В основном это похоже на указатель в книге, поскольку такой указатель знает, на какой странице начинается или заканчивается та или иная глава. Таким образом, в отличие от кластерного индекса, таблица может иметь много некластерных индексов. Но стоит понимать важный момент – каждый новый некластерный индекс увеличивает время, которое необходимо для записи новых строк в таблицу.
```
Таким образом, некластерные индексы не упорядочивают данные физически, они просто хранят список порядка данных.
```
Некластерные индексы используются для увеличения скорости запросов к таблице. Некластерные индексы указывают на адреса памяти вместо хранения самих данных. Поэтому они медленнее для запросов, чем кластерные индексы. Однако обычно они намного быстрее, чем неиндексированный столбец.

![image](https://github.com/artemaverin/summary/assets/97846877/d05ae7ab-9735-4feb-937b-a1f7191db775)

Когда использовать кластерные или некластерные индексы?

- если необходимо создавать несколько индексов в БД, то выбираем некластерный индекс, поскольку может быть только один кластерный индекс;
- если при выборке будут использоваться только столбцы, задействованные при создании индекса, то некластерный индекс будет работать быстрее. Однако если нас интересуют и остальные столбцы, которые связаны с индексом, то операции выборки будут выполняться медленнее поскольку для некластерного индекса будет выполнен сначала поиск по индексу и только потом выполнено связывание с фактической записью таблицы. С другой стороны, операция SELECT выполняется быстрее с кластерными индексами, если данные выбираются из столбцов, отличных от столбца в кластерном индексе. Поскольку все записи уже отсортированы.
- операции INSERT и UPDATE выполняются быстрее с некластерными индексами, поскольку фактические записи не требуется сортировать при вставке и обновлении.
- поскольку некластерные индексы хранятся отдельно от физических данных, то они занимают дополнительное пространство на диске. Если это критично, то для использования некластерный индекс непригоден.

В первую очередь индексы необходимы для улучшения производительности наших БД. Но если создать слишком много индексов, то мы можем только навредить производительности. Индексы – это достаточно мощный способ повысить производительность таблиц, но их нужно использовать осторожно. Очень часто индексы могут мешать запросам, если они используются неправильно.


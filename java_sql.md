## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).](#6-Опишите-как-вставить-удалить-обновить-данные-в(из)-таблицу(ы))

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

[8. Что такое денормализация БД? Для чего она нужна?](#8-Что-такое-денормализация-БД-Для-чего-она-нужна)

[9. Что такое кластерный и некластерный индексы?](#9-Что-такое-кластерный-и-некластерный-индексы)

[10. Какие типы соединений (join) таблиц существуют? В чем их разница?](#10-Какие-типы-соединений-(join)-таблиц-существуют-В-чем-их-разница)

[11. Что такое SQL курсор?](#11-Что-такое-SQL-курсор)

[12. Опишите шаги по созданию и использованию курсора](#12-Опишите-шаги-по-созданию-и-использованию-курсора)

[13. Что такое транзакция?](#13-Что-такое-транзакция)

[14. Что такое триггер? Какие типы триггеров Вы знаете?](#14-Что-такое-триггер-Какие-типы-триггеров-Вы-знаете)

[15. В чем разница между where и having?](#15-В-чем-разница-между-where-и-having)

[16. Что такое подзапрос (sub-query)?](#16-Что-такое-подзапрос-(sub-query))

[17. Что такое union?](#17-Что-такое-union)

[18. Что такое group by?](#18-Что-такое-group-by)

[19. Что такое хранимые процедуры?](#19-Что-такое-хранимые-процедуры)

[20. Что такое view (Представление)?](#20-Что-такое-view-(Представление))

[21. Что такое JDBC?](#21-Что-такое-JDBC)

[22. Что нужно для работы с той или иной БД?](#22-Что-нужно-для-работы-с-той-или-иной-БД)

[23. Как зарегистрировать драйвер?](#23-Как-зарегистрировать-драйвер)

[24. Как получить Connection?](#24-Как-получить-Connection)

[25.Что такое Statement, PreparedStatement? В чем разница между ними?](#25-Что-такое-Statement-PreparedStatement-В-чем-разница-между-ними)

[26. Что такое ResultSet?](#26-Что-такое-ResultSet)

[27. В чем разница между методами execute, executeUpdate, executeQuery?](#27-В-чем-разница-между-методами-execute-executeUpdate-executeQuery)

## 1. Что такое SQL?
SQL - это декларативный язык программирования, который используется для создания, модификации и управления данными в реляционной БД, управляемой системой управления базами данных (СУБД). С помощью SQL-запросов можно добавлять, изменять, получать или удалять данные из БД.

## 2. Что такое DML и DDL?
![image](https://github.com/artemaverin/summary/assets/97846877/3bd0357e-64ec-4edf-98fb-be075f6e041c)

Операции бывают двух видов: над структурой данных и над самими данными. К первым относятся операции, касающиеся создания, удаления, изменения и т.д. таблиц и баз данных. Ко вторым относятся создание, удаление, получение, обновление самих данных. В профильной литературе можно встретить понятия DDL и DML. 

DDL – Data Definition Language, характеризует операции над структурой данных.

DML – Data Manipulation Language, представляет операции над самими данными.

## 3. Что такое первичный ключ?
первичный ключ (primary key) - это поле в таблице, однозначно идентифицирующее каждую строку (запись) в таблице БД. Первичный ключ должен содержать уникальные значения. Также не может содержать null. В таблице может быть только один первичный ключ. Ключ может состоять из одного и более полей. Первичный ключ, состоящий из нескольких полей, называется составным ключом.

Первичный ключ выбирается так, чтобы он состоял из минимально возможного количества полей. Например, если есть поля "имя", "фамилия", "дата рождения" и "номер телефона", нет смысла делать составной ключ из нескольких полей, так как имеется поле "номер телефона", и по нему одному мы можем в будущем уникально идентифицировать записи, так как номер телефона не может повторяться.

Так как в реляционных БД все таблицы почти всегда связаны друг с другом, первичные ключи используются для однозначной организации этой связи.

## 4. Что такое внешний ключ?

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

## 5. Какие виды связей между таблицами существуют и как они организуются?

**many-to-one и one-to-many**

Пример:

Должность и Сотрудник. Одну должность могут иметь несколько сотрудников, причем сотрудник может иметь одну должность. 

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Особое внимание стоит уделить столбцу position_id. Для связи таблиц между собой используется ключевое слово REFERENCES. Это значит, что значения данного столбца - значения связываемой таблицы. В данном случае это можно трактовать как столбец position_id содержит значения из таблицы positions, а именно из столбца id. Общий синтаксис связи при создании таблицы выглядит следующим образом:

имя_столбца тип REFERENCES связываемая_таб(столбец_св_табл)

Слово REFERENCES с английского переводится как "ссылается". Что это значит? При выполнении запроса извлечения всех работников видим, что в таблице position_id стоит какое-то значение. Мы можем перейти к соответствующей таблице, на которую ссылаемся, и найти запись по этому столбцу. Таким образом, мы как бы «переходим» по ссылке. Через SQL это записано последним запросом.

![image](https://github.com/artemaverin/summary/assets/97846877/d09061fa-36aa-488a-97c3-974422840f98)

Обратите внимание, что стрелка идет от сущности, которая many, к сущности, которая one. Либо же можно рассуждать так: где у нас стоит REFERENCES связь начинается, а стрелка будет указывать на сущность, на которую мы ссылаемся.

**many-to-many**

Пример:

Человек и Курс. Человек может проходить много курсов (one-to-many), в то же время курс могут проходить много человек (many-to-one).

Данная связь организуется с помощью вспомогательной таблицы, т.к. на уровне БД мы имеем только связь many-to-one.

![image](https://github.com/artemaverin/summary/assets/97846877/100ab40a-1180-4e3b-b169-5b4f4d5934dd)

Как видно по коду, здесь идет двойное применение REFERENCES, т.е. у нас есть два внешних ключа во вспомогательной таблице. Один ссылается на таблицу курсов, другой на таблицу людей.

**one-to-one**

Пример:

Очевидно, что паспорт и человек, это связь один к одному. У каждого человека есть только один паспорт. У паспорта может быть только один владелец.

Организуется эта связь немного сложнее, чем первые две. В первую очередь тут стоит задать вопрос: какую связь мы хотим? Однонаправленную (unidirectional) или двунаправленную (bidirectional)? Т.е. как мы хотим извлекать данные? В контексте примера: мы хотим по паспорту получать человека или наоборот? Или и так и так?

Если нам нужно получать паспорт по человеку, то мы можем поступить так

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255),
    passport_id int references passport(id) unique
);
```

Обратите внимание, что рядом с внешним ключом стоит unique. Это значит, что данное значение уникально среди всех записей данного столбца. Без этого ограничения(constraint) мы получим связь many-to-one. Теперь по записи в таблице людей мы можем перейти в таблицу паспорта для уточнения данных. Аналогично мы могли бы поступить в случае, если бы нам нужно было получать человека по паспорту. Такая организация связи является однонаправленной. Обратите внимание, что на связи указано 1, это значит, что связь один-к-одному, мы не можем писать unique, т.к. это относится к спецификации БД.

![image](https://github.com/artemaverin/summary/assets/97846877/674e1b19-41d1-450c-b41a-f05b1a5914c8)

Если нам нужно получать данные и так, и так (человека по паспорту и паспорт по человеку), то мы можем сделать так:

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255)
);

create table passport_people(
    id serial primary key,
    passport_id int references passport(id) unique,
    people_id int references people(id) unique
);
```

Данный способ использует, как и many-to-many, вспомогательную таблицу, но опять же используется ограничения на внешние ключи unique. Иначе мы получим связь many-to-many - как на рисунке ниже - обратите внимание, над связями нет символов "1".  

![image](https://github.com/artemaverin/summary/assets/97846877/951b8949-1f44-4ee7-a052-a742bba07bf5)

## 6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).

Для того, чтобы создать таблицы в простейшем виде, можно использовать подобный синтаксис:

create table имя_таблицы(

      id serial primary key,

      имя_атрибута1 тип_данных,

      имя_атрибутаN тип_данных

);

указание id является обязательным, ключевые слова primary key говорят о том, что данный атрибут является идентификатором. Во-вторых, используется ключевое слово serial, что значит, что генерацией id будет заниматься БД, причем генерироваться он будет последовательно, т.е. 1, 2, 3 и т.д.

**Вставка данных**

Как создать структуру - разобрались. Давайте теперь вставим данные в БД. Синтаксис следующий:

insert into имя_таблицы(имя_атр1, имя_атрN) values(значение_атр1, значение_атрN);

**Обновление данных**

Для обновления данных используется оператор update. Синтаксис такой:

update имя_таблицы set имя_атр1 = зн_атр1, имя_атрN = зн_атрN;

*Обратите внимание*, что если выполнить эту команду без условия, то обновятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

**Удаление данных**

Чтобы удалить данные, нужно использовать оператор delete. Синтаксис такой:

delete from имя_таблицы;

*Обратите внимание*, что если выполнить эту команду без условия, то удалятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

## 7. Что такое нормализация БД?

https://job4j.ru/profile/exercise/179/task-view/819

Нормализация БД – это процесс организации данных определенным образом и рекомендации по проектированию. Т.е. таблицы и связи между ними (отношения) создаются в соответствии с правилами. В результате обеспечивается некоторый уровень безопасности данных. К тому же устраняются несогласованные зависимости и избыточность.

Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.

избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управление данными не гибким и не очень удобным. Отсюда можно сделать вывод, что нормализация нужна для:

- Устранения аномалий
- Повышения производительности
- Повышения удобства управления данными

Нормальная форма базы данных – это набор правил и критериев, которым должна отвечать база данных.

Процесс нормализации – это последовательный процесс приведения базы данных к эталонному виду, т.е. переход от одной нормальной формы к следующей.

* Ненормализованная форма или нулевая нормальная форма (UNF)
* Первая нормальная форма (1NF)
* Вторая нормальная форма (2NF)
* Третья нормальная форма (3NF)
* Нормальная форма Бойса-Кодда (BCNF)
* Четвертая нормальная форма (4NF)
* Пятая нормальная форма (5NF)
* Доменно-ключевая нормальная форма (DKNF)
* Шестая нормальная форма (6NF)

**первая нормальная форма (1NF)**

Переменная отношения находится в первой нормальной форме (далее – 1НФ) тогда и только тогда, когда каждый атрибут отношения содержит строго одно атомарное значение.

Если упростить, то можно сказать, что каждый атрибут отношения атомарен (неделим) и система управления БД (далее - СУБД) не должна оперировать отдельной частью атрибута.

https://info-comp.ru/first-normal-form

Требование первой нормальной формы (1NF) очень простое и оно заключается в том, чтобы таблицы соответствовали реляционной модели данных и соблюдали определённые реляционные принципы.

Таким образом, чтобы база данных находилась в 1 нормальной форме, необходимо чтобы ее таблицы соблюдали следующие реляционные принципы:

- В таблице не должно быть дублирующих строк
- В каждой ячейке таблицы хранится атомарное значение (одно не составное значение)
- В столбце хранятся данные одного типа
- Отсутствуют массивы и списки в любом виде

Правило: **Строки, столбцы и ячейки в таблицах необходимо использовать строго по назначению.**

* Назначение строк – хранить данные
* Назначение столбцов – хранить структурную информацию
* Назначение ячеек – хранить атомарное значение

**вторая нормальная форма (2NF)**

Переменная отношения находится во второй нормальной форме (далее – 2НФ) тогда и только тогда, когда она находится в 1НФ и каждый ее неключевой атрибут функционально полно зависит от любого потенциального ключа.

Т.е. ни один атрибут, не входящий в состав потенциального ключа, не должен функционально зависеть от части какого бы то ни было из потенциальных ключей.

https://info-comp.ru/second-normal-form

Чтобы база данных находилась во второй нормальной форме (2NF), необходимо чтобы ее таблицы удовлетворяли следующим требованиям:

- Таблица должна находиться в первой нормальной форме
- Таблица должна иметь ключ
- Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)

Если ключ составной, т.е. состоит из нескольких столбцов, то все остальные неключевые столбцы должны зависеть от всего ключа, т.е. от всех столбцов в этом ключе. Если какой-то атрибут (столбец) зависит только от одного столбца в ключе, значит, база данных не находится во второй нормальной форме.

Иными словами, в таблице не должно быть данных, которые можно получить, зная только половину ключа, т.е. только один столбец из составного ключа.

Главное правило второй нормальной формы (2NF) звучит следующим образом
```
Таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку.
```

**третья нормальная форма (3NF)**

Переменная отношения находится в третьей нормальной форме (далее – 3НФ) тогда и только тогда, когда она находится во второй нормальной форме, и каждый ее неключевой атрибут нетранзитивно зависит от первичного ключа. Т.е. в отношении не должно быть атрибутов, которые не входят в состав первичного ключа и при этом транзитивно зависящих от первичного ключа.

https://info-comp.ru/third-normal-form

Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.

Транзитивная зависимость – это когда неключевые столбцы зависят от значений других неключевых столбцов.

Если: 
- в первой нормальной форме наше внимание было нацелено на ***соблюдение реляционных принципов***, 
- во второй нормальной форме в центре нашего внимания был ***первичный ключ***,
- то в третьей нормальной форме все наше внимание уделено ***столбцам***, которые ***не являются первичным ключом***, т.е. неключевым столбцам.

Иными словами, неключевые столбцы не должны пытаться играть роль ключа в таблице, т.е. они действительно должны быть неключевыми столбцами, такие столбцы не дают возможности получить данные из других столбцов, они дают возможность посмотреть на информацию, которая в них содержится, так как в этом их назначение.

Главное правило третьей нормальной форме (3NF) звучит следующим образом:

```
Таблица должна содержать правильные неключевые столбцы
```

***Нормальная форма Бойса-Кодда (BCNF)***

https://info-comp.ru/boyes-codd-normal-form

Требования нормальной формы Бойса-Кодда следующие:

- Таблица должна находиться в третьей нормальной форме. Здесь все как обычно, т.е. как и у всех остальных нормальных форм, первое требование заключается в том, чтобы таблица находилась в предыдущей нормальной форме, в данном случае в третьей нормальной форме;
- Ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов.
- 
Отсюда следует, что требования нормальной формы Бойса-Кодда предъявляются только к таблицам, у которых первичный ключ составной. Таблицы, у которых первичный ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной форме Бойса-Кодда.

Главное правило нормальной формы Бойса-Кодда (BCNF) звучит следующим образом:
```
Часть составного первичного ключа не должна зависеть от неключевого столбца.
```

## 8. Что такое денормализация БД? Для чего она нужна?

https://job4j.ru/profile/exercise/179/task-view/820

Оптимизация БД – очень важный шаг для повышения производительности приложения. Обычно разработчики нормализуют реляционную БД, т.е. реструктурируют ее таким образом, чтобы уменьшить избыточность данных и повысить целостность данных. Однако бывают ситуации, когда нормализации недостаточно и в этом случае для повышения производительности БД в дальнейшем разработчики прибегают к *денормализации* БД.

Основная цель денормализации – значительно ускорить получение данных. Однако необходимо понимать, что денормализация – это не волшебная таблетка и необходимо использовать ее осторожно. Разработчики должны использовать этот инструмент только для определенных целей

**1. Для повышения производительности запросов.**

Обычно нормализованная БД требует объединения множества таблиц для получения результата запросов. Однако, чем больше соединений, тем медленнее выполняется запрос. Поэтому мы можем добавить избыточность в БД, скопировав значения между родительской и дочерней таблицами. Таким образом мы уменьшим количество соединений, которые необходимы для запроса.

**2. Сделать БД более удобной в управлении.**

Нормализованная БД не имеет значений, которые являются расчетными и очень часто необходимы для приложений. Расчет таких значений на лету потребует времени и, соответственно, замедлит выполнение запроса.

В таком случае можно денормализовать БД, чтобы получить рассчитываемые значения, добавив для них отдельные столбцы. После того как такие значения рассчитаны и добавлены в таблицы, становится очень удобным создавать необходимые разработчикам отчеты и значительно упрощают написание запросов.

**3. Упростить и ускорить составление отчетов.**

Часто приложению необходимо предоставлять много аналитической и статистической информации. Создание отчетов из оперативных данных занимает много времени и отрицательно влияет на производительность системы.

Эту проблему может помочь решить денормализация БД. Например, нам необходимо предоставить общую сводку продаж для одного или нескольких пользователей: нормализованная БД будет агрегировать и вычислять все детали счетов несколько раз. Чтобы ускорить этот процесс, можно сохранить сводку продаж за год до текущей даты в таблице, в которой хранятся сведения о пользователях.

Стоит подчеркнуть один очень важный факт – необходимо отличать денормализованную схему БД (которая сначала была нормализована и только потом денормализована) от просто недостаточно нормализованной схемы: первое – хорошо, а второе – просто пример плохого дизайна.

Недостатки:


**- дополнительное место для хранения.**

Когда мы денормализуем БД, придется дублировать много данных. Соответственно, нашей БД потребуется больше места для хранения.

**- дополнительная документация.**

Каждый шаг, который мы делаем во время денормализации, необходимо должным образом задокументировать. Если когда-либо позже мы изменим структуру БД, необходимо будет пересмотреть все правила, которые были созданы ранее.

**- возможные аномалии данных.**

При денормализации БД необходимо понимать, что мы получаем больше данных которые можно изменить. Следовательно, нам необходимо заботиться о каждом отдельном случае дублирования данных. В таком случае необходимо использовать триггеры, хранимые процедуры и транзакции, чтобы избежать аномалий данных.

**- приходится писать больше кода**

При денормализации БД мы изменяем SELECT запросы и, хотя это дает некоторые преимущества, оно имеет свою цену – необходимо писать дополнительный код. К тому же необходимо обновить значения в новых столбцах, которые мы добавляем к существующим записям.

**- более медленные операции**

Денормализация БД может ускорить извлечение данных, но в то же время замедляет обновление. Если в приложении необходимо выполнять много операций записи в БД, то оно может показывать более низкую производительность, чем аналогичная нормализованная БД. Поэтому прежде чем использовать денормализацию, необходимо убедиться в том, что это не принесет ущерба для нашего приложения.

## 9. Что такое кластерный и некластерный индексы?

**Кластерный индекс** – это индекс, который физически упорядочивает данные (фактически биты на диске) определенным образом. Когда в таблицу поступают новые данные, то они сохраняются в том же порядке.

Ограничение в отношении кластерного индекса заключается в том, что для таблицы БД можно создать только один кластерный индекс. Это происходит из-за его природы – кластерные индексы обеспечивают соблюдение порядка данных. К тому же кластерные индексы увеличивают время записи, поскольку при добавлении новых данных все данные необходимо переупорядочить. Однако кластерные индексы могут значительно увеличить скорость чтения данных из таблицы.
```
Таким образом, главное, что необходимо понимать – это то, что кластерные индексы упорядочивают данные физически (на диске) в кластерах.
```
В большинстве систем управления базами данных (далее – СУБД) кластерный индекс строится автоматически на основании первичного ключа. Если в таблице нет первичного ключа, то для построения кластерного индекса будет использовано поле, объявленное как UNIQUE. Если же в таблице нет уникального поля, то можем создать индекс на основании любого из полей, по которому мы желаем сортировать данные в таблице.

По умолчанию кластерный индекс создается на основе B-tree, т.е. самобалансирующееся дерево. B-деревья стараются оставаться сбалансированными. При этом количество данных в каждой ветви дерева примерно одинаково. Следовательно, количество уровней, которые необходимо пройти, чтобы найти строки, всегда примерно одинаково. Такие индексы можно эффективно использовать для запросов на равенство и диапазона. Они могут работать со всеми типами данных, а также могут быть использованы для получения значений NULL.

**Некластерные индексы** – это индексы, которые хранят отдельный список упорядочивания, в котором есть указатели на физические строки. В основном это похоже на указатель в книге, поскольку такой указатель знает, на какой странице начинается или заканчивается та или иная глава. Таким образом, в отличие от кластерного индекса, таблица может иметь много некластерных индексов. Но стоит понимать важный момент – каждый новый некластерный индекс увеличивает время, которое необходимо для записи новых строк в таблицу.
```
Таким образом, некластерные индексы не упорядочивают данные физически, они просто хранят список порядка данных.
```
Некластерные индексы используются для увеличения скорости запросов к таблице. Некластерные индексы указывают на адреса памяти вместо хранения самих данных. Поэтому они медленнее для запросов, чем кластерные индексы. Однако обычно они намного быстрее, чем неиндексированный столбец.

![image](https://github.com/artemaverin/summary/assets/97846877/d05ae7ab-9735-4feb-937b-a1f7191db775)

Когда использовать кластерные или некластерные индексы?

- если необходимо создавать несколько индексов в БД, то выбираем некластерный индекс, поскольку может быть только один кластерный индекс;
- если при выборке будут использоваться только столбцы, задействованные при создании индекса, то некластерный индекс будет работать быстрее. Однако если нас интересуют и остальные столбцы, которые связаны с индексом, то операции выборки будут выполняться медленнее поскольку для некластерного индекса будет выполнен сначала поиск по индексу и только потом выполнено связывание с фактической записью таблицы. С другой стороны, операция SELECT выполняется быстрее с кластерными индексами, если данные выбираются из столбцов, отличных от столбца в кластерном индексе. Поскольку все записи уже отсортированы.
- операции INSERT и UPDATE выполняются быстрее с некластерными индексами, поскольку фактические записи не требуется сортировать при вставке и обновлении.
- поскольку некластерные индексы хранятся отдельно от физических данных, то они занимают дополнительное пространство на диске. Если это критично, то для использования некластерный индекс непригоден.

В первую очередь индексы необходимы для улучшения производительности наших БД. Но если создать слишком много индексов, то мы можем только навредить производительности. Индексы – это достаточно мощный способ повысить производительность таблиц, но их нужно использовать осторожно. Очень часто индексы могут мешать запросам, если они используются неправильно.


## 10. Какие типы соединений (join) таблиц существуют? В чем их разница?

![image](https://github.com/artemaverin/summary/assets/97846877/9a41a92c-0b04-4a27-bec3-ac9843923d4a)

**INNER JOIN** - Из строк левой_таблицы и правой_таблицы объединяются и возвращаются только те строки, по которым выполняются условия_соединения.

**LEFT OUTER JOIN** - Возвращаются все строки левой_таблицы (ключевое слово LEFT). Данными правой_таблицы дополняются только те строки левой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк правой_таблицы вставляются NULL-значения.

**RIGHT OUTER JOIN** - Возвращаются все строки правой_таблицы (ключевое слово RIGHT). Данными левой_таблицы дополняются только те строки правой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк левой_таблицы вставляются NULL-значения.

**FULL OUTER JOIN** - Возвращаются все строки левой_таблицы и правой_таблицы. Если для строк левой_таблицы и правой_таблицы выполняются условия_соединения, то они объединяются в одну строку. Для строк, для которых не выполняются условия_соединения, NULL-значения вставляются на место левой_таблицы, либо на место правой_таблицы, в зависимости от того данных какой таблицы в строке не имеется.

**CROSS JOIN** - Объединение каждой строки левой_таблицы со всеми строками правой_таблицы. Этот вид соединения иногда называют декартовым произведением.

## 11. Что такое SQL курсор?

https://job4j.ru/profile/exercise/179/task-view/811

При знакомстве с этим понятием в литературе и в различных источниках в интернете можно встретить 2 определения понятия курсор:

1. ***Курсор*** – это объект, который позволяет отдельно обрабатывать строки из результирующего набора данных, который возвращается оператором SELECT. Строки при этом можно перебирать последовательно, с первой до последней.

2. ***Курсор*** – это область в памяти БД, которая предназначена для хранения последнего оператора SQL. Если текущий оператор – запрос к БД, то в памяти хранится и строка данных запроса. Она называется текущим значением или же – текущей строкой курсора. Данная область в памяти поименована и доступна нам для вызова.

Обычно курсоры используются для выбора из БД некоторого подмножества хранимой информации. В каждый момент времени мы можем проверить одну строку курсора. В некоторых реализациях систем управления базами данных (далее – СУБД) могут создаваться неявные курсоры, однако чаще всего реализацию курсоров определяют программисты.

Ранее в разделе Структуры данных мы изучали такой интерфейс как Iterator. Напомним, что методы, которые объявлены в этом интерфейсе позволяют перебирать элементы нашей коллекции последовательно и по одному значению. Таким образом, для лучшего понимания можем в некоторой степени сравнивать итератор и курсор.

Чаще всего курсоры используют в следующих случаях:

- в сочетании с операторами, которые возвращают более одной строки данных с сервера БД:

1. Для оператора SELECT можно использовать курсор выбора;

2. Для оператора EXECUTE FUNCTION используется курсор функции.

- в сочетании с оператором INSERT, который отправляет более одной строки на сервер БД. Для этого понадобится курсор вставки.

При кратком рассмотрении курсоров в SQL стоит понимать в чем состоят преимущества и недостатки их использования.

**Преимущества**:

1. Когда мы используем курсор, у нас есть возможность выполнять построчную обработку, т.е. мы можем выполнять проверку над каждой строкой или операции с каждой строкой;

2. Курсоры могут предоставить первые несколько строк до того времени, как будет собран весь результат выполнения запроса. Если же не использовать курсор, то весь набор результатов должен быть получен до того, как приложение что-либо отразит в виде строк. Таким образом, с помощью курсора можно достичь некоторого улучшения времени отклика;

3. Если выполняются обновления без использования курсоров в приложении, то нам необходимо отправлять отдельные операторы SQL на сервер БД. Это может вызвать проблемы параллелизма, если набор результатов изменился с момента запроса клиента. К тому же это увеличивает вероятность потери обновлений. Таким образом, с помощью курсора можно получить лучшее управление параллелизмом;

4. Курсоры могут работать быстрее, чем цикл while, однако стоит помнить о дополнительных накладных расходах.

**Недостатки**:

1. Курсор – это временная рабочая область, которая создана в памяти системы. Поэтому он занимает память нашей системы, которая может быть доступна для других процессов;

2. Каждый раз, когда строка будет извлекаться из курсора, это может приводить к циклическому обходу сети (Клиент – СУБД – Сервер БД). Таким образом, используется гораздо большая пропускная способность сети, в противоположность если бы мы выполняли один оператор SELECT или DELETE и т.д., который выполняет только один циклический обход;

3. Повторяющиеся обходы сети могут снизить скорость операции с использованием курсора.

## 12. Опишите шаги по созданию и использованию курсора

Для работы с курсором необходимо выполнить следующую последовательность операций:

1. Объявить курсор – используется команда DECLARE имя_курсора;

2. Открыть курсор – используется команда OPEN имя_курсора;

3. Чтение следующей строки из курсора – используется команда FETCH имя_курсора;

4. Закрыть курсор – используется команда CLOSE имя_курсора;

5. Удалить курсор из памяти – используется команда DEALLOCATE имя_курсора.

Курсор можно объявить только внутри транзакции. Курсор не вычисляет данные, а только подготавливает запрос, чтобы данные могли быть созданы при вызове FETCH. После работы с курсором мы можем просто зафиксировать транзакцию с помощью COMMIT.

Синтаксис объявления курсора выглядит следующим образом:

DECLARE
    [cursor_name] [[NO] SCROLL] CURSOR FOR [query];
    

BEGIN;
DECLARE
    cursor_products cursor for
                        select * from products;

============================================================ 

FETCH [FORWARD | BACKWARD]
    [direction (rows)]
    FROM [cursor_name];


FETCH NEXT FROM cursor_products;
FETCH 10 FROM cursor_products;

============================================================ 

MOVE [FORWARD | BACKWARD]
    [direction (rows)]
    FROM [cursor_name];

MOVE FORWARD 2 FROM cursor_products;

============================================================ 

CLOSE cursor_name;

COMMIT;

## 13. Что такое транзакция?

https://job4j.ru/profile/exercise/179/task-view/800

Транзакция – это совокупность операций с БД, которые представляют собой логически неделимую единицу. При этом операции могут быть выполнены или целиком и успешно (должны быть соблюдены все правила консистентности БД и не зависит от параллельных транзакций), или же не выполнены вообще (при этом ни одна из операций, которые входят в совокупность, не должна внести изменения в БД).

Если говорить немного проще, то это совокупность операций, который или целиком и успешно завершится, или целиком отменяется в случае ошибки при выполнении любой из входящих в транзакцию операции.

При этом также к определению транзакции добавляют, что они являются единицей восстановления и конкурентного доступа.

Соответственно, обобщим все сказанное:

1. Всегда или выполнится, или не выполнится целиком;

2. Может быть использована для восстановления из-за сбоев и отказов системы. В случае сбоя системы во время выполнения транзакции методы восстановления отменяют любое влияние транзакции на базу данных.

3. Обеспечивает механизм конкурентного доступа к данным.

## 14. Что такое триггер? Какие типы триггеров Вы знаете?

https://job4j.ru/profile/exercise/179/task-view/798

Триггер – специальный объект БД, описывающий перечень действий, которые необходимо автоматически выполнить при наступлении указанного события.

Если упростить для понимания – описание действия, которое надо автоматически выполнить при определенных условиях.

Классическим вариантом использования триггеров является реакция на модификацию данных: операции вставки, обновления и удаления.

Соответственно, триггеры можно поделить на три группы с точки зрения события:

1. BEFORE (до выполнения операции);

2. INSTEAD OF (вместо выполнения операции);

3. AFTER (после выполнения операции).


Теперь рассмотрим другую классификацию – как триггеры выполняются и обрабатывают данные. Здесь они делятся на 2 группы:

- триггеры уровня строки(row) запускаются каждый раз заново для каждой отдельной строки (записи таблицы), которая будет затронута SQL-запросом;

- триггеры уровня запроса(statement) запускаются один раз для всего SQL-запроса.

## 15. В чем разница между where и having?

Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций.

Основное различие между WHERE и HAVING в SQL-запросах заключается в том, что WHERE используется для фильтрации строк до применения к ним групповых функций (например, SUM(), AVG(), COUNT()), а HAVING применяется после применения групповых функций и позволяет отфильтровать итоговые группы.

Например:
```
SELECT column_name(s)
FROM table_name
WHERE condition(s);
```
В этом запросе WHERE используется для применения условий фильтрации к отдельным строкам перед применением групповых функций.
```
SELECT column_name(s), function()
FROM table_name
GROUP BY column_name
HAVING condition;
```
Здесь HAVING используется для фильтрации групп после применения групповых функций. Это позволяет дополнительно отфильтровать группы на основе условия.

Важно отметить, что вы не можете использовать WHERE для группировки данных, вы должны использовать HAVING для этой цели.

Также стоит отметить, что в некоторых случаях использование HAVING может быть более эффективным, чем использование WHERE с подзапросом, особенно если подзапрос содержит сложную логику или соединения.

## 16. Что такое подзапрос (sub-query)?

https://job4j.ru/profile/exercise/179/task/954/395757

Для начала определимся, что в SQL подзапрос можно определить как запрос внутри запроса. Таким образом, можно сказать, что подзапрос - это запрос, встроенный в предложение WHERE другого SQL-запроса.

Важные особенности и правила использования подзапросов, о которых стоит упомянуть в самом начале:

1. Можно поместить подзапрос в несколько предложений SQL: предложение WHERE, предложение HAVING, предложение FROM.

Подзапросы могут использоваться с операторами SELECT, UPDATE, INSERT, DELETE вместе с операторами выражения. Это могут быть оператор равенства или операторы сравнения, такие как =>, =, <= и оператор LIKE

2. Подзапрос – это запрос внутри другого запроса. Внешний запрос называется основным запросом, а внутренний называется подзапросом;

3. Подзапрос обычно выполняется первым, и его выходные данные используются для выполнения условия запроса для основного или внешнего запроса;

4. Подзапрос должен быть заключен в круглые скобки.

5. Подзапросы должны находится справа от оператора сравнения.

6. ORDER BY нельзя использовать в подзапросе. GROUP BY может быть использоваться для выполнения функции в подзапросе.

7. Необходимо использовать однострочные операторы с однострочными подзапросами. И наоборот – с многострочными операторами необходимо использовать многострочные подзапросы. Тут необходимо пояснить, что однострочные подзапросы – это подзапросы, которые в результате выборки вернут 0 или одну строку, а многострочные – 1 или более строк.


Один из простейших вариантов использования подзапроса – включить его в предложение WHERE для фильтрации результатов. Для примера – вы хотите получить информацию только о тех менеджерах по продажах, которые в прошлом месяце получили вознаграждение выше среднего, то вы можете использовать SQL-запрос:
```
SELECT * FROM sales_managers 
WHERE manager_fee > (SELECT AVG(manager_fee) FROM sales_managers);
```

**Скалярные подзапросы**

В том случае, если подзапрос возвращает одно значение или ровно одну строку и ровно один столбец, то мы называем такие подзапросы скалярным подзапросом. Этот тип подзапроса часто используется в предложении WHERE для фильтрации результатов основного запроса. Думаю, что вы уже поняли, что подзапрос из нашего предыдущего примера является скалярным, поскольку он возвращает одно значение – среднее вознаграждение.

Скалярные подзапросы к тому же могут использоваться в операторе SELECT основного запроса. Например, мы хотим, чтобы рядом с ценой товара отражалась средняя цена всех наших товаров, то мы можем выполнить следующий запрос:
```
SELECT name AS real_estate, price, (SELECT AVG(price) FROM goods) AS avg_price FROM goods;
```

Стоит обратить внимание, что подзапрос (так называемый внутренний запрос) в нашем примере полностью независим от основного запроса (называемого внешним запросом) – можно запустить внутренний запрос самостоятельно и получить значимый результат.

**Многострочные подзапросы**

Если подзапрос возвращает более одной строки, то его можно назвать многострочным подзапросом. При этом такой тип подзапросов могут включать:

- подзапросы, которые возвращают один столбец с несколькими строками

- подзапросы, которые возвращают несколько столбцов с несколькими строками

Подзапросы, которые возвращают один и столбец строк, часто включаются в предложение WHERE для фильтрации результатов основного запроса. В таком случае они обычно используются с такими операторами, как IN, NOT IN, ANY, ALL, EXISTS или NOT EXISTS, которые позволяют сравнивать конкретное значение со значениями в списке, возвращаемым подзапросом.

Например, нам необходимо рассчитать среднее вознаграждение для менеджеров, которые не внесены в таблицу managers (например, работают на фрилансе). Для этого можно использовать следующий запрос с использованием подзапроса:
```
SELECT AVG(manager_fee) 
FROM sales_managers WHERE sales_managers.id NOT IN (SELECT managers.id FROM managers);
```

Внутренний запрос вернет список всех идентификаторов менеджеров. Затем внешний запрос отфильтровывает только тех менеджеров, которые работают на фрилансе, и вычисляет среднее вознаграждение, выплачиваемое им. Запрос возвращает единственное значение – среднее вознаграждение, выплачиваемое фрилансерам – 1885:

**Коррелированные подзапросы**

Существуют такие подзапросы SQL, в которых внутренний запрос опирается на информацию, полученную из внешнего запроса. Такие запросы называются коррелированными. Из-за взаимозависимости между основным запросом и внутренним запросом этот тип подзапроса может быть более сложным для понимания.

Коррелированные подзапросы обычно используются в операторах SELECT, WHERE и FROM.

Если мы хотим подсчитать количество товаров, в каждой из наших компаний, то можно использовать следующий запрос. Ниже представлен коррелированный подзапрос в SELECT:

SELECT city, (SELECT count(*) FROM goods as g 
WHERE c.id = g.company_id) as total_goods FROM companies c;
В данном случае подзапрос вернет скалярное значение с общим количеством товаров в соответствующей компании. Основной запрос отображает эту информацию вместе с городом, в котором находится компания.

В отличие от наших предыдущих примеров, здесь внутренний запрос зависит от внешнего запроса. Мы вытягиваем ID компании из таблицы companies, которая находится во внешнем запросе. Т.е., мы не можем запустить внутренний запрос, как независимый – запрос попросту выдаст ошибку.

Подведем небольшие итоги рассмотрения подзапросов:

1. Подзапрос – это просто оператор SELECT внутри другого запроса;
2. Подзапросы должны быть заключены в круглые скобки;
3. Псевдонимы подзапросов в списке столбцов, чтобы упростить чтение и ссылки на результаты;
4. Подзапрос возвращает либо одно значение, либо таблицу;
5. Подзапрос, который возвращает более одного значения, обычно используется там, где есть список значений, которые используются в IN;
6. Подзапросы могут быть очень неэффективными. Если есть иные способы получить тот же результат выборки, например, с использованием внутреннего соединения – то лучше выбрать этот вариант.

## 17. Что такое union?

https://job4j.ru/profile/exercise/179/task/976/395770

Операторы множества в SQL – это ключевые слова, которые позволяют объединить результаты двух и более запросов в один.

Существует несколько различных операторов множества, которые можно использовать в зависимости от наших потребностей и используемой системы управления базами данных (далее – СУБД).

В задании рассмотрим следующие операторы множества:

- UNION;
- UNION ALL;
- INTERSECT;
- EXCEPT.

```
SELECT first_select_query
set_operator
SELECT second_select_query;
```

Таким образом, операторы множества используют два и более запроса SELECT, при этом оператор множества ставится между запросами SELECT.

Однако есть некоторые ограничения, о которых необходимо обязательно помнить:

- при выборе столбцов в каждом из запросов SELECT количество столбцов должно совпадать;
- типы данных каждого из столбцов должны быть совместимыми;
- порядок столбцов в каждом из запросов SELECT должны быть одинаковыми.

Оператор множества UNION позволяет объединить результаты двух запросов. Этот оператор удаляет все повторяющиеся строки и показывает нам комбинацию обоих результатов выборок SELECT.

Оператор множества UNION ALL также объединяет результаты двух и более запросов. Однако в отличие от UNION, он не удаляет дубликаты

В чем же разница между UNION и UNION ALL? Основное различие между операторами заключается в том, что UNION удаляет все повторяющиеся результаты из окончательного набора результатов, а UNION ALL – нет. UNION выполняет DISTINCT для набора результатов, чтобы удалить дубликаты.

Таким образом, UNION ALL почти всегда будет показывать больше результатов, так как не удаляет повторяющиеся записи.

Стоит подчеркнуть, что UNION будет выполняться медленнее, чем UNION ALL, поскольку там присутствует операция по удалению повторяющихся значений (DISTINCT) – эта операция, как известно, является дорогостоящей частью запроса.

Таким образом, если нам не нужны уникальные строки в результирующем наборе или если мы уверены, что строки в базе данных или запросе уже уникальны, то стоит использовать UNION ALL.

## 18. Что такое group by?

https://job4j.ru/profile/exercise/52/task-view/340

GROUP BY – это оператор (или конструкция, кому как удобней) SQL для группировки данных по полю, при использовании в запросе агрегатных функций, таких как sum, max, min, count и других.
Как Вы знаете, агрегатные функции работают с набором значений, например sum суммирует все значения.

## 19. Что такое хранимые процедуры?

**Хранимая процедура** – это подпрограмма (она может принимать параметры), которая предназначена выполнять ряд операций с данными и структурами БД. Хранится на стороне БД и доступна как для вызова из других процедур и триггеров, а также может исполняться самостоятельно.

**Хранимая функция** – это подпрограмма (она может принимать параметры), которая расширяет возможности SQL и работает по аналогии со встроенными в СУБД функциям. При этом функция обязана возвращать значения.

Если говорить упрощенно, то хранимая процедура - это подпрограмма, которую можно вызвать напрямую или из других подпрограмм, и при этом она выполняет полезные действия. Функция же расширяет возможности СУБД и предназначена для упрощения повторяющихся операций.

Получается, что самое главное отличие в том, что функция обязана возвращать значение, процедура – нет (чаще всего она не имеет даже такой возможности). К тому же функцию можно использовать в любом SQL-запросе, в то время как работа с процедурами имеет особый синтаксис и ряд ограничений.

![image](https://github.com/artemaverin/summary/assets/97846877/c8795864-a85d-4db7-8bdf-fc9357682804)

Таким образом,  можем подытожить – функции мы используем тогда, когда в SQL-запросе нужно получить некоторое значение (можно привести аналогию со встроенными функциями например SUM(), AVG() и т.д.), а процедуры – когда нужно выполнить ряд сложных действий.

В качестве преимуществ можем выделить следующее:

- то, что требуется выполнить,  описывается один раз. Таким образом не нужно писать один и тот же код многократно;
- вызвать подпрограмму – короткая синтаксическая конструкция. Это намного упрощает читаемость кода;
- наши подпрограммы работают на стороне СУБД. Таким образом, не передаются никакие данные в приложение, значит мы повышаем производительность и безопасность.

Если говорить о недостатках, то они уже могут быть не так очевидны, поскольку мы можем работать с разными СУБД. Обозначим следующие недостатки:

- некоторое снижение производительности (если сравнивать с непосредственным выполнением кода, который мы поместили в подпрограмму);
- возможны проблемы с безопасностью (если на выполнение хранимой подпрограммы определенны неверные права);
- возможно усложнение тестирования и диагностики неполадок при использовании хранимых подпрограмм.

Однако стоит подчеркнуть – в общем и целом преимущества хранимых подпрограмм превышают их недостатки.

```
create or replace procedure insert_data(i_name varchar, prod varchar, i_count integer, i_price integer)
language 'plpgsql'
as $$
    BEGIN
    insert into products (name, producer, count, price)
    values (i_name, prod, i_count, i_price);
    END
$$;
```

```
call insert_data('product_2', 'producer_2', 15, 32);
```

## 20. Что такое view (Представление)?

https://job4j.ru/profile/exercise/179/task-view/787

представления - это другой тип таблиц, поскольку представления по умолчанию не существуют физически, т.е. их содержимое не сохраняется на диске.

**Представления (views)** – это объекты базы данных, которые всегда создаются на основе одной или более базовых таблиц (или других представлений), используя информацию метаданных. Эта информация (включая имя представления и способ получения строк из базовых таблиц) – все, что сохраняется физически для представления. Именно по этой причине представления также называют виртуальными таблицами. упрощенно, это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени.

**Материализованное представление** – это объект базы данных, значением которого является сохраненный результат заранее выполненного запроса, заданного при создании материализованного представления. Повторное вычисление и сохранение полученного результата происходит согласно правилам, которые определяются при создании материализованного представления.

В упрощенном виде – это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени, и результат выполнения этого запроса сохраняется для дальнейшего использования.

Таким образом, мы выяснили, что представления можно условно поделить на 2 типа:

- «обычные» представления, результат вычисления которых нигде не сохраняется;
- материализованные представления, результат вычисления которых сохраняется и может быть повторно использован.

Отразим эти различия следующим образом:

1. Представление:

- при создании представления просто фиксируется то, что с этого момента некоторый SQL-запрос можно не писать заново, а вызывать по заранее заданному имени.
- только при вызове этого запроса по его имени происходит (заново каждый раз) реальное чтение данных из таблиц, на которое ссылается представление.

**Материализованное представление:**

- при создании представления фиксируется то, что с этого момента некоторый SQL-запрос можно не писать заново, а вызывать по заранее заданному имени.
- результат выполнения запроса фиксируется во временном хранилище.
- обновление хранилища происходит согласно алгоритму, который указывается при создании представления.
- при вызове запроса чтение происходит из временного хранилища.

Мы уже определили, что представления строятся на основе SQL-запросов. Соответственно:

- основой для построения представления может быть только SELECT-запрос (т.е. нельзя построить представление на основе запросов с INSERT, UPDATE, DELETE);
- иногда представление допускает так называемые двунаправленные отношения, т.е. с его использованием можно будет не только читать данные, но и изменять их. В рамках нашего курса это не рассматривается.

**Преимущества:**

1. Упрощение выполнения запросов. Как мы уже обсудили, представление может быть построено на SQL-запросе любой сложности. Поэтому при использовании представлений нам уже не придется переписывать запрос, который может состоять даже из 100 строк. Нам будет достаточно вызвать представление SELECT * FROM представление и в итоге получить тот же результат;

2. Возможность построения простого и надежного API. На стадии проектирования БД мы можем предусмотреть набор удобных представлений, т.е. мы можем заранее скрыть от разработчика сложные запросы, что, в свою очередь, упростит разработку приложения и к тому же снизит количество ошибок при разработке.

3. Упрощение бизнес-логики. В принципе, это следует из предыдущего пункта. Однако даже если мы не строим полноценный API, мы все равно можем заранее сформировать набор для наиболее сложных и часто встречаемых запросов.

4. Минимум накладных расходов. Представление (это касается простых представлений) практически не занимает места в БД, потому даже создание сотен и тысяч представлений не приводит к ощутимому увеличению размера БД.

5. Безопасность. Представления являются объектами БД, потому к ним применимы все механизмы СУБД по контролю прав доступа.

**Недостатки:**

1. Избыточность. Иногда представления просто не нужны. Например, БД небольшая, бизнес-логика простая, модель безопасности тривиальная. В таком случае представления чаще всего будут лишними.

2. Дополнительный код. Представления, как и все остальное, необходимо создавать, что ведет за собой остальные операции – тестирование, корректировка при изменении БД или бизнес-логики. Соответственно, растут трудозатраты и повышается вероятность появления ошибок.

3. Ограниченность возможностей. Мы уже говорили, что представления можно использовать для модификации данных. Однако это имеет много ограничений, поэтому можно утверждать, что не любую операцию с БД можно выполнить с помощью представлений.

Создание представления
```
create view имя_представления as запрос_select
```

```
create view show_students_with_2_or_more_books
    as select s.name as student, count(a.name), a.name as author from students as s
         join orders o on s.id = o.student_id
         join books b on o.book_id = b.id
         join authors a on b.author_id = a.id
         group by (s.name, a.name) having count(a.name) >= 2;
```

Вызов представления
```
select * from show_students_with_2_or_more_books;
```

изменить представление

```
alter view старое_имя rename to новое_имя
```

Удалить представление

```
drop view имя_представления
```

## 21. Что такое JDBC?

JDBC – это API, т.е. набор вспомогательных классов, которое позволяет работать с базами данных. Причем JDBC предоставляет единый интерфейс для работы с ними, ведь бывают различные базы данных.

## 22. Что нужно для работы с той или иной БД?

Для работы с той или иной базой данных существует понятие драйвера. Драйвер – это то, что позволяет работать с бд (поддерживать подключения, выполнять запросы и т.д.). Для каждой БД есть свой драйвер. Чтобы добавить драйвер в проект необходимо добавить зависимость на этот самый драйвер.

## 23. Как зарегистрировать драйвер?

После добавления зависимости на драйвер, нам необходимо его зарегистрировать в системе. Чтобы это сделать необходимо прописать строку (полный код программы с данной строкой ниже по уроку):

```
Class.forName("org.postgresql.Driver");
```

## 24. Как получить Connection?

Для подключения нам нужны url, логин (имя пользователя) и пароль. Чтобы получить подключение нужно воспользоваться классом DriverManager, передав ему эти аргументы.

```
String url = "jdbc:postgresql://localhost:5432/idea_db";
String login = "postgres";
String password = "password";
try (Connection connection = DriverManager.getConnection(url, login, password)) {
```

Обратите внимание, что в url стоит префикс “jdbc:postgres”. Это указывает, что мы подключаемся к postgres через jdbc. Далее как обычно идет хост и порт, а за ними уже имя базы данных.

Хорошо, теперь мы получили объект типа Connection. Если он не равен null, то это значит, что установлено подключение и теперь мы можем выполнять запросы к базе данных.

Обратите внимание, что мы использовали Connection с try-with-resources. Вообще некоторые объекты jdbc, реализуют Autocloseable, поэтому нужно использовать их с try-with-resources.    

## 25.Что такое Statement, PreparedStatement? В чем разница между ними?

Для исполнения операций существуют специальные интерфейсы: Statement, PreparedStatement.

**Statement**

```
try (Connection connection = getConnection()) {
    try (Statement statement = connection.createStatement()) {
```

Пока мы просто создали объект для запроса. Для его выполнения существуют 3 метода: execute(), executeUpdate(), executeQuery(). При их вызове мы должны передать в качестве аргумента SQL - запрос. Разберём каждый метод подробнее.

**executeUpdate()**

Данный метод используется как для выполнения операторов управления данными (DML - операторы), например INSERT, UPDATE или DELETE, так и для операторов определения структуры базы данных (DDL - операторы), например CREATE TABLE, DROP TABLE. Возвращает int – количество affected строк, т.е. количество строк на которые оказал влияние запрос. Для операторов, которые не манипулируют строками, таких как CREATE TABLE или DROP TABLE, возвращаемое значение executeUpdate всегда равно нулю.                                                        

**executeQuery()**                                              

Как правило, этот метод используется для выполнения операции SELECT и возвращает объект ResultSet, который позволяет пройтись по результатам запроса.

**execute()**

Используется для выполнения любых команд. Возвращает true, если результатом выполнения является ResultSet (то есть был выполнен SELECT запрос) , или false, если результатом является int (количество изменённых строк). Получить ResultSet или количество строк мы можем с помощью последующего вызова getUpdateCount() или getResultSet().

Используем метод execute() для создания таблицы:

```
java
try (Connection connection = getConnection()) {
    try (Statement statement = connection.createStatement()) {
        String sql = String.format(
                "CREATE TABLE IF NOT EXISTS demo_table(%s, %s);",
                "id SERIAL PRIMARY KEY",
                "name TEXT"
        );
        statement.execute(sql);
```

**PreparedStatement**

С помощью объекта типа PreparedStatement можно вставлять аргументы в запрос. Во-первых, удобным образом, т.к. для вставки предназначены специальные методы. Во-вторых, безопасным способом, т.е. без возможности возникновения SQL injection (это когда наш код декомпилируют и меняют его, тем самым появляется возможность потери и утечки данных).

```
try (PreparedStatement statement = 
                     connection.prepareStatement("INSERT INTO cities(name, population) VALUES (?, ?)")) {
            statement.setString(1, city.getName());
            statement.setInt(2, city.getPopulation());
            statement.execute();
        } catch (Exception e) {
            e.printStackTrace();
        }
```

Основная особенность объекта PreparedStatement заключается в том, что при создании ему передается SQL - запрос с параметрами.

Обратите внимание. Во-первых, параметры, т.е. места куда будут подставляться аргументы обозначаются «?». Во-вторых, для подстановки аргументов используются методы вида “setТип(позиция, аргумент)”. В-третьих, позиция аргумента считается как его порядковый номер, а не как индекс, т.е. позиции аргументов начинаются с 1.

Также важно запомнить, что методы execute(), executeUpdate() и executeQuery() интерфейса PreparedStatement не принимают никаких аргументов, в отличие от одноименных методов Statement. Они выполняют указанный при создании объекта SQL-запрос с подставленными аргументами. 


**Отличие**

Главной отличительной чертой интерфейса PreparedStatement является то, что он используется для выполнения параметризованных SQL-запросов.

## 26. Что такое ResultSet?

Класс ResultSet представляет результирующий набор данных и обеспечивает приложению построчный доступ к результатам запросов. При обработке запроса ResultSet поддерживает указатель на текущую обрабатываемую строку.
Доступ к данным ResultSet обеспечивает посредством набора get-методов, которые организуют доступ к колонкам текущей строки. Метод ResultSet.next используется для перемещения к следующей строке ResultSet, делая ее текущей.

Statment.execute()

Используется для выполнения любых команд. Возвращает true, если результатом выполнения является ResultSet (то есть был выполнен SELECT запрос) , или false, если результатом является int (количество изменённых строк). Получить ResultSet или количество строк мы можем с помощью последующего вызова getUpdateCount() или getResultSet().

```
statement.execute(sql);
int count = statement.getUpdateCount();
/* эквивалентно */
int count = statement.executeUpdate(sql);

statement.execute(sql);
ResultSet result = statement.getResultSet();
/* эквивалентно */
ResultSet result = statement.executeQuery(sql);
```

## 27. В чем разница между методами execute, executeUpdate, executeQuery?

**executeUpdate()**

Данный метод используется как для выполнения операторов управления данными (DML - операторы), например INSERT, UPDATE или DELETE, так и для операторов определения структуры базы данных (DDL - операторы), например CREATE TABLE, DROP TABLE. Возвращает int – количество affected строк, т.е. количество строк на которые оказал влияние запрос. Для операторов, которые не манипулируют строками, таких как CREATE TABLE или DROP TABLE, возвращаемое значение executeUpdate всегда равно нулю.                                                        

**executeQuery()**                                              

Как правило, этот метод используется для выполнения операции SELECT и возвращает объект ResultSet, который позволяет пройтись по результатам запроса.

**execute()**

Используется для выполнения любых команд. Возвращает true, если результатом выполнения является ResultSet (то есть был выполнен SELECT запрос) , или false, если результатом является int (количество изменённых строк). Получить ResultSet или количество строк мы можем с помощью последующего вызова getUpdateCount() или getResultSet().

- -----------------------------------------------

Методы execute, executeUpdate и executeQuery являются методами интерфейса PreparedStatement в Java. Они используются для выполнения SQL-запросов к базе данных.

Вот в чем разница между ними:

execute: Этот метод используется для выполнения подготовленного SQL-запроса. Он в основном используется, когда вы хотите выполнить SQL-запросы, которые возвращают результаты (например, SELECT, CALL, EXECUTE). Этот метод возвращает объект ResultSet, который можно использовать для получения результатов запроса.
executeUpdate: Этот метод выполняет SQL-запрос, который не возвращает результаты. Он обычно используется для выполнения команд DML (например, INSERT, UPDATE, DELETE). Этот метод не возвращает ResultSet, а вместо этого возвращает количество затронутых записей.
executeQuery: Этот метод аналогичен execute, но он всегда возвращает объект ResultSet независимо от того, возвращает ли SQL-запрос результаты или нет. Это может быть полезно, если вы хотите выполнить различные типы SQL-запросов внутри одного метода.

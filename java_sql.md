## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).](#6-Опишите-как-вставить-удалить-обновить-данные-в(из)-таблицу(ы))

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

## 1. Что такое SQL?
SQL - это декларативный язык программирования, который используется для создания, модификации и управления данными в реляционной БД, управляемой системой управления базами данных (СУБД). С помощью SQL-запросов можно добавлять, изменять, получать или удалять данные из БД.

## 2. Что такое DML и DDL?
![image](https://github.com/artemaverin/summary/assets/97846877/3bd0357e-64ec-4edf-98fb-be075f6e041c)

Операции бывают двух видов: над структурой данных и над самими данными. К первым относятся операции, касающиеся создания, удаления, изменения и т.д. таблиц и баз данных. Ко вторым относятся создание, удаление, получение, обновление самих данных. В профильной литературе можно встретить понятия DDL и DML. 

DDL – Data Definition Language, характеризует операции над структурой данных.

DML – Data Manipulation Language, представляет операции над самими данными.

## 3. Что такое первичный ключ?
первичный ключ (primary key) - это поле в таблице, однозначно идентифицирующее каждую строку (запись) в таблице БД. Первичный ключ должен содержать уникальные значения. Также не может содержать null. В таблице может быть только один первичный ключ. Ключ может состоять из одного и более полей. Первичный ключ, состоящий из нескольких полей, называется составным ключом.

Первичный ключ выбирается так, чтобы он состоял из минимально возможного количества полей. Например, если есть поля "имя", "фамилия", "дата рождения" и "номер телефона", нет смысла делать составной ключ из нескольких полей, так как имеется поле "номер телефона", и по нему одному мы можем в будущем уникально идентифицировать записи, так как номер телефона не может повторяться.

Так как в реляционных БД все таблицы почти всегда связаны друг с другом, первичные ключи используются для однозначной организации этой связи.

## 4. Что такое внешний ключ?

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

## 5. Какие виды связей между таблицами существуют и как они организуются?

**many-to-one и one-to-many**

Пример:

Должность и Сотрудник. Одну должность могут иметь несколько сотрудников, причем сотрудник может иметь одну должность. 

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Особое внимание стоит уделить столбцу position_id. Для связи таблиц между собой используется ключевое слово REFERENCES. Это значит, что значения данного столбца - значения связываемой таблицы. В данном случае это можно трактовать как столбец position_id содержит значения из таблицы positions, а именно из столбца id. Общий синтаксис связи при создании таблицы выглядит следующим образом:

имя_столбца тип REFERENCES связываемая_таб(столбец_св_табл)

Слово REFERENCES с английского переводится как "ссылается". Что это значит? При выполнении запроса извлечения всех работников видим, что в таблице position_id стоит какое-то значение. Мы можем перейти к соответствующей таблице, на которую ссылаемся, и найти запись по этому столбцу. Таким образом, мы как бы «переходим» по ссылке. Через SQL это записано последним запросом.

![image](https://github.com/artemaverin/summary/assets/97846877/d09061fa-36aa-488a-97c3-974422840f98)

Обратите внимание, что стрелка идет от сущности, которая many, к сущности, которая one. Либо же можно рассуждать так: где у нас стоит REFERENCES связь начинается, а стрелка будет указывать на сущность, на которую мы ссылаемся.

**many-to-many**

Пример:

Человек и Курс. Человек может проходить много курсов (one-to-many), в то же время курс могут проходить много человек (many-to-one).

Данная связь организуется с помощью вспомогательной таблицы, т.к. на уровне БД мы имеем только связь many-to-one.

![image](https://github.com/artemaverin/summary/assets/97846877/100ab40a-1180-4e3b-b169-5b4f4d5934dd)

Как видно по коду, здесь идет двойное применение REFERENCES, т.е. у нас есть два внешних ключа во вспомогательной таблице. Один ссылается на таблицу курсов, другой на таблицу людей.

**one-to-one**

Пример:

Очевидно, что паспорт и человек, это связь один к одному. У каждого человека есть только один паспорт. У паспорта может быть только один владелец.

Организуется эта связь немного сложнее, чем первые две. В первую очередь тут стоит задать вопрос: какую связь мы хотим? Однонаправленную (unidirectional) или двунаправленную (bidirectional)? Т.е. как мы хотим извлекать данные? В контексте примера: мы хотим по паспорту получать человека или наоборот? Или и так и так?

Если нам нужно получать паспорт по человеку, то мы можем поступить так

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255),
    passport_id int references passport(id) unique
);
```

Обратите внимание, что рядом с внешним ключом стоит unique. Это значит, что данное значение уникально среди всех записей данного столбца. Без этого ограничения(constraint) мы получим связь many-to-one. Теперь по записи в таблице людей мы можем перейти в таблицу паспорта для уточнения данных. Аналогично мы могли бы поступить в случае, если бы нам нужно было получать человека по паспорту. Такая организация связи является однонаправленной. Обратите внимание, что на связи указано 1, это значит, что связь один-к-одному, мы не можем писать unique, т.к. это относится к спецификации БД.

![image](https://github.com/artemaverin/summary/assets/97846877/674e1b19-41d1-450c-b41a-f05b1a5914c8)

Если нам нужно получать данные и так, и так (человека по паспорту и паспорт по человеку), то мы можем сделать так:

```
create table passport(
    id serial primary key,
    seria int,
    number int
);

create table people(
    id serial primary key,
    name varchar(255)
);

create table passport_people(
    id serial primary key,
    passport_id int references passport(id) unique,
    people_id int references people(id) unique
);
```

Данный способ использует, как и many-to-many, вспомогательную таблицу, но опять же используется ограничения на внешние ключи unique. Иначе мы получим связь many-to-many - как на рисунке ниже - обратите внимание, над связями нет символов "1".  

![image](https://github.com/artemaverin/summary/assets/97846877/951b8949-1f44-4ee7-a052-a742bba07bf5)

## 6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).

Для того, чтобы создать таблицы в простейшем виде, можно использовать подобный синтаксис:

create table имя_таблицы(

      id serial primary key,

      имя_атрибута1 тип_данных,

      имя_атрибутаN тип_данных

);

указание id является обязательным, ключевые слова primary key говорят о том, что данный атрибут является идентификатором. Во-вторых, используется ключевое слово serial, что значит, что генерацией id будет заниматься БД, причем генерироваться он будет последовательно, т.е. 1, 2, 3 и т.д.

**Вставка данных**

Как создать структуру - разобрались. Давайте теперь вставим данные в БД. Синтаксис следующий:

insert into имя_таблицы(имя_атр1, имя_атрN) values(значение_атр1, значение_атрN);

**Обновление данных**

Для обновления данных используется оператор update. Синтаксис такой:

update имя_таблицы set имя_атр1 = зн_атр1, имя_атрN = зн_атрN;

*Обратите внимание*, что если выполнить эту команду без условия, то обновятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

**Удаление данных**

Чтобы удалить данные, нужно использовать оператор delete. Синтаксис такой:

delete from имя_таблицы;

*Обратите внимание*, что если выполнить эту команду без условия, то удалятся все данные. Пока выполняйте ее в таком в виде, об условиях поговорим в следующих уроках.

## 7. Что такое нормализация БД?

https://job4j.ru/profile/exercise/179/task-view/819

Нормализация БД – это процесс организации данных определенным образом и рекомендации по проектированию. Т.е. таблицы и связи между ними (отношения) создаются в соответствии с правилами. В результате обеспечивается некоторый уровень безопасности данных. К тому же устраняются несогласованные зависимости и избыточность.

Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.

избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управление данными не гибким и не очень удобным. Отсюда можно сделать вывод, что нормализация нужна для:

- Устранения аномалий
- Повышения производительности
- Повышения удобства управления данными

Нормальная форма базы данных – это набор правил и критериев, которым должна отвечать база данных.

Процесс нормализации – это последовательный процесс приведения базы данных к эталонному виду, т.е. переход от одной нормальной формы к следующей.

* Ненормализованная форма или нулевая нормальная форма (UNF)
* Первая нормальная форма (1NF)
* Вторая нормальная форма (2NF)
* Третья нормальная форма (3NF)
* Нормальная форма Бойса-Кодда (BCNF)
* Четвертая нормальная форма (4NF)
* Пятая нормальная форма (5NF)
* Доменно-ключевая нормальная форма (DKNF)
* Шестая нормальная форма (6NF)

**первая нормальная форма (1NF)**

Переменная отношения находится в первой нормальной форме (далее – 1НФ) тогда и только тогда, когда каждый атрибут отношения содержит строго одно атомарное значение.

Если упростить, то можно сказать, что каждый атрибут отношения атомарен (неделим) и система управления БД (далее - СУБД) не должна оперировать отдельной частью атрибута.

https://info-comp.ru/first-normal-form

Требование первой нормальной формы (1NF) очень простое и оно заключается в том, чтобы таблицы соответствовали реляционной модели данных и соблюдали определённые реляционные принципы.

Таким образом, чтобы база данных находилась в 1 нормальной форме, необходимо чтобы ее таблицы соблюдали следующие реляционные принципы:

- В таблице не должно быть дублирующих строк
- В каждой ячейке таблицы хранится атомарное значение (одно не составное значение)
- В столбце хранятся данные одного типа
- Отсутствуют массивы и списки в любом виде

Правило: **Строки, столбцы и ячейки в таблицах необходимо использовать строго по назначению.**

* Назначение строк – хранить данные
* Назначение столбцов – хранить структурную информацию
* Назначение ячеек – хранить атомарное значение

**вторая нормальная форма (2NF)**

Переменная отношения находится во второй нормальной форме (далее – 2НФ) тогда и только тогда, когда она находится в 1НФ и каждый ее неключевой атрибут функционально полно зависит от любого потенциального ключа.

Т.е. ни один атрибут, не входящий в состав потенциального ключа, не должен функционально зависеть от части какого бы то ни было из потенциальных ключей.

https://info-comp.ru/second-normal-form

Чтобы база данных находилась во второй нормальной форме (2NF), необходимо чтобы ее таблицы удовлетворяли следующим требованиям:

- Таблица должна находиться в первой нормальной форме
- Таблица должна иметь ключ
- Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)

Если ключ составной, т.е. состоит из нескольких столбцов, то все остальные неключевые столбцы должны зависеть от всего ключа, т.е. от всех столбцов в этом ключе. Если какой-то атрибут (столбец) зависит только от одного столбца в ключе, значит, база данных не находится во второй нормальной форме.

Иными словами, в таблице не должно быть данных, которые можно получить, зная только половину ключа, т.е. только один столбец из составного ключа.

Главное правило второй нормальной формы (2NF) звучит следующим образом
```
Таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку.
```

**третья нормальная форма (3NF)**

Переменная отношения находится в третьей нормальной форме (далее – 3НФ) тогда и только тогда, когда она находится во второй нормальной форме, и каждый ее неключевой атрибут нетранзитивно зависит от первичного ключа. Т.е. в отношении не должно быть атрибутов, которые не входят в состав первичного ключа и при этом транзитивно зависящих от первичного ключа.

https://info-comp.ru/third-normal-form

Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.

Транзитивная зависимость – это когда неключевые столбцы зависят от значений других неключевых столбцов.

Если: 
- в первой нормальной форме наше внимание было нацелено на ***соблюдение реляционных принципов***, 
- во второй нормальной форме в центре нашего внимания был ***первичный ключ***,
- то в третьей нормальной форме все наше внимание уделено ***столбцам***, которые ***не являются первичным ключом***, т.е. неключевым столбцам.

Иными словами, неключевые столбцы не должны пытаться играть роль ключа в таблице, т.е. они действительно должны быть неключевыми столбцами, такие столбцы не дают возможности получить данные из других столбцов, они дают возможность посмотреть на информацию, которая в них содержится, так как в этом их назначение.

Главное правило третьей нормальной форме (3NF) звучит следующим образом:

```
Таблица должна содержать правильные неключевые столбцы
```

***Нормальная форма Бойса-Кодда (BCNF)***

https://info-comp.ru/boyes-codd-normal-form

Требования нормальной формы Бойса-Кодда следующие:

- Таблица должна находиться в третьей нормальной форме. Здесь все как обычно, т.е. как и у всех остальных нормальных форм, первое требование заключается в том, чтобы таблица находилась в предыдущей нормальной форме, в данном случае в третьей нормальной форме;
- Ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов.
- 
Отсюда следует, что требования нормальной формы Бойса-Кодда предъявляются только к таблицам, у которых первичный ключ составной. Таблицы, у которых первичный ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной форме Бойса-Кодда.

Главное правило нормальной формы Бойса-Кодда (BCNF) звучит следующим образом:
```
Часть составного первичного ключа не должна зависеть от неключевого столбца.
```

#конспект по Numpy с ютуб-канала selfedu https://www.youtube.com/watch?v=KaT3aPjjx1A&list=PLA0M1Bcd0w8zmegfAUfFMiACPKfdW4ifD&index=2

=[КОНСПЕКТ НА САЙТЕ](https://proproprogs.ru/modules/numpy-ustanovka-i-pervoe-znakomstvo)=

# Оглавление
1. [Основные типы данных. Создание массивов функцией array()](#основные-типы-данных-создание-массивов-функцией-array)
2. [Функции автозаполнения, создания матриц и числовых диапазонов](#функции-автозаполнения-создания-матриц-и-числовых-диапазонов)

### Основные типы данных. Создание массивов функцией array()

Numpy поддерживает огромное количество различных типов данных, ознакомиться со всем списком можно применив функцию
```python
np.sctypeDict
```

Создавая массив мы явно можем задать нужный тип
```python
m = np.array([1, 2, 3, 4], dtype='float64')
print(m)
Вывод:
[1. 2. 3. 4.]
```
Массив можно привести к необходимому типу данных передав его в параметр нужного  объекта-типа. Данная процедура вернет копию изначального массива, оригинальный массив не изменится

```python
m = np.array([1, 2, 3, 4], dtype='float64')
b = np.complex64(m)
print(b)
Вывод:
[1.+0.j 2.+0.j 3.+0.j 4.+0.j]
```

Массив можно создать передавая список ,картеж или одиночный объект
```python
m = np.array([1, 2, 3, 4])
[1 2 3 4]
m2 = np.array((1,2 ,3))
[1 2 3]
m3 = np.array('Hello')
Hello
```

Стоит также помнить, что можно передавать и двумерный массив и трехмерных , но важно чтобы эти матрица были прямоугольными, а не неравномерными списками
```python
# пример с ошибкой
m = np.array([[1, 2], [3, 4], [4, 5, 6]])
Вывод:ValueError: setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (3,) + inhomogeneous part.
```

Обращаться к элементам массива (в зависимости от размерности) можно так:

```python
# для трехмерного
m[0][1][0]
m[0, 1, 0]
#для двумерного
m[0][1]
m[0, 1]
```

### Функции автозаполнения, создания матриц и числовых диапазонов
[Функции автозаполнения, создания матриц и числовых диапазонов](https://proproprogs.ru/modules/numpy-funkcii-avtozapolneniya-sozdaniya-matric-i-chislovyh-diapazonov)

Часто в инженерных задачах требуется определять векторы или матрицы с типовым набором значений, например, состоящих из нулей или единиц, или определение диагональной и единичной матриц и так далее. Конечно, мы можем все это сделать также через функцию array, используя механизм генерации списков, например, так:
```python
np.array( [0]*10 )  # массив из 10 нулей
np.array( [1]*15 )  # массив из 15 единиц
np.array( [x for x in range(10)] ) # массив из чисел от 0  до 9
```
Но есть более быстрые способы (по скорости выполнения) создания подобных массивов. Для этого в NumPyимеются полезные функции, которые мы сейчас рассмотрим.
|Название|Описание|
|-----------|--------|
|empty(shape, …)   |Возвращает новый массив заданного размера и типа данных, но без определенных значений.|
|eye(N, M=None, …)   |Возвращает массив размером NxMс единичными диагональными элементами (остальные элементы равны нулю).|
|identity(n, …)   |Возвращает квадратный массив размерностью nxn с единичными элементами по главной диагонали (остальные равны нулю).|
|ones(shape, …)   |Возвращает массив заданного размера и типа, состоящего из всех единиц.|
|zeros(shape, …)   |Возвращает массив заданного размера и типа, состоящего из всех нулей.|
|full(shape, value, …)   |Возвращает массив заданного размера и типа со значениями value.|

Это только часть основных функций для создания массивов с заданными значениями. Использовать их достаточно просто. Например, так:
```python
np.empty(10) # создание одномерного массива с произвольными числами
[ 1.05438828e+251 -1.06828554e-149  9.69878380e+173  9.63119631e-244
  1.16356587e-099  2.22112548e+068  1.17567364e+214  9.10016855e+276
  9.08366791e+223  7.07430660e+170]
  
np.empty(10, dtype='int16')
[-11920 -22370    601      0 -11824 -22370    601      0   8296  24950]

np.empty((3, 2), dtype='float32') # возвращаетматрицу 3x2 стипомfloat32
[[6.8608197e+22 7.6196602e+31]
 [2.7489706e+20 1.3555975e-19]
 [1.3563156e-19 1.3563156e-19]]
```

Для функций eye и identity размерности указываются отдельными параметрами:
```python
np.eye(4)    # матрица 4х4
[[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 1.]]
 
np.eye(4, 2)         # матрица 4x2
[[1. 0.]
 [0. 1.]
 [0. 0.]
 [0. 0.]]
 
np.identity(5) # матрица 5x5
[[1. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0.]
 [0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 1.]]
```

Функции ones, zeros и full работают по аналогии с функцией empty:
```python
np.zeros( (2, 3, 4) ) # нулевая матрица размерностью 2x3x4
[[[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]]
  
np.ones( [4, 3], dtype='int8') # матрица 4x3 из единиц и типом int8
[[1 1 1]
 [1 1 1]
 [1 1 1]
 [1 1 1]]
 
np.full((3, 2), -1) # матрица 3x2, состоящая из -1
[[-1 -1]
 [-1 -1]
 [-1 -1]]
```

Все эти функции работают быстрее, чем функция array с генератором списков языка Python. Поэтому их предпочтительно использовать при создании и инициализации массивов определенными значениями.
Функции создания матриц
Следующий полезный набор функций позволяет генерировать матрицы на основе списков или по определенным правилам.
|Название|Описание|
|-----------|--------|
|mat(object, …)|Приводит входные данные object к матрице, если это возможно. Параметр object может быть строкой, списком или кортежем.|
|diag(list, …)|Формирует диагональную матрицу на основе списка или массива NumPy. В последних версиях возвращает копию массива (а не его представление).|
|diagflat(list, …)|Формирует диагональную матрицу из списка list, который сначала сжимает до одной оси (преобразует в одномерный список или массив).|
|tri(N, M=None, …)|Создает треугольный массив NxM с единицами на главной диагонали и ниже ее.|
|tril(list, …)|Преобразует двумерный список или массив list в треугольную матрицу с нулевыми элементами выше главной диагонали.|
|triu(list, …)|Преобразует двумерный список или массив list в треугольную матрицу с нулевыми элементами ниже главной диагонали.|
|vander(list, N=None, …)|Создание матрицы Вандермонда из одномерного списка или массива list. Второй параметр N определяет число столбцов (по умолчанию формируется квадратная матрица).|

Давайте посмотрим как работают эти функции.
```python
np.mat('1 2 3 4') # создает матрицу 1x4 из строки
[[1 2 3 4]]

np.mat('1, 2, 3, 4') # то же самое: создает матрицу 1x4 из строки
[[1 2 3 4]]

np.mat('1 2; 3 4') # возвращает матрицу 2x2
[[1 2]
 [3 4]]
 ```
 
 Или же, вместо строк можно использовать список или кортеж:
```python
np.mat([5, 4, 3])
[[5 4 3]]

np.mat( [(1,2,3), (4,5,6)])
[[1 2 3]
 [4 5 6]]
 ```
 Но, если из переданных данных нельзя сформировать прямоугольную таблицу (матрицу), то произойдет ошибка:
```python
np.mat( [(1,2,3), (4,5,6,7)])# ошибка, размерности не совпадают
```
Следующая функция позволяет формировать диагональные матрицы:
```python
np.diag([1, 2, 3]) # диагональная матрица 3x3
[[1 0 0]
 [0 2 0]
 [0 0 3]]
```

Но, если ей передать двумерный список, то она возвратит одномерный массив из элементов, стоящих на главной диагонали:
```python
np.diag([(1,2,3), (4,5,6), (7,8,9)]) # выделение элементов главной диагонали
```

Если же мы хотим сформировать диагональную матрицу из многомерных списков или массивов, то следует воспользоваться функцией
```python
np.diagflat([(1,2,3), (4,5,6), (7,8,9)])
[[1 0 0 0 0 0 0 0 0]
 [0 2 0 0 0 0 0 0 0]
 [0 0 3 0 0 0 0 0 0]
 [0 0 0 4 0 0 0 0 0]
 [0 0 0 0 5 0 0 0 0]
 [0 0 0 0 0 6 0 0 0]
 [0 0 0 0 0 0 7 0 0]
 [0 0 0 0 0 0 0 8 0]
 [0 0 0 0 0 0 0 0 9]]
```

Следующий набор функций используются для формирования треугольных матриц. Например:
```python
np.tri(4) # треугольная матрица 4x4
[[1. 0. 0. 0.]
 [1. 1. 0. 0.]
 [1. 1. 1. 0.]
 [1. 1. 1. 1.]]
 
np.tri(4, 2) # треугольная матрица 4x2
[[1. 0.]
 [1. 1.]
 [1. 1.]
 [1. 1.]]
```
Если нужно привести уже существующие матрицы к треугольному виду, то это можно сделать так:
```python
a = np.array( [(1,2,3), (4,5,6), (7,8,9)] )
np.tril(a) # нижняя треугольная матрица размером 3x3
[[1 0 0]
 [4 5 0]
 [7 8 9]]
 
np.triu(a) # верхняя треугольная матрица размером 3x3
[[1 2 3]
 [0 5 6]
 [0 0 9]]
```

Если указать одномерный список:
```python
np.tril([1,2,3])
[[1 0 0]
 [1 2 0]
 [1 2 3]]
```

Также функции tril и triu будут работать и с многомерными массивами:
```python
np.tril([[[1,2,3], [4,5,6], [7,8,9]]])
[[[1 0 0]
  [4 5 0]
  [7 8 9]]]
  
np.tril([[[1,2,3], [4,5,6], [7,8,9]], [[10,20,30], [40,50,60], [70,80,90]], [[100,200,300], [400,500,600], [700,800,900]]])
[[[  1   0   0]
  [  4   5   0]
  [  7   8   9]]

 [[ 10   0   0]
  [ 40  50   0]
  [ 70  80  90]]

 [[100   0   0]
  [400 500   0]
  [700 800 900]]]
  ```
  В этом случае последние двумерные сечения будут приведены к треугольному виду.

Последняя функция этойгруппы формирует матрицу Вандермонда из одномерных списков или массивов:
```python
np.vander([1,2,3]) # матрица Вандермонда 3x3
[[1 1 1]
 [4 2 1]
 [9 3 1]]
```
#### Функции формирования числовых диапазонов
Следующая группа функций, которые мы рассмотрим на этом занятии, служит для формирования числовых диапазонов. Что делают эти функции? Когда мы с вами изучали язык Python, то говорили о функции
***range(Start, Stop, Step)***
которая генерирует числовой диапазон с параметрами Start, Stop, Step. Причем, все эти параметры должны быть целочисленными. В NumPy есть подобные функции, но более гибкие и работающие с вещественными величинами.
|Название|Описание|
|-----------|--------|
|arange()|Возвращает одномерный массив с равномерно разнесенными числами указанного диапазона.|
|linspace(start, stop, …)|Возвращает одномерный массивcравномерно разнесенными числами, используя только значения начала и конца интервала.|
|logspace(start, stop, …)|Возвращает одномерный массив с числами, равномерно распределенных по логарифмической шкале.|
|geomspace(start, stop, …)|Формирование чисел по геометрической прогрессии.|
|meshgrid(x1, ..., xn, …)|x1, ..., xn – одномерные последовательности или массивы, используемые для формирования координатной сетки по каждой из осей.|
|mgrid[]|Возвращает массив плотных координатных сеток.|
|ogrid[]|Возвращает открытую сетку значений.|

```python
np.arange(5)# интервал [0; 5) с шагом 1
[0 1 2 3 4]

np.arange(1, 5)# интервал [1; 5) с шагом 1
[1 2 3 4]

np.arange(1, 5, 0.5) # интервал [1; 5) с шагом 0,5
[1.  1.5 2.  2.5 3.  3.5 4.  4.5]
```
Обратите внимание, в отличие от функции range языка Python в arrange пакета NumPy можно указывать вещественные значения. Вот еще один пример, демонстрирующий это:
```python
np.arange(0, np.pi, 0.1)
[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.  1.1 1.2 1.3 1.4 1.5 1.6 1.7
 1.8 1.9 2.  2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.  3.1]
 ```
 Здесь все величины вещественные. Мы начинаем движение от значения 0 с шагом 0,1 пока не дойдем до значения пи (не включая его). И, далее, используя этот массив, можно вычислить синус или косинус от всех этих значений:
 ```python
np.cos(np.arange(0, np.pi, 0.1))
[ 1.          0.99500417  0.98006658  0.95533649  0.92106099  0.87758256
  0.82533561  0.76484219  0.69670671  0.62160997  0.54030231  0.45359612
  0.36235775  0.26749883  0.16996714  0.0707372  -0.02919952 -0.12884449
 -0.22720209 -0.32328957 -0.41614684 -0.5048461  -0.58850112 -0.66627602
 -0.73739372 -0.80114362 -0.85688875 -0.90407214 -0.94222234 -0.97095817
 -0.9899925  -0.99913515]
 ```
 Видите, как это удобно. Без пакета NumPyнам пришлось бы писать цикл и делать вычисление для каждого значения аргумента. А здесь мы сразу получаем готовый массив значений функции косинуса. Это работает гораздо быстрее циклов в Python.

Похожим образом работает и функция linspace. Она разбивает указанный интервал на равномерные отрезки и возвращает массив этих значений:\
![](https://proproprogs.ru/htm/modules/files/numpy-funkcii-avtozapolneniya-sozdaniya-matric-i-chislovyh-diapazonov.files/image001.png)

Мы указываем в качестве аргументов интервал [start; stop] и число отметок в этом интервале n. Если n = 0, то получим пустой массив. При n = 1 – значение start. При n = 2 – значения start и stop. При n> 2 равномерное разбиение интервала точками m = n-2. Например:
```python
np.linspace(0, np.pi, 0) # пустой массив
[]

np.linspace(0, np.pi, 1) # одно значение 0
[0.]

np.linspace(0, np.pi, 2) # два значения: 0 и pi
[0.         3.14159265]

np.linspace(0, np.pi, 3) # три значения: 0, pi/2, pi
[0.         1.57079633 3.14159265]
```

В чем отличие linspace от arange? В arange мы указываем сами шаг движения по числовой оси. При этом число значений определяется граничными значениями. А в linspace мы задаем граничные значения и число делений, а шаг вычисляется автоматически.

Функции logspace и geomspace работают аналогичным образом. У них указываются граничные значения и число членов, а на выходе имеем массив из соответствующих величин. Например:
```python
np.logspace(0, 1, 3) # значения: 1, sqrt(10), 10
[ 1.          3.16227766 10.        ]

np.logspace(0, 1, 4) # значения: 1, 2.15, 4.64, 10
 [ 1.          2.15443469  4.64158883 10.        ]
 
np.geomspace(1, 4, 3) # значения: 1, 2, 4
[1. 2. 4.]

np.geomspace(1, 16, 5) # значения: 1, 2, 4, 8, 16
[ 1.  2.  4.  8. 16.]
```
Остальные функции этой группы используются при построении графиков и мы их рассмотрим, когда будем рассматривать построение графиков с помощью библиотеки matplotlib.

#### Функции формирования массивов на основе данных
Рассмотрим следующую группу, связанную с формированием на основе уже имеющихся данных.

# System analytic FAQ

## Требования

[1. Какие виды требований вы знаете?](#1-Какие-виды-требований-вы-знаете)

[2. Что такое функциональные требования?](#2-Что-такое-функциональные-требования)

[3. Что такое НЕфункциональные требования?](#3-Что-такое-НЕфункциональные-требования)

[4. Критерии требований](#4-Критерии-требований)

[5. Заинтересованные лица (стейкхолдеры) - кто это и как с ними взаимодействовать?](#5-Заинтересованные-лица-(стейкхолдеры)-кто-это-и-как-с-ними-взаимодействовать)

[6. User story и Use case](#6-User-story-и-Use-case)

[7. Какие существуют техники сбора требований?](#7-Какие-существуют-техники-сбора-требований)

## Нотации UML и BPMN

[8. Какими нотациями вы владеете?](#8-Какими-нотациями-вы-владеете)

[9. Какие бывают виды UML диаграм?](#9-Какие-бывают-виды-UML-диаграм)

[10. Какие бывают виды BPMN диаграм?](#10-Какие-бывают-виды-BPMN-диаграм)

[11. Составьте схему BPMN для процесса, описывающего работу банкомата](#11-Составьте-схему-BPMN-для-процесса-описывающего-работу-банкомата)

[12. Какие бывают Gateway в BPMN?](#12-Какие-бывают-Gateway-в-BPMN)

[13. Какие элементы BPMN вы знаете?](#13-Какие-элементы-BPMN-вы-знаете)

## SQL и базы данных

[14. Зачем нужны индексы в таблицах БД?](#14-Зачем-нужны-индексы-в-таблицах-БД)

[15. Знакомы ли вы с нормализацией баз данных?](#15-Знакомы-ли-вы-с-нормализацией-баз-данных)

[16. Какие виды JOIN запросов вы знаете?](#16-Какие-виды-JOIN-запросов-вы-знаете)

[17. Чем TRANCATE отличается от DELETE?](#17-Чем-TRANCATE-отличается-от-DELETE)

[18. Что такое транзакция?](#18-Что-такое-транзакция)

[19. Какими свойствами должна обладать транзакция? (ACID)](#19-Какими-свойствами-должна-обладать-транзакция-ACID)

[20. Чем отличается UNION от UNION ALL?](#20-Чем-отличается-UNION-от-UNION-ALL)

[21. Что такое первичный ключ?](#21-Что-такое-первичный-ключ)

[22. Что такое внешний ключ?](#22-Что-такое-внешний-ключ)

[23. Какие бывают представления в БД?](#23-Какие-бывают-представления-в-БД)

[24. Для чего используется HAVING в SQL?](#24-Для-чего-используется-HAVING-в-SQL)

[25. Какие бывают БД?](#25-Какие-бывают-БД)

## Интеграция

[27. Что такое XML и что в нем содержится?](#27-Что-такое-XML-и-что-в-нем-содержится)

[26. Что такое XSD?](#26-Что-такое-XSD)

[28. Чем sequence отличается от choice в XSD?](#28-Чем-sequence-отличается-от-choice-в-XSD)

[29. Что такое пространство имен в XML?](#29-Что-такое-пространство-имен-в-XML)

[30. Что такое WSDL?](#30-Что-такое-WSDL)

[31. Чем SOAP отличается от REST?](#31-Чем-SOAP-отличается-от-REST)

[32. Из чего состоит сообщение в SOAP?](#32-Из-чего-состоит-сообщение-в-SOAP)

[33. Что содержит HEADER в ответе REST?](#33-Что-содержит-HEADER-в-ответе-REST)

[34. Чем отличается ошибка 200 от 201?](#34-Чем-отличается-ошибка-200-от-201)

[35. Какие методы REST вы знаете?](#35-Какие-методы-REST-вы-знаете)

[36. Напишите пример rest-API для книжной библиотеки (напишите методы, эндпоинты и пример JSON)](#36-Напишите-пример-rest-API-для-книжной-библиотеки)


[6. Чем Kanban отличается от Scrum?](#6-Чем-Kanban-отличается-от-Scrum)

[7. Какие бывают подходы к разработке?](#7-Какие-бывают-подходы-к-разработке)

[8. Agile манифест](#8-Agile-манифест)

[10. Какие существуют этапы разработки?](#10-Какие-существуют-этапы-разработки)



[13. Чем Kafka отличается от RabbitMQ?](#13-Чем-Kafka-отличается-от-RabbitMQ)

[14. Что такое очередь сообщений?](#14-Что-такое-очередь-сообщений)

[15. Что такое брокер сообщений?](#15-Что-такое-брокер-сообщений)

[16. Что такое корпоративная шина ESB?](#16-Что-такое-корпоративная-шина-ESB)



[19. Что такое абсолютные и относительные ссылки?](#19-Что-такое-абсолютные-и-относительные-ссылки)

[20. Что такое монолитная архитектура?](#20-Что-такое-монолитная-архитектура)

[21. Что такое SOA?](#21-Что-такое-SOA)

[22. Что такое микросервисная архитектура?](#20-Что-такое-микросервисная-архитектура)

[23. Что такое бизнес процесс?](#20-Что-такое-бизнес-процесс)

## Требования

## 1. Какие виды требований вы знаете?

Функциональные и Нефункциональные

[к оглавлению](#Требования)

## 2. Что такое функциональные требования?

Функциональные требования (functional requirements) — описание требуемого поведения системы в определенных условиях.
Функциональные требования определяют, каким должно быть поведение продукта в тех или иных условиях. 
Они определяют, что разработчики должны создать, чтобы пользователи смогли выполнить свои задачи (пользовательские требования) в рамках бизнес-требований.

[к оглавлению](#Требования)

## 3. Что такое НЕфункциональные требования?

`Нефункциональные требования` – это четкие критерии того, как система должна работать, в отличие от функциональных, которые описывают, что система должна делать.

`Нефункциональные требования` — требования, определяющие свойства, которые система должна демонстрировать, или ограничения, которые она должна соблюдать, не относящиеся к поведению системы. 
Например, производительность, удобство сопровождения, расширяемость, надежность, факторы эксплуатации. Требования, которые подразумеваются или преобразованы из высокоуровневого требования.

![image](https://myslide.ru/documents_4/466f7ee98584a6c0130bca7bd65391fd/img5.jpg)

[к оглавлению](#Требования)

## 4. Критерии требований

-Полнота 
- Осуществимость 
- Необходимость 
- Конкретность 
- Приоритезированность 
- Недвусмысленность 
- Проверяемость

[к оглавлению](#Требования)

## 5. Заинтересованные лица (стейкхолдеры) - кто это и как с ними взаимодействовать?

`Стейкхолдеры` — это люди или группы, которые влияют на проект или на компанию в целом. Стейкхолдерами могут быть клиенты, сотрудники, акционеры, поставщики и другие заинтересованные лица.
Стейкхолдер (stakeholder) — это лицо, которое имеет интересы относительно проекта или организации или влияет на проект или организацию.

Стейкхолдеры бывают внутренние (например, сотрудники и руководство) и внешние (например, клиенты, поставщики, общественность). 
Каждый стейкхолдер имеет свои уникальные цели, ожидания и потребности, вносит свой вклад в проект или организацию.

**Внутренние стейкхолдеры**. Это группы и лица, которые находятся внутри организации или проекта и прямо участвуют в его деятельности. К ним относятся:

* Руководство и сотрудники. 
* Владельцы и акционеры.

**Внешние стейкхолдеры.** Это группы и лица, которые находятся за пределами организации или проекта, но заинтересованы в их результатах и влияют на них. Внешними стейкхолдерами могут быть:

* Клиенты и пользователи. 
* Партнёры по бизнесу.
* Государственные органы и регуляторы. 
* Общественность и неправительственные организации.

![image](https://github.com/artemaverin/summary/assets/97846877/9a31979e-d765-457a-a125-efc06907b022)

[к оглавлению](#Требования)

## 6. User story и Use case

User Story и Use Case - это инструменты аналитика по сбору клиентских требований

**User story** - это описание простым и понятным языком, того что нужно клиенту и для чего. Разговор бизнеса и аналитика.Обычно историю можно кратко описать по шаблону:

`Я (роль пользователя) хочу (описание того что нужно сделать) с помощью (инструмент или процесс) для (для чего мне это нужно? например сокращения издержек по времени)`

**Use story** - это перевод бизнес задачи на язык понятный разработчикам. Пошагово расписываются роли, задачи, место в приложении где что-то нужно добавить/исправить максимально ясно,четко и однозначно.
- -----

_User story_ — для чего клиенту продукт (пассажир хочет самостоятельно распечатать посадочный талон для посадки на рейс).

_Use case_ — как этот продукт должен работать. Это описание поведения системы при взаимодействии с кем-то или чем-то из внешней среды (стороннее приложение или пользователь). (говорят: “юз кейсы”). Пользователь не может совершить 2 шага подряд.

[к оглавлению](#Требования)

## 7. Какие существуют техники сбора требований?

`интервью` - беседа один на один с конкретным стейкхолдером, с заранее оговоренными вопросами. В рамках данной беседы выясняются и уточняются требования посредством дробления глобальной задачи на более мелкие и детального обсуждения каждой из этих подзадач

`мозговой штурм` - формат групповой встречи с участием стейкхолдеров, целью которой является генерация как можно большего количества идей  и требований без их фильтрации

`воркшоп` - совещание с участием заказчика и команды разработки с целью принятия и выработки единого решения и противоречий в рамках заданной темы

## Нотации UML и BPMN

## 8. Какими нотациями вы владеете?

- `Блок-схема` (в основном под алгоритмы)
https://docs.google.com/document/d/1dlwJd1brdHCSWWIMCyAWzrPKZ3eyzjMc9aS_m5cdzDk/edit

- `EPC` (Event-Driven Process Chain — событийная цепочка процессов) используется для описания процессов нижнего уровня
https://docs.google.com/document/d/1TTGRTWtWcc9Hs2ZwIkFIqIYEerlDFbNGdjk8znBS5Z0/edit

- `UML`
https://docs.google.com/document/d/1ivrj7yAg3Bx4DQsdlDzvrk3ilmhx5esdMFk_ki5LjgQ/edit#heading=h.ybfk4ofsso

- `BPMN 2.0`
https://docs.google.com/document/d/15oM59LZxiZq_nFDKLcPg2ljNUB7OzGa5uo2eK5aeLCQ/edit#heading=h.5r0o6fbrkp7z

- `Семейство IDEF`
https://docs.google.com/document/d/1oaDJ4sPnH6VdI7p2wYGgxsW9akaHV-JLat0xVf3Hw2Y/edit#heading=h.noe8as5cv3kr

Сравнение EPC и BPMN

https://docs.google.com/document/d/128AjQPa56f09OExebYQNxCHsvdsy7C9lmUTvOgKOqCo/edit#heading=h.isy65fclwb7w

[к оглавлению](#Нотации-UML-и-BPMN)

## 9. Какие бывают виды UML диаграм?

![image](https://github.com/artemaverin/summary/assets/97846877/7d6869eb-8b59-4909-b8a1-2eab3e8ec0c4)


**Диаграмма классов** - представляет  собой тип диаграммы статической структуры,  которая описывает структуру системы, показывая классы системы, их атрибуты, операции (или методы) и отношения между объектами.

**Диаграмма деятельности** - по сути, представляет собой расширенную версию блок-схемы, которая моделирует поток от одного действия к другому.

**Диаграммы последовательностей UML**  — это диаграммы взаимодействия, в которых подробно описывается, как выполняются операции. Они фиксируют взаимодействие между объектами в контексте сотрудничества. Диаграммы последовательности ориентированы на время и визуально показывают порядок взаимодействия, используя вертикальную ось диаграммы для представления времени, когда и какие сообщения отправляются.

![image](https://github.com/artemaverin/summary/assets/97846877/c15413be-2f5c-4887-b403-6dba667e39bd)

**Диаграмма состояния** - поведение объекта является не только прямым следствием его входных данных, но также зависит от его предшествующего состояния. Прошлую историю объекта лучше всего можно смоделировать с помощью диаграммы конечного автомата или традиционно называемого автоматом.

![image](https://github.com/artemaverin/summary/assets/97846877/b5ce155e-6925-4df2-9c3f-41d6cb27be3e)

**Диаграмма  вариантов  использования UML** — это основная форма требований к системе/программному обеспечению для новой недостаточно разработанной программы. Варианты использования определяют ожидаемое поведение (что), а не точный метод его реализации (как).

**Диаграммы связи UML**  , как и  диаграммы последовательности  — своего рода диаграммы взаимодействия, показывают, как взаимодействуют объекты. Диаграмма связи — это расширение диаграммы объектов, которое показывает объекты вместе с сообщениями, которые передаются от одного к другому. В дополнение к ассоциациям между объектами диаграмма связи показывает сообщения, которые объекты посылают друг другу.

![image](https://github.com/artemaverin/summary/assets/97846877/7678e5ad-7527-4a17-9c5c-61b0c3a52bf1)

**Диаграммы компонентов UML** используются при моделировании физических аспектов объектно-ориентированных систем, которые используются для визуализации, спецификации и документирования систем на основе компонентов, а также для создания исполняемых систем путем прямого и обратного проектирования.

Диаграммы компонентов — это, по сути, диаграммы классов, которые фокусируются на компонентах системы, которые часто используются для моделирования статического представления реализации системы.

**Диаграмма  развертывания UML**  — это диаграмма, которая показывает конфигурацию узлов обработки во время выполнения и компонентов, которые находятся на них. Диаграммы развертывания — это своего рода структурная диаграмма, используемая при моделировании физических аспектов объектно-ориентированной системы. Они часто используются для моделирования статического представления развертывания системы (топологии оборудования).

**Диаграмма объекта**
Объект — это экземпляр определенного момента времени выполнения, включая объекты и значения данных. Статическая  диаграмма объектов UML  является экземпляром  диаграммы классов ; он показывает снимок подробного состояния системы в определенный момент времени, поэтому диаграмма объектов охватывает объекты и их отношения в определенный момент времени.

[к оглавлению](#Нотации-UML-и-BPMN)

## 10. Какие бывают виды BPMN диаграм?

В BPMN существует 4 вида диаграмм:

- Процесс (Process Diagram)
Описывает содержание и логику бизнес-процесса BPMN в виде потока задач, условий и событий. Это самый распространенный, часто применяемый вид диаграмм, он является основой нотации BPMN.
![image](https://github.com/artemaverin/summary/assets/97846877/60fa546a-18ef-4ab0-953c-decac696febc)

- Взаимодействие (Collaboration Diagram)
Позволяет моделировать взаимодействие (обмен данными) между двумя или более бизнес-процессами BPMN. Для графического отображения такого взаимодействия используются потоки сообщений (message flow)
![image](https://github.com/artemaverin/summary/assets/97846877/bd98e4ff-c5b6-4ed5-976d-9854d27105f3)

- Хореография (Choreography Diagram)
Иногда диаграммы "Взаимодействие" оказываются слишком сложными для восприятия и требуют более наглядного представления. В этом случае применяют диаграммы хореографии. Они описывают поток (последовательность) взаимодействий участников при выполнении бизнес-процессов BPMN.
![image](https://github.com/artemaverin/summary/assets/97846877/a235b75f-b14f-4ed1-9b6e-a241f0260c02)


- Диалог (Conversation Diagram)
Является еще одним вариантом диаграммы для визуализации взаимодействий бизнес-процессов BPMN и их участников. Диаграмма "Диалог" описывает процессный ландшафт и взаимодействия верхнего уровня между вовлеченными сторонами.

![image](https://github.com/artemaverin/summary/assets/97846877/0d1cdadc-c6ab-4805-bded-dfad65686f37)

[к оглавлению](#Нотации-UML-и-BPMN)

## 11. Составьте схему BPMN для процесса, описывающего работу банкомата

![new-bpmn-diagram (1)](https://github.com/artemaverin/summary/assets/97846877/cfe6d5a9-2f07-4ea3-b5ca-eca8c9cb1a0e)

## 12. Какие бывают Gateway в BPMN?

Шлюзы BPMN (или Логические операторы BPMN) используются для контроля слияния и ветвления потоков управления. Если контроль потока управления не нужен, то шлюзы можно не использовать. Принцип работы шлюза похож на пропускное устройство, которое позволяет пройти через него в определенных направлениях и при определенных условиях.

![image](https://github.com/artemaverin/summary/assets/97846877/d2c17f60-e803-4c73-9203-bde3a8b23709)

[к оглавлению](#Нотации-UML-и-BPMN)

## 13. Какие элементы BPMN вы знаете?

Алфавит нотации BPMN включает следующие элементы:

**События (Events):**

* Начальное событие (Start Event): обозначает начало бизнес-процесса.
* Промежуточное событие (Intermediate Event): представляет собой событие, которое происходит во время выполнения процесса.
* Конечное событие (End Event): обозначает завершение бизнес-процесса.

**Задачи (Tasks):**

* Пул (Pool)
* Задача (Task): представляет собой действие или задачу, которую должен выполнить участник процесса.
* Подзадача (Sub-Task): представляет собой более мелкую задачу, которая является частью более крупной задачи.

**Шлюзы (Gateways):**

* Исключающее шлюз (Exclusive Gateway): используется для принятия решения на основе условий, выбирая один из нескольких исходящих потоков.
* Включающее шлюз (Inclusive Gateway): используется для определения различных вариантов выполнения процесса, где одновременно могут быть выбраны несколько исходящих потоков.
* Событийное шлюз (Event-Based Gateway): используется для управления потоком выполнения на основе возникновения событий.

**Потоки (Flows):**

* Поток сообщений (Message Flow): представляет передачу сообщений между двумя участниками процесса.
* Поток данных (Data Flow): обозначает передачу данных между элементами процесса.

**Участники (Participants):**

* Бизнес-участник (Business Participant): представляет бизнес-роль или организацию, которая участвует в бизнес-процессе.



В нотации BPMN выделяют пять основных категорий элементов:
- элементы потока (события, процессы и шлюзы);
- данные (объекты данных и базы данных);
- соединяющие элементы (потоки управления, потоки сообщений и ассоциации);
- зоны ответственности (пулы и дорожки);
- артефакты (сноски)

[к оглавлению](#Нотации-UML-и-BPMN)

# SQL и базы данных

## 14.Зачем нужны индексы в таблицах БД?

Индекс — объект базы данных, создаваемый с целью повышения производительности поиска данных. 

**Кластерный индекс** – это индекс, который физически упорядочивает данные (фактически биты на диске) определенным образом. Когда в таблицу поступают новые данные, то они сохраняются в том же порядке.

Ограничение в отношении кластерного индекса заключается в том, что для таблицы БД можно создать только один кластерный индекс. Это происходит из-за его природы – кластерные индексы обеспечивают соблюдение порядка данных. К тому же кластерные индексы увеличивают время записи, поскольку при добавлении новых данных все данные необходимо переупорядочить. Однако кластерные индексы могут значительно увеличить скорость чтения данных из таблицы.
```
Таким образом, главное, что необходимо понимать – это то, что кластерные индексы упорядочивают данные физически (на диске) в кластерах.
```
В большинстве систем управления базами данных (далее – СУБД) кластерный индекс строится автоматически на основании первичного ключа. Если в таблице нет первичного ключа, то для построения кластерного индекса будет использовано поле, объявленное как UNIQUE. Если же в таблице нет уникального поля, то можем создать индекс на основании любого из полей, по которому мы желаем сортировать данные в таблице.

По умолчанию кластерный индекс создается на основе B-tree, т.е. самобалансирующееся дерево. B-деревья стараются оставаться сбалансированными. При этом количество данных в каждой ветви дерева примерно одинаково. Следовательно, количество уровней, которые необходимо пройти, чтобы найти строки, всегда примерно одинаково. Такие индексы можно эффективно использовать для запросов на равенство и диапазона. Они могут работать со всеми типами данных, а также могут быть использованы для получения значений NULL.

**Некластерные индексы** – это индексы, которые хранят отдельный список упорядочивания, в котором есть указатели на физические строки. В основном это похоже на указатель в книге, поскольку такой указатель знает, на какой странице начинается или заканчивается та или иная глава. Таким образом, в отличие от кластерного индекса, таблица может иметь много некластерных индексов. Но стоит понимать важный момент – каждый новый некластерный индекс увеличивает время, которое необходимо для записи новых строк в таблицу.
```
Таким образом, некластерные индексы не упорядочивают данные физически, они просто хранят список порядка данных.
```
Некластерные индексы используются для увеличения скорости запросов к таблице. Некластерные индексы указывают на адреса памяти вместо хранения самих данных. Поэтому они медленнее для запросов, чем кластерные индексы. Однако обычно они намного быстрее, чем неиндексированный столбец.

![image](https://github.com/artemaverin/summary/assets/97846877/d05ae7ab-9735-4feb-937b-a1f7191db775)

[к оглавлению](#SQL-и-базы-данных)

## 15. Знакомы ли вы с нормализацией баз данных?

https://job4j.ru/profile/exercise/179/task-view/819

Нормализация БД – это процесс организации данных определенным образом и рекомендации по проектированию. Т.е. таблицы и связи между ними (отношения) создаются в соответствии с правилами. В результате обеспечивается некоторый уровень безопасности данных. К тому же устраняются несогласованные зависимости и избыточность.

Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.

избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управление данными не гибким и не очень удобным. Отсюда можно сделать вывод, что нормализация нужна для:

- Устранения аномалий
- Повышения производительности
- Повышения удобства управления данными

Нормальная форма базы данных – это набор правил и критериев, которым должна отвечать база данных.

Процесс нормализации – это последовательный процесс приведения базы данных к эталонному виду, т.е. переход от одной нормальной формы к следующей.

* Ненормализованная форма или нулевая нормальная форма (UNF)
* Первая нормальная форма (1NF)
* Вторая нормальная форма (2NF)
* Третья нормальная форма (3NF)
* Нормальная форма Бойса-Кодда (BCNF)
* Четвертая нормальная форма (4NF)
* Пятая нормальная форма (5NF)
* Доменно-ключевая нормальная форма (DKNF)
* Шестая нормальная форма (6NF)

**первая нормальная форма (1NF)**

Переменная отношения находится в первой нормальной форме (далее – 1НФ) тогда и только тогда, когда каждый атрибут отношения содержит строго одно атомарное значение.

Если упростить, то можно сказать, что каждый атрибут отношения атомарен (неделим) и система управления БД (далее - СУБД) не должна оперировать отдельной частью атрибута.

https://info-comp.ru/first-normal-form

Требование первой нормальной формы (1NF) очень простое и оно заключается в том, чтобы таблицы соответствовали реляционной модели данных и соблюдали определённые реляционные принципы.

Таким образом, чтобы база данных находилась в 1 нормальной форме, необходимо чтобы ее таблицы соблюдали следующие реляционные принципы:

- В таблице не должно быть дублирующих строк
- В каждой ячейке таблицы хранится атомарное значение (одно не составное значение)
- В столбце хранятся данные одного типа
- Отсутствуют массивы и списки в любом виде

Правило: **Строки, столбцы и ячейки в таблицах необходимо использовать строго по назначению.**

* Назначение строк – хранить данные
* Назначение столбцов – хранить структурную информацию
* Назначение ячеек – хранить атомарное значение

**вторая нормальная форма (2NF)**

Переменная отношения находится во второй нормальной форме (далее – 2НФ) тогда и только тогда, когда она находится в 1НФ и каждый ее неключевой атрибут функционально полно зависит от любого потенциального ключа.

Т.е. ни один атрибут, не входящий в состав потенциального ключа, не должен функционально зависеть от части какого бы то ни было из потенциальных ключей.

https://info-comp.ru/second-normal-form

Чтобы база данных находилась во второй нормальной форме (2NF), необходимо чтобы ее таблицы удовлетворяли следующим требованиям:

- Таблица должна находиться в первой нормальной форме
- Таблица должна иметь ключ
- Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)

Если ключ составной, т.е. состоит из нескольких столбцов, то все остальные неключевые столбцы должны зависеть от всего ключа, т.е. от всех столбцов в этом ключе. Если какой-то атрибут (столбец) зависит только от одного столбца в ключе, значит, база данных не находится во второй нормальной форме.

Иными словами, в таблице не должно быть данных, которые можно получить, зная только половину ключа, т.е. только один столбец из составного ключа.

Главное правило второй нормальной формы (2NF) звучит следующим образом
```
Таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку.
```

**третья нормальная форма (3NF)**

Переменная отношения находится в третьей нормальной форме (далее – 3НФ) тогда и только тогда, когда она находится во второй нормальной форме, и каждый ее неключевой атрибут нетранзитивно зависит от первичного ключа. Т.е. в отношении не должно быть атрибутов, которые не входят в состав первичного ключа и при этом транзитивно зависящих от первичного ключа.

https://info-comp.ru/third-normal-form

Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.

Транзитивная зависимость – это когда неключевые столбцы зависят от значений других неключевых столбцов.

Если: 
- в первой нормальной форме наше внимание было нацелено на ***соблюдение реляционных принципов***, 
- во второй нормальной форме в центре нашего внимания был ***первичный ключ***,
- то в третьей нормальной форме все наше внимание уделено ***столбцам***, которые ***не являются первичным ключом***, т.е. неключевым столбцам.

Иными словами, неключевые столбцы не должны пытаться играть роль ключа в таблице, т.е. они действительно должны быть неключевыми столбцами, такие столбцы не дают возможности получить данные из других столбцов, они дают возможность посмотреть на информацию, которая в них содержится, так как в этом их назначение.

Главное правило третьей нормальной форме (3NF) звучит следующим образом:

```
Таблица должна содержать правильные неключевые столбцы
```

***Нормальная форма Бойса-Кодда (BCNF)***

https://info-comp.ru/boyes-codd-normal-form

Требования нормальной формы Бойса-Кодда следующие:

- Таблица должна находиться в третьей нормальной форме. Здесь все как обычно, т.е. как и у всех остальных нормальных форм, первое требование заключается в том, чтобы таблица находилась в предыдущей нормальной форме, в данном случае в третьей нормальной форме;
- Ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов.
- 
Отсюда следует, что требования нормальной формы Бойса-Кодда предъявляются только к таблицам, у которых первичный ключ составной. Таблицы, у которых первичный ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной форме Бойса-Кодда.

Главное правило нормальной формы Бойса-Кодда (BCNF) звучит следующим образом:
```
Часть составного первичного ключа не должна зависеть от неключевого столбца.
```
[к оглавлению](#SQL-и-базы-данных)

## 16. Какие виды JOIN запросов вы знаете?

![image](https://github.com/artemaverin/summary/assets/97846877/9a41a92c-0b04-4a27-bec3-ac9843923d4a)

**INNER JOIN** - Из строк левой_таблицы и правой_таблицы объединяются и возвращаются только те строки, по которым выполняются условия_соединения.

**LEFT OUTER JOIN** - Возвращаются все строки левой_таблицы (ключевое слово LEFT). Данными правой_таблицы дополняются только те строки левой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк правой_таблицы вставляются NULL-значения.

**RIGHT OUTER JOIN** - Возвращаются все строки правой_таблицы (ключевое слово RIGHT). Данными левой_таблицы дополняются только те строки правой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк левой_таблицы вставляются NULL-значения.

**FULL OUTER JOIN** - Возвращаются все строки левой_таблицы и правой_таблицы. Если для строк левой_таблицы и правой_таблицы выполняются условия_соединения, то они объединяются в одну строку. Для строк, для которых не выполняются условия_соединения, NULL-значения вставляются на место левой_таблицы, либо на место правой_таблицы, в зависимости от того данных какой таблицы в строке не имеется.

**CROSS JOIN** - Объединение каждой строки левой_таблицы со всеми строками правой_таблицы. Этот вид соединения иногда называют декартовым произведением.

[к оглавлению](#SQL-и-базы-данных)

## 17. Чем TRANCATE отличается от DELETE?

![image](https://github.com/artemaverin/summary/assets/97846877/0f9af2e7-99d4-4e84-a67c-d8cc93fb777d)

[к оглавлению](#SQL-и-базы-данных)

## 18. Что такое транзакция?

https://job4j.ru/profile/exercise/179/task-view/800

Транзакция – это совокупность операций с БД, которые представляют собой логически неделимую единицу. При этом операции могут быть выполнены или целиком и успешно (должны быть соблюдены все правила консистентности БД и не зависит от параллельных транзакций), или же не выполнены вообще (при этом ни одна из операций, которые входят в совокупность, не должна внести изменения в БД).

Если говорить немного проще, то это совокупность операций, который или целиком и успешно завершится, или целиком отменяется в случае ошибки при выполнении любой из входящих в транзакцию операции.

При этом также к определению транзакции добавляют, что они являются единицей восстановления и конкурентного доступа.

Соответственно, обобщим все сказанное:

1. Всегда или выполнится, или не выполнится целиком;

2. Может быть использована для восстановления из-за сбоев и отказов системы. В случае сбоя системы во время выполнения транзакции методы восстановления отменяют любое влияние транзакции на базу данных.

3. Обеспечивает механизм конкурентного доступа к данным.

[к оглавлению](#SQL-и-базы-данных)

## 19. Какими свойствами должна обладать транзакция? (ACID)

https://job4j.ru/profile/exercise/179/task/806/393958

поговорим про свойства транзакций. Эти свойства известны под аббревиатурой ACID, которая получается из первых букв следующих английских слов:

1. Atomicity (атомарность);

2. Consistency (согласованность);

3. Isolation (изолированность);

4. Durability (устойчивость).

Представленные свойства обеспечивают точность и целостность данных в БД и гарантируют, что данные не будут повреждены в результате некоторого сбоя, обеспечивая при этом достоверность данных даже при возникновении ошибок или сбоев.

**Атомарность** (atomicity) означает, что транзакция не может быть выполнена частично. Таким образом, всегда все операции транзакции будут выполнены (все и до конца) или же не будут выполнены (ни одна, т.е. все изменения данных будут отменены).

Таким образом, согласно этому свойству промежуточного пути нет или транзакции не происходят частично. Каждая транзакция рассматривается как единое целое и должна выполниться полностью. При этом она включает следующие операции:

- прерывание выполнения: если транзакция прерывается, то изменения, внесенные в БД, не видны;
- фиксация изменений: если транзакция завершается успешно, то внесенные изменения в БД будут зафиксированы в БД.

**Согласованность** (consistency) означает, что успешно завершенная транзакция гарантированно сохраняет согласованность БД, т.е. фиксируются только допустимые результаты изменения данных (они не должны противоречить никаким ограничениям, которые реализованы на уровне СУБД или добавленные отдельно в БД проверки, триггеры и т.д.). Иногда проверки дополнительных условий реализуются непосредственно в коде транзакции.

Важно, что в процессе выполнения транзакции согласованность БД может нарушаться. Например, в представленном выше примере на рисунке во время выполнения операций одновременно обоими клиентами существует момент, когда баланс счета источника уже уменьшен, а баланс счета приемника еще не увеличен. Проще говоря деньги «ушли в никуда». Однако это внутреннее состояние СУБД не показывается другим транзакциям, которые работают с теми же данными, т.е. извне транзакции нарушения согласованности «почти» никогда не видны. Здесь мы говорим «почти» потому что существуют способы на свой страх и риск получить доступ к промежуточным состояниям БД. Однако лучше этого не делать.

Если ссылаться на пример выше, то для согласованности данных необходимо сохранить общую сумму до и после транзакции.

Итого до выполнения транзакции: T = 500 + 200 = 700.

Итого после выполнения транзакции: T = 400 + 300 = 700.

Таким образом, данные БД согласованны. Несогласованность возникает в том случае, если T1 завершается успешно, а Т2 терпит неудачу.

**Изолированность** (isolation) означает, что несколько выполняемых параллельно транзакций не должны влиять на результат выполнения друг друга.

Транзакции происходят независимо, без помех. Изменения, которые происходят в конкретной транзакции, не будут видны ни в одной другой транзакции, пока это изменение в транзакции не будет записано в память или не будет зафиксировано. Изолированность гарантирует, что одновременное выполнение транзакций приведет к состоянию, которое эквивалентно состоянию, в котором транзакции были выполнены последовательно в некотором порядке.

**Устойчивость** (durability) означает, что СУБД самостоятельно решает все «внутренние проблемы» и гарантирует, что после завершения транзакции (как успешного, так и неуспешного), все необходимые изменения были или зафиксированы, или отменены и что БД не окажется в некотором «промежуточном состоянии». Чаще всего это свойство ассоциируют с устойчивостью к сбоям в аппаратном обеспечении, сетевом взаимодействии и т.д. Даже в таких условиях СУБД всегда «в курсе», какие операции были выполнены и после возвращения к нормальным условиям работы может удостовериться, что данные не повреждены (или же сообщить о возникших проблемах).

[к оглавлению](#SQL-и-базы-данных)

## 20. Чем отличается UNION от UNION ALL?

https://job4j.ru/profile/exercise/179/task/976/395770

Операторы множества в SQL – это ключевые слова, которые позволяют объединить результаты двух и более запросов в один.

Существует несколько различных операторов множества, которые можно использовать в зависимости от наших потребностей и используемой системы управления базами данных (далее – СУБД).

В задании рассмотрим следующие операторы множества:

- UNION;
- UNION ALL;
- INTERSECT;
- EXCEPT.

```
SELECT first_select_query
set_operator
SELECT second_select_query;
```

Таким образом, операторы множества используют два и более запроса SELECT, при этом оператор множества ставится между запросами SELECT.

Однако есть некоторые ограничения, о которых необходимо обязательно помнить:

- при выборе столбцов в каждом из запросов SELECT количество столбцов должно совпадать;
- типы данных каждого из столбцов должны быть совместимыми;
- порядок столбцов в каждом из запросов SELECT должны быть одинаковыми.

Оператор множества UNION позволяет объединить результаты двух запросов. Этот оператор удаляет все повторяющиеся строки и показывает нам комбинацию обоих результатов выборок SELECT.

Оператор множества UNION ALL также объединяет результаты двух и более запросов. Однако в отличие от UNION, он не удаляет дубликаты

В чем же разница между UNION и UNION ALL? Основное различие между операторами заключается в том, что UNION удаляет все повторяющиеся результаты из окончательного набора результатов, а UNION ALL – нет. UNION выполняет DISTINCT для набора результатов, чтобы удалить дубликаты.

Таким образом, UNION ALL почти всегда будет показывать больше результатов, так как не удаляет повторяющиеся записи.

Стоит подчеркнуть, что UNION будет выполняться медленнее, чем UNION ALL, поскольку там присутствует операция по удалению повторяющихся значений (DISTINCT) – эта операция, как известно, является дорогостоящей частью запроса.

Таким образом, если нам не нужны уникальные строки в результирующем наборе или если мы уверены, что строки в базе данных или запросе уже уникальны, то стоит использовать UNION ALL.

[к оглавлению](#SQL-и-базы-данных)

## 21. Что такое первичный ключ?

первичный ключ (primary key) - это поле в таблице, однозначно идентифицирующее каждую строку (запись) в таблице БД. Первичный ключ должен содержать уникальные значения. Также не может содержать null. В таблице может быть только один первичный ключ. Ключ может состоять из одного и более полей. Первичный ключ, состоящий из нескольких полей, называется составным ключом.

Первичный ключ выбирается так, чтобы он состоял из минимально возможного количества полей. Например, если есть поля "имя", "фамилия", "дата рождения" и "номер телефона", нет смысла делать составной ключ из нескольких полей, так как имеется поле "номер телефона", и по нему одному мы можем в будущем уникально идентифицировать записи, так как номер телефона не может повторяться.

Так как в реляционных БД все таблицы почти всегда связаны друг с другом, первичные ключи используются для однозначной организации этой связи.

[к оглавлению](#SQL-и-базы-данных)

## 22. Что такое внешний ключ?

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

[к оглавлению](#SQL-и-базы-данных)

## 23. Какие бывают представления в БД?

https://job4j.ru/profile/exercise/179/task-view/787

представления - это другой тип таблиц, поскольку представления по умолчанию не существуют физически, т.е. их содержимое не сохраняется на диске.

**Представления (views)** – это объекты базы данных, которые всегда создаются на основе одной или более базовых таблиц (или других представлений), используя информацию метаданных. Эта информация (включая имя представления и способ получения строк из базовых таблиц) – все, что сохраняется физически для представления. Именно по этой причине представления также называют виртуальными таблицами. упрощенно, это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени.

**Материализованное представление** – это объект базы данных, значением которого является сохраненный результат заранее выполненного запроса, заданного при создании материализованного представления. Повторное вычисление и сохранение полученного результата происходит согласно правилам, которые определяются при создании материализованного представления.

В упрощенном виде – это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени, и результат выполнения этого запроса сохраняется для дальнейшего использования.

Таким образом, мы выяснили, что представления можно условно поделить на 2 типа:

- «обычные» представления, результат вычисления которых нигде не сохраняется;
- материализованные представления, результат вычисления которых сохраняется и может быть повторно использован.

Отразим эти различия следующим образом:

1. Представление:

- при создании представления просто фиксируется то, что с этого момента некоторый SQL-запрос можно не писать заново, а вызывать по заранее заданному имени.
- только при вызове этого запроса по его имени происходит (заново каждый раз) реальное чтение данных из таблиц, на которое ссылается представление.

**Материализованное представление:**

- при создании представления фиксируется то, что с этого момента некоторый SQL-запрос можно не писать заново, а вызывать по заранее заданному имени.
- результат выполнения запроса фиксируется во временном хранилище.
- обновление хранилища происходит согласно алгоритму, который указывается при создании представления.
- при вызове запроса чтение происходит из временного хранилища.

Мы уже определили, что представления строятся на основе SQL-запросов. Соответственно:

- основой для построения представления может быть только SELECT-запрос (т.е. нельзя построить представление на основе запросов с INSERT, UPDATE, DELETE);
- иногда представление допускает так называемые двунаправленные отношения, т.е. с его использованием можно будет не только читать данные, но и изменять их. В рамках нашего курса это не рассматривается.

**Преимущества:**

1. Упрощение выполнения запросов. Как мы уже обсудили, представление может быть построено на SQL-запросе любой сложности. Поэтому при использовании представлений нам уже не придется переписывать запрос, который может состоять даже из 100 строк. Нам будет достаточно вызвать представление SELECT * FROM представление и в итоге получить тот же результат;

2. Возможность построения простого и надежного API. На стадии проектирования БД мы можем предусмотреть набор удобных представлений, т.е. мы можем заранее скрыть от разработчика сложные запросы, что, в свою очередь, упростит разработку приложения и к тому же снизит количество ошибок при разработке.

3. Упрощение бизнес-логики. В принципе, это следует из предыдущего пункта. Однако даже если мы не строим полноценный API, мы все равно можем заранее сформировать набор для наиболее сложных и часто встречаемых запросов.

4. Минимум накладных расходов. Представление (это касается простых представлений) практически не занимает места в БД, потому даже создание сотен и тысяч представлений не приводит к ощутимому увеличению размера БД.

5. Безопасность. Представления являются объектами БД, потому к ним применимы все механизмы СУБД по контролю прав доступа.

**Недостатки:**

1. Избыточность. Иногда представления просто не нужны. Например, БД небольшая, бизнес-логика простая, модель безопасности тривиальная. В таком случае представления чаще всего будут лишними.

2. Дополнительный код. Представления, как и все остальное, необходимо создавать, что ведет за собой остальные операции – тестирование, корректировка при изменении БД или бизнес-логики. Соответственно, растут трудозатраты и повышается вероятность появления ошибок.

3. Ограниченность возможностей. Мы уже говорили, что представления можно использовать для модификации данных. Однако это имеет много ограничений, поэтому можно утверждать, что не любую операцию с БД можно выполнить с помощью представлений.

Создание представления
```
create view имя_представления as запрос_select
```

```
create view show_students_with_2_or_more_books
    as select s.name as student, count(a.name), a.name as author from students as s
         join orders o on s.id = o.student_id
         join books b on o.book_id = b.id
         join authors a on b.author_id = a.id
         group by (s.name, a.name) having count(a.name) >= 2;
```

Вызов представления
```
select * from show_students_with_2_or_more_books;
```

изменить представление

```
alter view старое_имя rename to новое_имя
```

Удалить представление

```
drop view имя_представления
```
[к оглавлению](#SQL-и-базы-данных)

## 24. Для чего используется HAVING в SQL?

Ранее мы рассмотрели метод where. Однако, у него есть одно ограничение – его нельзя использовать с агрегатными функциями. Для этих целей специально служит оператор having. Применяется он аналогично where, только в нем обязательно должна быть агрегатная функция.

Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций.

Основное различие между WHERE и HAVING в SQL-запросах заключается в том, что WHERE используется для фильтрации строк до применения к ним групповых функций (например, SUM(), AVG(), COUNT()), а HAVING применяется после применения групповых функций и позволяет отфильтровать итоговые группы.

Например:
```
SELECT column_name(s)
FROM table_name
WHERE condition(s);
```
В этом запросе WHERE используется для применения условий фильтрации к отдельным строкам перед применением групповых функций.
```
SELECT column_name(s), function()
FROM table_name
GROUP BY column_name
HAVING condition;
```
Здесь HAVING используется для фильтрации групп после применения групповых функций. Это позволяет дополнительно отфильтровать группы на основе условия.

Важно отметить, что вы не можете использовать WHERE для группировки данных, вы должны использовать HAVING для этой цели.

Также стоит отметить, что в некоторых случаях использование HAVING может быть более эффективным, чем использование WHERE с подзапросом, особенно если подзапрос содержит сложную логику или соединения.

[к оглавлению](#SQL-и-базы-данных)

## 25. Какие бывают БД?

**Реляционная база данных** (SQL) — база, где данные хранятся в формате таблиц, они строго структурированы и связаны друг с другом. В таблице есть строки и столбцы, каждая строка представляет отдельную запись, а столбец — поле с назначенным ей типом данных. В каждой ячейке информация записана по шаблону.
Основная особенность — надежность и неизменяемость данных, низкий риск потери информации. При обновлении данных их целостность гарантирована, они заменяются в одной таблице.
Реляционные БД идеальны для работы со структурированными данными, структура которых не подвержена частым изменениям.


**Нереляционная база данных (NoSQL)** — хранит данные без четких связей друг с другом и четкой структуры. Вместо структурированных таблиц внутри базы находится множество разнородных документов, в том числе изображения, видео и даже публикации в социальных сетях. В отличие от реляционных БД, NoSQL базы данных не поддерживают запросы SQL.
Особенности. В отличие от реляционных, в нереляционных базах данных схема данных является динамической и может меняться в любой момент времени. К данным сложнее получить доступ, то есть найти внутри базы что-то нужное — с таблицей это просто, достаточно знать координаты ячейки. Зато такие СУБД отличаются производительностью и скоростью.
Базы данных NoSQL подходят для хранения больших объемов неструктурированной информации, а также хороши для быстрой разработки и тестирования гипотез.


_Четыре вида нереляционных баз данных_
- **Документоориентированные** базы данных — данные хранятся в коллекциях документов, обычно с использованием форматов JSON, XML или BSON
- Базы данных **ключ-значение** — каждая запись имеет ключ и значение. Её используют такие базы данных, когда данные не слишком сложные, а скорость является приоритетом.
- **Графовые** базы данных — состоят из узлов и связей между ними. Узлы обозначают элементы в базе данных, а связи между ними определяют их отношения между собой.
- **Колоночные** СУБД — хороший вариант для обработки больших данных, отличаются высокой производительностью, эффективным сжатием данных и отличной масштабируемостью.

![image](https://github.com/artemaverin/summary/assets/97846877/263e7a23-2a7b-46b6-b8ab-bca278b046bb)

[к оглавлению](#SQL-и-базы-данных)


# Интеграция

## 26. Что такое XML и что в нем содержится?

Расширяемый язык разметки (XML) – это язык разметки, который предоставляет правила для определения любых данных.

Файл XML представляет собой текстовый документ, в котором присутствуют теги для описания структуры и других его функций. Теги пишут в угловых скобках, причём их всегда два – один открывает запись, другим она заканчивается.

В отличие от других языков программирования, XML не может выполнять вычислительные операции сам по себе. Вместо этого для управления структурированными данными можно использовать любой язык программирования или программное обеспечение.

XML содержит мета-данные (об именах полей, классов, вложенности структур)

[к оглавлению](#Интеграция)

## 27. Что такое XSD?

XSD (XML Schema Definition) - это язык описания структуры XML-документов. Он определяет структуру, элементы и атрибуты документа XML. XSD позволяет проверить, соответствует ли XML-документ заданной структуре, и помогает обеспечить его корректность.

XSD — это язык описания структуры XML документа. Его также называют XML Schema. При использовании XML Schema XML парсер может проверить не только правильность синтаксиса XML документа, но также его структуру, модель содержания и типы данных.
Такой подход позволяет объектно-ориентированным языкам программирования легко создавать объекты в памяти, что, несомненно, удобнее, чем разбирать XML как обычный текстовый файл.

[к оглавлению](#Интеграция)

## 28. Чем sequence отличается от choice в XSD?

XSD-схемы могут содержать различные элементы, включая sequence и choice. Sequence указывает порядок, в котором должны быть представлены элементы в документе, а choice – позволяет выбирать из нескольких элементов только один.

[к оглавлению](#Интеграция)

## 29. Что такое пространство имен в XML?

Пространство имен в XML - это способ организации элементов и атрибутов в иерархическую структуру. Оно позволяет определять уникальные идентификаторы для элементов и атрибутов, а также задавать отношения между ними. Это делается с помощью механизма URI (Унифицированный идентификатор ресурса), который связывает элементы и атрибуты с определенными пространствами имен.

В XML-документе пространство имен указывается с помощью атрибута xmlns (XML Namespace), который содержит URI пространства имен. Этот атрибут может быть указан как для корневого элемента документа, так и для отдельных элементов и атрибутов. Если атрибут xmlns не указан, то элемент или атрибут считается принадлежащим пространству имен по умолчанию.

Использование пространств имен в XML позволяет избежать конфликтов имен элементов и атрибутов и обеспечивает возможность повторного использования и модульности кода.

[к оглавлению](#Интеграция)


## 30. Что такое WSDL?

WSDL (Web Services Description Language) - это язык описания веб-сервисов, который определяет структуру и функциональность веб-сервиса, а также протоколы и форматы данных, используемые для обмена информацией между клиентом и сервером. WSDL позволяет другим приложениям и системам понимать и использовать функции веб-сервиса, независимо от того, на каком языке программирования он написан и какие технологии используются для его разработки.

WSDL и XSD являются двумя разными стандартами, связанными с веб-сервисами и обменом данными. Вот основные различия между ними:

- WSDL (Язык описания веб-сервисов) определяет интерфейс веб-сервиса и включает информацию о том, какие операции доступны, какие параметры они принимают и какие результаты возвращают. Он также определяет формат сообщений, используемых для обмена данными между сервисом и клиентами.
- XSD (XML Schema Definition) описывает структуру XML-документов и определяет, какие элементы, атрибуты, типы данных и ограничения могут быть использованы в документе. Она используется для проверки правильности структуры XML-документа и обеспечения его соответствия требованиям.
- WSDL используется для описания веб-сервисов и определения их интерфейса, в то время как XSD используется для определения структуры XML-сообщений, используемых в обмене данными между веб-сервисом и клиентами.
- WSDL может использовать XSD для определения структуры сообщений, но не ограничивается только использованием XSD. Он также может определять другие форматы сообщений, такие как JSON или SOAP.
- WSDL определяет протоколы и форматы данных для обмена информацией, в то время как XSD только определяет структуру данных.

[к оглавлению](#Интеграция)

## 31. Чем SOAP отличается от REST?

REST:

https://skillbox.ru/media/code/rest-api-chto-eto-takoe-i-kak-rabotaet/

https://www.youtube.com/watch?v=XaTwnKLQi4A



REST и SOAP на самом деле не сопоставимы. REST — это архитектурный стиль. SOAP — это формат обмена сообщениями. Давайте сравним популярные реализации стилей REST и SOAP.

Пример реализации RESTful: JSON через HTTP
Пример реализации SOAP: XML поверх SOAP через HTTP

На верхнем уровне SOAP ограничивает структуры ваших сообщений, тогда как REST — это архитектурный подход, ориентированный на использование HTTP в качестве транспортного протокола.

![image](https://github.com/artemaverin/summary/assets/97846877/4cbc3f4d-9a18-4b23-9d52-4ec9e529d473)

[к оглавлению](#Интеграция)

## 32. Из чего состоит сообщение в SOAP?

SOAP-сообщение – это обычный XML-документ, содержащий следующие элементы:
- Конверт – определяет начало и конец сообщения. Это обязательный элемент.
- Заголовок – содержит любые необязательные атрибуты сообщения, используемые при обработке сообщения, либо в промежуточной точке, либо в конечной конечной точке. Это необязательный элемент.
- Тело – содержит данные XML, содержащие отправляемое сообщение. Это обязательный элемент.
- Неисправность – необязательный элемент неисправности, который предоставляет информацию об ошибках, возникающих при обработке сообщения.

![image](https://github.com/artemaverin/summary/assets/97846877/abd13126-43f0-4a86-9449-08af8a7fe96a)

![image](https://github.com/artemaverin/summary/assets/97846877/2f36b00a-bcea-44b3-af65-15ca68b99aba)

[к оглавлению](#Интеграция)

## 33. Что содержит HEADER в ответе REST?

Заголовок (header) в REST API — это часть запроса или ответа, которая содержит метаданные о содержимом сообщения, например тип контента или кодировку. Заголовки используются для передачи информации о запросах и ответах между клиентом и сервером. Некоторые общие примеры заголовков в REST API включают: Content-Type, Accept, Authorization и Cache-Control. Клиент может указать заголовки в запросе, а сервер может возвращать заголовки в ответе, чтобы согласовать параметры с клиентом.

![image](https://github.com/artemaverin/summary/assets/97846877/a99743f3-7d3d-4a82-bbdb-bf3eb02ff9e7)

[к оглавлению](#Интеграция)

## 34. Чем отличается ошибка 200 от 201?

https://ru.hostings.info/schools/kody-vseh-oshibok.html#:~:text=200%20OK.%20Сервер%20обработал%20запрос,но%20будет%20обрабатывать%20его%20позже

**200 Ok**
Сервер обработал запрос браузера (пользователя) и передал ему то, что он хотел. А пользователь должен увидеть сайт или файл, который запрашивал.

**201 Created**
Код сообщает, что сервером создан новый идентификатор URI. В ответе сервера (заголовок Location) можно найти место куда именно были помещены созданные данные.

[к оглавлению](#Интеграция)

## 35. Какие методы REST вы знаете?

* GET - метод используется для получения данных. Он не изменяет состояние сервера и не вносит изменения на стороне сервера.
* POST - метод используется, когда вы хотите добавить или создать ресурс на сервере.
* PUT - метод используется при обновлении ресурса на сервере. Он заменяет существующий ресурс на новый.
* PATCH - метод применяется, когда нужно внести изменения в определенный аспект ресурса.
* DELETE - метод удаляет ресурс на сервере.
- -
* OPTIONS - метод возвращает информацию о поддерживаемых методах для конкретного ресурса.
* HEAD - метод аналогичен GET, но возвращает только заголовки, без тела ответа.
* TRACE - метод отправляет обратно запрошенные данные, которые помогут увидеть, где и по какой причине произошла ошибка.
* CONNECT - метод используется для создания туннеля через защищенный протокол, такой как HTTPS.

[к оглавлению](#Интеграция)

## 36. Напишите пример rest-API для книжной библиотеки (напишите методы, эндпоинты и пример JSON)

В этом примере мы будем использовать формат JSON для обмена данными между библиотекой и клиентами. Допустим, у нас есть API, который позволяет пользователям получать информацию о книгах.

Пример запроса:

`
GET /api/v1/books?title=harry%20potter HTTP/1.1
Host: mylibrary.com
Accept: application/json
`
Пример ответа:
`
[
  {
    "id": 1,
    "title": "Harry Potter and the Sorcerer's Stone",
    "author": "J.K. Rowling",
    "genre": "Fantasy",
    "pages": 324,
    "published_date": "January 1998"
  },
  {
    "id": 2,
    ...
  }
]
`
Этот API позволяет пользователю искать книги по их заголовкам. В ответе мы видим список объектов, каждый из которых представляет одну книгу. Каждый объект содержит свойства, такие как идентификатор книги (id), название, автор, жанр, количество страниц и дата публикации.

Эндопоинты:
`
/books: Получить список книг
/books/{id}: Получить информацию о книге по ее ID
/authors: Получить список авторов
/borrowings: Получить информацию о выдачах книг
/categories: Получить список категорий книг
/genres: Получить список жанров книг
/book_author: Связать книгу с автором
/book_category: Связать книгу с категорией
/book_genre: Связать книгу с жанром
/book/create: Создать новую книгу
/author/create: Создать нового автора
/category/create: Создать новую категорию
/genre/create: Создать новый жанр
/book/borrow: Взять книгу на выдачу
/book/return: Вернуть книгу
`

## 6. Чем Kanban отличается от Scrum?

![image](https://github.com/artemaverin/summary/assets/97846877/651ebcbf-c252-4a22-8a6c-d7f33f52e9ab)

![image](https://github.com/artemaverin/summary/assets/97846877/3d95d431-bd40-4fc8-8dda-9c518514636f)

## 7 Какие бывают подходы к разработке?

Waterfall - подход основанный на последовательном выполнении задач о подробном документировании. Для данного подхода характерны такие моменты как:
- нежелательность любых изменений по ходу проекта
- следование установленным правилам
- ТЗ первично, разработка без него не начинается

Agile + Scrum - в первую очередь это гибкий подход, при котором продукт первичен, документация и прочая бюрократия вторична. 
Характерные моменты:
- неиерархическое построение команды
- самоорганизация команды
- скорость и прозрачность работы

	Особенность Scrum данного подхода:
проект разбивается на временные периоды (спринты) в рамках которого решаются определенные задачи
в команде помимо разработчиков и владельца есть scrum - мастер - человек из команды следящий за scrum-ритуалами
рабочий процесс:
- планирование
- daily-встречи
- обзор и тестирование
- ретроспективы


Agile + Kanban
В отличии от Scrum, команда разбивает рабочие процессы не по времени, а по этапам:
- «В плане»
- «В работе»
- «Готово»

## 8. Agile манифест

- Люди и взаимодействие важнее процессов и инструментов.
- Работающий продукт важнее исчерпывающей документации.
- Сотрудничество с заказчиком важнее согласования условий контракта.
- Готовность к изменениям важнее следования плану.



## 10. Какие существуют этапы разработки?

**Планирование**: интервьюирование и описание требований в ходе которых выявляются цели, согласовываются сроки и цена
	
**Проектирование**: бизнес-аналитик и системный аналитик составляют схемы бизнес-процессов, определяют стек технологий и вырабатывают ТЗ

**Разработка/ реализация**:

команда разработчиков начинает реализацию задач:
	- фронтэнд - отрисовывает макет/интерфейс
	- бэкэнд реализует техническую часть
в итоге на данном этапе получаем тестовый вариант продукта

**Тестирование**:  тестировщики проводят различные виды тестирования на предмет соответствия требованиям.

**Доработка**: обнаруженные баги отправляются на доработку

**Интеграция**: идет внедрение продукта итогом которого станет принятие заказчиком проекта

**Поддержка**: поддержка готового продукта , начиная от инструкций и консультаций до изменений функционала




## 13. Чем Kafka отличается от RabbitMQ?

![image](https://github.com/artemaverin/summary/assets/97846877/ce564a5b-acfb-41c7-9970-0517529abd45)

## 14. Что такое очередь сообщений?

**Очередь сообщений** – это форма асинхронной коммуникации между сервисами, применяемая в бессерверных и микросервисных архитектурах. Сообщения хранятся в очереди, пока не будут обработаны и удалены. Каждое сообщение обрабатывается только один раз и только одним потребителем. Очереди сообщений могут использоваться для разъединения сложных процессов обработки, для буферизации или организации пакетной обработки, а также для сглаживания пиковых нагрузок.

## 15. Что такое брокер сообщений?

**Брокер сообщений** — это программный компонент, который служит посредником между различными компонентами распределенной системы. В его работе используются две основные сущности: producer (отправитель) и consumer (потребитель/подписчик). Он обрабатывает сообщения, полученные от отправителей, и перенаправляет к соответствующим потребителям. Такое ПО реализуется как часть общей архитектуры системы, либо как отдельный сервис.

**Брокер сообщений** — это программное обеспечение для связи между приложениями, системами и службами, помогающее им обмениваться информацией друг с другом. Это делается посредством перевода сообщений из одного формального протокола обмена сообщениями в другой. Таким образом независимые службы могут «общаться» между собой напрямую, даже если они написаны на разных языках или реализованы на разных платформах.

`Очередь сообщений - это структура данных, или контейнер, способ хранения сообщений для последующего использования. Брокер сообщений-это отдельный компонент, который управляет очередями.`

- Распределение нагрузки: если у вас есть много пользователей, которые отправляют запросы одновременно, то очередь сообщений поможет распределить нагрузку между серверами.
- Асинхронная связь: доставка и чтение сообщений может происходить в разное время, когда удобно получатель будет готов получить его и не блокируется.
- Улучшение производительности: если вы используете очередь сообщений, то это может улучшить производительность вашей системы. Запросы будут обрабатываться быстрее, тк они не будут блокироваться на сервере.
- Гарантия порядка доставки: сама структура данных гарантирует что данные будут попадать и храниться в очереди в порядке добавления в нее.
- Гарантия доставки: данные будут доставлены в любом случае (если есть получатель сообщений).
- Масштабирование: если система будет расширяться, то можно добавить дополнительные серверы и использовать очередь сообщений для распределения нагрузки между ними.
- Отказоустойчивость: в случае сбоев в процессе передачи сообщения, то они будут добавлены в очередь позднее после восстановления системы.
- Безопасность: очередь сообщений может помочь защитить систему например от  ддос атак, тк она позволяет ограничить количество запросов, которые могут быть отправлены на сервер одновременно.
- Слабое связывание: при передаче сообщение через очередь возникают неявные связи между процессами, что позволяет им быть изолированными друг от друга и независимыми


## 16. Что такое корпоративная шина ESB?
Сервисная/Корпоративная шина предприятия (англ. enterprise service bus, ESB) — это связующее `программное обеспечение`, обеспечивающее `централизованный` и унифицированный событийно-ориентированный `обмен сообщениями` между различными информационными системами на принципах сервис-ориентированной архитектуры.

![image](https://github.com/artemaverin/summary/assets/97846877/0f511537-5409-41b4-8fd3-69c71e4207e8)

Брокеры сообщений облегчают обмен данными "точка-точка" между двумя приложениями. Если на предприятии много приложений и им необходимо взаимодействовать друг с другом, включение двухточечной связи между каждой парой **приведет к созданию сложной архитектуры, которой трудно управлять и устранять неполадки**. Кроме того, даже связь "один ко многим" также приводит к сетчатому шаблону связи, которым трудно управлять.

ESB решает эту проблему, **внедряя компонент, подобный центральной шине, к которому подключаются все приложения**. Таким образом, ESB устраняет необходимость в соединении "один к одному" между приложениями. Он обеспечивает подключаемую архитектуру связи, которая относительно упрощает подключение новых приложений к существующей инфраструктуре.



## 19. Что такое абсолютные и относительные ссылки?

Абсолютные и относительные ссылки используются в программировании и интернет-ссылках для определения местоположения определенного ресурса.

Абсолютная ссылка:
– Начинается с указания полного пути к ресурсу от корня доменного имени.
– Не изменяется при копировании и вставке ссылки на другую страницу или сайт.
– Позволяет легко определить, на каком сайте находится ресурс.

Относительная ссылка:
– Указывает путь к ресурсу относительно текущей страницы.
– Может быть вставлена на любую страницу сайта или блога без изменения.
– Удобна для пользователей, так как позволяет быстро переходить к связанным ресурсам на том же сайте.

## 20. Что такое монолитная архитектура?

Концепция монолитного программного обеспечения заключается в том, что различные компоненты приложения объединяются в одну программу на одной платформе. Обычно монолитное приложение состоит из базы данных, клиентского пользовательского интерфейса и серверного приложения. Все части программного обеспечения унифицированы, и все его функции управляются в одном месте.

![image](https://github.com/artemaverin/summary/assets/97846877/785bdc12-a15b-42f3-8db5-71bff3b2ddff)

Плюсы:

- Упрощенная разработка и развертывание
- Лучшая производительность

Минусы:

- Кодовая база со временем становится громоздкой
- Сложно внедрять новые технологии
- Ограниченная гибкость (В монолитных приложениях каждое небольшое обновление требует полного повторного развертывания.)

## 21. Что такое SOA?

**Сервис-ориентированная архитектура** (далее SOA — service-oriented architecture) — это стиль архитектуры программного обеспечения, который предполагает модульное приложение, состоящее из дискретных и слабосвязанных программных агентов, которые выполняют конкретные функции. SOA разделяет компоненты по двум основным ролям: `поставщик` и `потребитель` сервисов. Обе эти роли могут играть программные агенты. Концепция SOA заключается в следующем: приложение может быть спроектировано и построено таким образом, что его модули легко интегрируются и могут быть легко использованы повторно.

Плюсы:

- Повторное использование сервисов
- Легкость в сопровождении (Поскольку каждая служба программного обеспечения является независимой единицей, ее легко обновлять и поддерживать, не затрагивая другие службы)
- Более высокая надежность (Службы легче отлаживать и тестировать, чем огромные куски кода, как в монолитах. Это, в свою очередь, делает продукты на основе SOA более надежными.)
- Параллельная разработка

Минусы:

- Высокие инвестиционные затраты
- Сложность в управлении
- Дополнительная нагрузка

## 22. Что такое микросервисная архитектура?

**Микросервисы** — это тип сервисно-ориентированной архитектуры программного обеспечения, ориентированный на создание ряда автономных компонентов, составляющих приложение. В отличие от монолитных приложений, созданных как единое целое, микросервисные приложения состоят из нескольких независимых компонентов, которые склеены вместе посредством API.

Плюсы

- Легко разрабатывать, тестировать и развертывать
- Повышенная гибкость
- Возможность масштабирования по горизонтали

Минусы:

- Сложность
- Проблемы безопасности
- Разные языки программирования

## 23. Что такое бизнес процесс?

Бизнес-процесс - это набор действий и операций, которые выполняются для достижения определенной цели в рамках компании или организации. 

Это могут быть процессы, связанные с производством товаров, оказанием услуг, управлением персоналом, логистикой, финансами и т.д. Каждый бизнес-процесс имеет свои входы, выходы, ресурсы и участников, а также определенную последовательность действий, которые необходимо выполнить для достижения желаемого результата. Оптимизация бизнес-процессов помогает улучшить эффективность работы компании, сократить затраты и повысить качество продукции или услуг.

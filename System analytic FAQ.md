# System analytic FAQ

## Требования

[1. Какие виды требований вы знаете?](#1-Какие-виды-требований-вы-знаете)

[2. Что такое функциональные требования?](#2-Что-такое-функциональные-требования)

[3. Что такое НЕфункциональные требования?](#3-Что-такое-НЕфункциональные-требования)

[4. Критерии требований](#4-Критерии-требований)

[5. Заинтересованные лица (стейкхолдеры) - кто это и как с ними взаимодействовать?](#5-Заинтересованные-лица-(стейкхолдеры)-кто-это-и-как-с-ними-взаимодействовать)

[6. User story и Use case](#6-User-story-и-Use-case)

[7. Какие существуют техники сбора требований?](#7-Какие-существуют-техники-сбора-требований)

_Что содержится в вашей типовой постановке задач для разработчика_

## Нотации UML и BPMN

[8. Какими нотациями вы владеете?](#8-Какими-нотациями-вы-владеете)

[9. Какие бывают виды UML диаграм?](#9-Какие-бывают-виды-UML-диаграм)

[10. Какие бывают виды BPMN диаграм?](#10-Какие-бывают-виды-BPMN-диаграм)

[11. Составьте схему BPMN для процесса, описывающего работу банкомата](#11-Составьте-схему-BPMN-для-процесса-описывающего-работу-банкомата)

[12. Какие бывают Gateway в BPMN?](#12-Какие-бывают-Gateway-в-BPMN)

[13. Какие элементы BPMN вы знаете?](#13-Какие-элементы-BPMN-вы-знаете)

## SQL и базы данных

[14. Зачем нужны индексы в таблицах БД?](#14-Зачем-нужны-индексы-в-таблицах-БД)

[15. Знакомы ли вы с нормализацией баз данных?](#15-Знакомы-ли-вы-с-нормализацией-баз-данных)

[16. Какие виды JOIN запросов вы знаете?](#16-Какие-виды-JOIN-запросов-вы-знаете)

[17. Чем TRANCATE отличается от DELETE?](#17-Чем-TRANCATE-отличается-от-DELETE)

[18. Что такое транзакция?](#18-Что-такое-транзакция)

[19. Какими свойствами должна обладать транзакция? (ACID)](#19-Какими-свойствами-должна-обладать-транзакция-ACID)

[20. Чем отличается UNION от UNION ALL?](#20-Чем-отличается-UNION-от-UNION-ALL)

[21. Что такое первичный ключ?](#21-Что-такое-первичный-ключ)

[22. Что такое внешний ключ?](#22-Что-такое-внешний-ключ)

[23. Какие бывают представления в БД?](#23-Какие-бывают-представления-в-БД)

[24. Для чего используется HAVING в SQL?](#24-Для-чего-используется-HAVING-в-SQL)

[25. Какие бывают БД?](#25-Какие-бывают-БД)

## Интеграция

[27. Что такое XML и что в нем содержится?](#27-Что-такое-XML-и-что-в-нем-содержится)

[26. Что такое XSD?](#26-Что-такое-XSD)

[28. Чем sequence отличается от choice в XSD?](#28-Чем-sequence-отличается-от-choice-в-XSD)

[29. Что такое пространство имен в XML?](#29-Что-такое-пространство-имен-в-XML)

[30. Что такое WSDL?](#30-Что-такое-WSDL)

[31. Чем SOAP отличается от REST?](#31-Чем-SOAP-отличается-от-REST)

[32. Из чего состоит сообщение в SOAP?](#32-Из-чего-состоит-сообщение-в-SOAP)

[33. Что содержит HEADER в ответе REST?](#33-Что-содержит-HEADER-в-ответе-REST)

[34. Чем отличается ошибка 200 от 201?](#34-Чем-отличается-ошибка-200-от-201)

[35. Какие методы REST вы знаете?](#35-Какие-методы-REST-вы-знаете)

[36. Напишите пример rest-API для книжной библиотеки (напишите методы, эндпоинты и пример JSON)](#36-Напишите-пример-rest-API-для-книжной-библиотеки)

[37. Знаете ли вы CAP-теорему?](#37-Знаете-ли-вы-CAP-теорему)

[38. Что такое идемпотентность?](#38-Что-такое-идемпотентность)

[39. Что такое очередь сообщений?](#39-Что-такое-очередь-сообщений)

[40. Что такое брокер сообщений?](#40-Что-такое-брокер-сообщений)

[41. Что такое корпоративная шина ESB?](#41-Что-такое-корпоративная-шина-ESB)

[42. Чем корпоративная шина отличается от ETL – инструмента?](#42-Чем-корпоративная-шина-отличается-от-ETL-инструмента)

[43. Что такое синхронные и асинхронные вызовы?](#43-Что-такое-синхронные-и-асинхронные-вызовы)

[44. Как брокер сообщений гарантирует доставку сообщений?](#44-Как-брокер-сообщений-гарантирует-доставку-сообщений)

[45. Чем Kafka отличается от RabbitMQ?](#13-Чем-Kafka-отличается-от-RabbitMQ)

[46. Есть две системы. Назовите все способы интеграции этих систем](#46-Есть-две-системы-Назовите-все-способы-интеграции-этих-систем)

[47. Клиент читает в Kafka два последних сообщения. Как тому же клиенту заново прочитать эти два последние сообщения?](#47-Клиент-читает-в-Kafka-два-последних-сообщения-Как-тому-же-клиенту-заново-прочитать-эти-два-последние-сообщения)

[48. Опишите все способы снизить нагрузку на вебсервис](#48-Опишите-все-способы-снизить-нагрузку-на-вебсервис)

[49. Что такое монолитная архитектура?](#49-Что-такое-монолитная-архитектура)

[50. Что такое SOA?](#50-Что-такое-SOA)

[51. Что такое микросервисная архитектура?](#51-Что-такое-микросервисная-архитектура)

[52. Что такое Хореография и Оркестрация?](#52-Что-такое-Хореография-и-Оркестрация)

_Как проверить, что сообщение брокера получено в полном объеме?_

_Приходилось ли вам проектировать взаимодействие информационных систем?_

_К корпоративной шине подключены веб-сервисы. В одном веб-сервисе появились два новых обязательных поля. Что изменится в интеграции?_

_Есть некий UI, нужно написать к нему веб-сервис. Опишите вашу постановку – что в ней будет._

_Есть две системы. Назовите все способы интеграции этих систем._

_Какие виды/способы интеграции вы знаете?_

## Методологии разработки ПО

[6. Чем Kanban отличается от Scrum?](#6-Чем-Kanban-отличается-от-Scrum)

[7. Какие бывают подходы к разработке?](#7-Какие-бывают-подходы-к-разработке)

[10. Какие существуют этапы разработки?](#10-Какие-существуют-этапы-разработки)



## Прочие вопросы

[19. Что такое абсолютные и относительные ссылки?](#19-Что-такое-абсолютные-и-относительные-ссылки)

[23. Что такое бизнес процесс?](#20-Что-такое-бизнес-процесс)

[24. Чем авторизация отличается от аутентификации?](#24-Чем-авторизация-отличается-от-аутентификации)

[25. Чем отличается валидация от верификации?](#25-Чем-отличается-валидация-от-верификации)

[26. Что такое протоколы SFTP и FTP и какая между ними разница?](#26-Что-такое-протоколы-SFTP-и-FTP-и-какая-между-ними-разница)

[27. Какие уровни протоколов знаете?](#27-Какие-уровни-протоколов-знаете)


## Требования

## 1. Какие виды требований вы знаете?

Функциональные и Нефункциональные

[к оглавлению](#Требования)

## 2. Что такое функциональные требования?

Функциональные требования (functional requirements) — описание требуемого поведения системы в определенных условиях.
Функциональные требования определяют, каким должно быть поведение продукта в тех или иных условиях. 
Они определяют, что разработчики должны создать, чтобы пользователи смогли выполнить свои задачи (пользовательские требования) в рамках бизнес-требований.

[к оглавлению](#Требования)

## 3. Что такое НЕфункциональные требования?

`Нефункциональные требования` – это четкие критерии того, как система должна работать, в отличие от функциональных, которые описывают, что система должна делать.

`Нефункциональные требования` — требования, определяющие свойства, которые система должна демонстрировать, или ограничения, которые она должна соблюдать, не относящиеся к поведению системы. 
Например, производительность, удобство сопровождения, расширяемость, надежность, факторы эксплуатации. Требования, которые подразумеваются или преобразованы из высокоуровневого требования.

![image](https://myslide.ru/documents_4/466f7ee98584a6c0130bca7bd65391fd/img5.jpg)

[к оглавлению](#Требования)

## 4. Критерии требований

-Полнота 
- Осуществимость 
- Необходимость 
- Конкретность 
- Приоритезированность 
- Недвусмысленность 
- Проверяемость

[к оглавлению](#Требования)

## 5. Заинтересованные лица (стейкхолдеры) - кто это и как с ними взаимодействовать?

`Стейкхолдеры` — это люди или группы, которые влияют на проект или на компанию в целом. Стейкхолдерами могут быть клиенты, сотрудники, акционеры, поставщики и другие заинтересованные лица.
Стейкхолдер (stakeholder) — это лицо, которое имеет интересы относительно проекта или организации или влияет на проект или организацию.

Стейкхолдеры бывают внутренние (например, сотрудники и руководство) и внешние (например, клиенты, поставщики, общественность). 
Каждый стейкхолдер имеет свои уникальные цели, ожидания и потребности, вносит свой вклад в проект или организацию.

**Внутренние стейкхолдеры**. Это группы и лица, которые находятся внутри организации или проекта и прямо участвуют в его деятельности. К ним относятся:

* Руководство и сотрудники. 
* Владельцы и акционеры.

**Внешние стейкхолдеры.** Это группы и лица, которые находятся за пределами организации или проекта, но заинтересованы в их результатах и влияют на них. Внешними стейкхолдерами могут быть:

* Клиенты и пользователи. 
* Партнёры по бизнесу.
* Государственные органы и регуляторы. 
* Общественность и неправительственные организации.

![image](https://github.com/artemaverin/summary/assets/97846877/9a31979e-d765-457a-a125-efc06907b022)

[к оглавлению](#Требования)

## 6. User story и Use case

User Story и Use Case - это инструменты аналитика по сбору клиентских требований

**User story** - это описание простым и понятным языком, того что нужно клиенту и для чего. Разговор бизнеса и аналитика.Обычно историю можно кратко описать по шаблону:

`Я (роль пользователя) хочу (описание того что нужно сделать) с помощью (инструмент или процесс) для (для чего мне это нужно? например сокращения издержек по времени)`

**Use story** - это перевод бизнес задачи на язык понятный разработчикам. Пошагово расписываются роли, задачи, место в приложении где что-то нужно добавить/исправить максимально ясно,четко и однозначно.
- -----

_User story_ — для чего клиенту продукт (пассажир хочет самостоятельно распечатать посадочный талон для посадки на рейс).

_Use case_ — как этот продукт должен работать. Это описание поведения системы при взаимодействии с кем-то или чем-то из внешней среды (стороннее приложение или пользователь). (говорят: “юз кейсы”). Пользователь не может совершить 2 шага подряд.

[к оглавлению](#Требования)

## 7. Какие существуют техники сбора требований?

`интервью` - беседа один на один с конкретным стейкхолдером, с заранее оговоренными вопросами. В рамках данной беседы выясняются и уточняются требования посредством дробления глобальной задачи на более мелкие и детального обсуждения каждой из этих подзадач

`мозговой штурм` - формат групповой встречи с участием стейкхолдеров, целью которой является генерация как можно большего количества идей  и требований без их фильтрации

`воркшоп` - совещание с участием заказчика и команды разработки с целью принятия и выработки единого решения и противоречий в рамках заданной темы

## Нотации UML и BPMN

## 8. Какими нотациями вы владеете?

- `Блок-схема` (в основном под алгоритмы)
https://docs.google.com/document/d/1dlwJd1brdHCSWWIMCyAWzrPKZ3eyzjMc9aS_m5cdzDk/edit

- `EPC` (Event-Driven Process Chain — событийная цепочка процессов) используется для описания процессов нижнего уровня
https://docs.google.com/document/d/1TTGRTWtWcc9Hs2ZwIkFIqIYEerlDFbNGdjk8znBS5Z0/edit

- `UML`
https://docs.google.com/document/d/1ivrj7yAg3Bx4DQsdlDzvrk3ilmhx5esdMFk_ki5LjgQ/edit#heading=h.ybfk4ofsso

- `BPMN 2.0`
https://docs.google.com/document/d/15oM59LZxiZq_nFDKLcPg2ljNUB7OzGa5uo2eK5aeLCQ/edit#heading=h.5r0o6fbrkp7z

- `Семейство IDEF`
https://docs.google.com/document/d/1oaDJ4sPnH6VdI7p2wYGgxsW9akaHV-JLat0xVf3Hw2Y/edit#heading=h.noe8as5cv3kr

Сравнение EPC и BPMN

https://docs.google.com/document/d/128AjQPa56f09OExebYQNxCHsvdsy7C9lmUTvOgKOqCo/edit#heading=h.isy65fclwb7w

[к оглавлению](#Нотации-UML-и-BPMN)

## 9. Какие бывают виды UML диаграм?

![image](https://github.com/artemaverin/summary/assets/97846877/7d6869eb-8b59-4909-b8a1-2eab3e8ec0c4)


**Диаграмма классов** - представляет  собой тип диаграммы статической структуры,  которая описывает структуру системы, показывая классы системы, их атрибуты, операции (или методы) и отношения между объектами.

**Диаграмма деятельности** - по сути, представляет собой расширенную версию блок-схемы, которая моделирует поток от одного действия к другому.

**Диаграммы последовательностей UML**  — это диаграммы взаимодействия, в которых подробно описывается, как выполняются операции. Они фиксируют взаимодействие между объектами в контексте сотрудничества. Диаграммы последовательности ориентированы на время и визуально показывают порядок взаимодействия, используя вертикальную ось диаграммы для представления времени, когда и какие сообщения отправляются.

![image](https://github.com/artemaverin/summary/assets/97846877/c15413be-2f5c-4887-b403-6dba667e39bd)

**Диаграмма состояния** - поведение объекта является не только прямым следствием его входных данных, но также зависит от его предшествующего состояния. Прошлую историю объекта лучше всего можно смоделировать с помощью диаграммы конечного автомата или традиционно называемого автоматом.

![image](https://github.com/artemaverin/summary/assets/97846877/b5ce155e-6925-4df2-9c3f-41d6cb27be3e)

**Диаграмма  вариантов  использования UML** — это основная форма требований к системе/программному обеспечению для новой недостаточно разработанной программы. Варианты использования определяют ожидаемое поведение (что), а не точный метод его реализации (как).

**Диаграммы связи UML**  , как и  диаграммы последовательности  — своего рода диаграммы взаимодействия, показывают, как взаимодействуют объекты. Диаграмма связи — это расширение диаграммы объектов, которое показывает объекты вместе с сообщениями, которые передаются от одного к другому. В дополнение к ассоциациям между объектами диаграмма связи показывает сообщения, которые объекты посылают друг другу.

![image](https://github.com/artemaverin/summary/assets/97846877/7678e5ad-7527-4a17-9c5c-61b0c3a52bf1)

**Диаграммы компонентов UML** используются при моделировании физических аспектов объектно-ориентированных систем, которые используются для визуализации, спецификации и документирования систем на основе компонентов, а также для создания исполняемых систем путем прямого и обратного проектирования.

Диаграммы компонентов — это, по сути, диаграммы классов, которые фокусируются на компонентах системы, которые часто используются для моделирования статического представления реализации системы.

**Диаграмма  развертывания UML**  — это диаграмма, которая показывает конфигурацию узлов обработки во время выполнения и компонентов, которые находятся на них. Диаграммы развертывания — это своего рода структурная диаграмма, используемая при моделировании физических аспектов объектно-ориентированной системы. Они часто используются для моделирования статического представления развертывания системы (топологии оборудования).

**Диаграмма объекта**
Объект — это экземпляр определенного момента времени выполнения, включая объекты и значения данных. Статическая  диаграмма объектов UML  является экземпляром  диаграммы классов ; он показывает снимок подробного состояния системы в определенный момент времени, поэтому диаграмма объектов охватывает объекты и их отношения в определенный момент времени.

[к оглавлению](#Нотации-UML-и-BPMN)

## 10. Какие бывают виды BPMN диаграм?

В BPMN существует 4 вида диаграмм:

- Процесс (Process Diagram)
Описывает содержание и логику бизнес-процесса BPMN в виде потока задач, условий и событий. Это самый распространенный, часто применяемый вид диаграмм, он является основой нотации BPMN.
![image](https://github.com/artemaverin/summary/assets/97846877/60fa546a-18ef-4ab0-953c-decac696febc)

- Взаимодействие (Collaboration Diagram)
Позволяет моделировать взаимодействие (обмен данными) между двумя или более бизнес-процессами BPMN. Для графического отображения такого взаимодействия используются потоки сообщений (message flow)
![image](https://github.com/artemaverin/summary/assets/97846877/bd98e4ff-c5b6-4ed5-976d-9854d27105f3)

- Хореография (Choreography Diagram)
Иногда диаграммы "Взаимодействие" оказываются слишком сложными для восприятия и требуют более наглядного представления. В этом случае применяют диаграммы хореографии. Они описывают поток (последовательность) взаимодействий участников при выполнении бизнес-процессов BPMN.
![image](https://github.com/artemaverin/summary/assets/97846877/a235b75f-b14f-4ed1-9b6e-a241f0260c02)


- Диалог (Conversation Diagram)
Является еще одним вариантом диаграммы для визуализации взаимодействий бизнес-процессов BPMN и их участников. Диаграмма "Диалог" описывает процессный ландшафт и взаимодействия верхнего уровня между вовлеченными сторонами.

![image](https://github.com/artemaverin/summary/assets/97846877/0d1cdadc-c6ab-4805-bded-dfad65686f37)

[к оглавлению](#Нотации-UML-и-BPMN)

## 11. Составьте схему BPMN для процесса, описывающего работу банкомата

![new-bpmn-diagram (1)](https://github.com/artemaverin/summary/assets/97846877/cfe6d5a9-2f07-4ea3-b5ca-eca8c9cb1a0e)

## 12. Какие бывают Gateway в BPMN?

Шлюзы BPMN (или Логические операторы BPMN) используются для контроля слияния и ветвления потоков управления. Если контроль потока управления не нужен, то шлюзы можно не использовать. Принцип работы шлюза похож на пропускное устройство, которое позволяет пройти через него в определенных направлениях и при определенных условиях.

![image](https://github.com/artemaverin/summary/assets/97846877/d2c17f60-e803-4c73-9203-bde3a8b23709)

[к оглавлению](#Нотации-UML-и-BPMN)

## 13. Какие элементы BPMN вы знаете?

Алфавит нотации BPMN включает следующие элементы:

**События (Events):**

* Начальное событие (Start Event): обозначает начало бизнес-процесса.
* Промежуточное событие (Intermediate Event): представляет собой событие, которое происходит во время выполнения процесса.
* Конечное событие (End Event): обозначает завершение бизнес-процесса.

**Задачи (Tasks):**

* Пул (Pool)
* Задача (Task): представляет собой действие или задачу, которую должен выполнить участник процесса.
* Подзадача (Sub-Task): представляет собой более мелкую задачу, которая является частью более крупной задачи.

**Шлюзы (Gateways):**

* Исключающее шлюз (Exclusive Gateway): используется для принятия решения на основе условий, выбирая один из нескольких исходящих потоков.
* Включающее шлюз (Inclusive Gateway): используется для определения различных вариантов выполнения процесса, где одновременно могут быть выбраны несколько исходящих потоков.
* Событийное шлюз (Event-Based Gateway): используется для управления потоком выполнения на основе возникновения событий.

**Потоки (Flows):**

* Поток сообщений (Message Flow): представляет передачу сообщений между двумя участниками процесса.
* Поток данных (Data Flow): обозначает передачу данных между элементами процесса.

**Участники (Participants):**

* Бизнес-участник (Business Participant): представляет бизнес-роль или организацию, которая участвует в бизнес-процессе.



В нотации BPMN выделяют пять основных категорий элементов:
- элементы потока (события, процессы и шлюзы);
- данные (объекты данных и базы данных);
- соединяющие элементы (потоки управления, потоки сообщений и ассоциации);
- зоны ответственности (пулы и дорожки);
- артефакты (сноски)

[к оглавлению](#Нотации-UML-и-BPMN)

# SQL и базы данных

## 14.Зачем нужны индексы в таблицах БД?

Индекс — объект базы данных, создаваемый с целью повышения производительности поиска данных. 

**Кластерный индекс** – это индекс, который физически упорядочивает данные (фактически биты на диске) определенным образом. Когда в таблицу поступают новые данные, то они сохраняются в том же порядке.

Ограничение в отношении кластерного индекса заключается в том, что для таблицы БД можно создать только один кластерный индекс. Это происходит из-за его природы – кластерные индексы обеспечивают соблюдение порядка данных. К тому же кластерные индексы увеличивают время записи, поскольку при добавлении новых данных все данные необходимо переупорядочить. Однако кластерные индексы могут значительно увеличить скорость чтения данных из таблицы.
```
Таким образом, главное, что необходимо понимать – это то, что кластерные индексы упорядочивают данные физически (на диске) в кластерах.
```
В большинстве систем управления базами данных (далее – СУБД) кластерный индекс строится автоматически на основании первичного ключа. Если в таблице нет первичного ключа, то для построения кластерного индекса будет использовано поле, объявленное как UNIQUE. Если же в таблице нет уникального поля, то можем создать индекс на основании любого из полей, по которому мы желаем сортировать данные в таблице.

По умолчанию кластерный индекс создается на основе B-tree, т.е. самобалансирующееся дерево. B-деревья стараются оставаться сбалансированными. При этом количество данных в каждой ветви дерева примерно одинаково. Следовательно, количество уровней, которые необходимо пройти, чтобы найти строки, всегда примерно одинаково. Такие индексы можно эффективно использовать для запросов на равенство и диапазона. Они могут работать со всеми типами данных, а также могут быть использованы для получения значений NULL.

**Некластерные индексы** – это индексы, которые хранят отдельный список упорядочивания, в котором есть указатели на физические строки. В основном это похоже на указатель в книге, поскольку такой указатель знает, на какой странице начинается или заканчивается та или иная глава. Таким образом, в отличие от кластерного индекса, таблица может иметь много некластерных индексов. Но стоит понимать важный момент – каждый новый некластерный индекс увеличивает время, которое необходимо для записи новых строк в таблицу.
```
Таким образом, некластерные индексы не упорядочивают данные физически, они просто хранят список порядка данных.
```
Некластерные индексы используются для увеличения скорости запросов к таблице. Некластерные индексы указывают на адреса памяти вместо хранения самих данных. Поэтому они медленнее для запросов, чем кластерные индексы. Однако обычно они намного быстрее, чем неиндексированный столбец.

![image](https://github.com/artemaverin/summary/assets/97846877/d05ae7ab-9735-4feb-937b-a1f7191db775)

[к оглавлению](#SQL-и-базы-данных)

## 15. Знакомы ли вы с нормализацией баз данных?

https://job4j.ru/profile/exercise/179/task-view/819

Нормализация БД – это процесс организации данных определенным образом и рекомендации по проектированию. Т.е. таблицы и связи между ними (отношения) создаются в соответствии с правилами. В результате обеспечивается некоторый уровень безопасности данных. К тому же устраняются несогласованные зависимости и избыточность.

Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.

избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управление данными не гибким и не очень удобным. Отсюда можно сделать вывод, что нормализация нужна для:

- Устранения аномалий
- Повышения производительности
- Повышения удобства управления данными

Нормальная форма базы данных – это набор правил и критериев, которым должна отвечать база данных.

Процесс нормализации – это последовательный процесс приведения базы данных к эталонному виду, т.е. переход от одной нормальной формы к следующей.

* Ненормализованная форма или нулевая нормальная форма (UNF)
* Первая нормальная форма (1NF)
* Вторая нормальная форма (2NF)
* Третья нормальная форма (3NF)
* Нормальная форма Бойса-Кодда (BCNF)
* Четвертая нормальная форма (4NF)
* Пятая нормальная форма (5NF)
* Доменно-ключевая нормальная форма (DKNF)
* Шестая нормальная форма (6NF)

**первая нормальная форма (1NF)**

Переменная отношения находится в первой нормальной форме (далее – 1НФ) тогда и только тогда, когда каждый атрибут отношения содержит строго одно атомарное значение.

Если упростить, то можно сказать, что каждый атрибут отношения атомарен (неделим) и система управления БД (далее - СУБД) не должна оперировать отдельной частью атрибута.

https://info-comp.ru/first-normal-form

Требование первой нормальной формы (1NF) очень простое и оно заключается в том, чтобы таблицы соответствовали реляционной модели данных и соблюдали определённые реляционные принципы.

Таким образом, чтобы база данных находилась в 1 нормальной форме, необходимо чтобы ее таблицы соблюдали следующие реляционные принципы:

- В таблице не должно быть дублирующих строк
- В каждой ячейке таблицы хранится атомарное значение (одно не составное значение)
- В столбце хранятся данные одного типа
- Отсутствуют массивы и списки в любом виде

Правило: **Строки, столбцы и ячейки в таблицах необходимо использовать строго по назначению.**

* Назначение строк – хранить данные
* Назначение столбцов – хранить структурную информацию
* Назначение ячеек – хранить атомарное значение

**вторая нормальная форма (2NF)**

Переменная отношения находится во второй нормальной форме (далее – 2НФ) тогда и только тогда, когда она находится в 1НФ и каждый ее неключевой атрибут функционально полно зависит от любого потенциального ключа.

Т.е. ни один атрибут, не входящий в состав потенциального ключа, не должен функционально зависеть от части какого бы то ни было из потенциальных ключей.

https://info-comp.ru/second-normal-form

Чтобы база данных находилась во второй нормальной форме (2NF), необходимо чтобы ее таблицы удовлетворяли следующим требованиям:

- Таблица должна находиться в первой нормальной форме
- Таблица должна иметь ключ
- Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)

Если ключ составной, т.е. состоит из нескольких столбцов, то все остальные неключевые столбцы должны зависеть от всего ключа, т.е. от всех столбцов в этом ключе. Если какой-то атрибут (столбец) зависит только от одного столбца в ключе, значит, база данных не находится во второй нормальной форме.

Иными словами, в таблице не должно быть данных, которые можно получить, зная только половину ключа, т.е. только один столбец из составного ключа.

Главное правило второй нормальной формы (2NF) звучит следующим образом
```
Таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку.
```

**третья нормальная форма (3NF)**

Переменная отношения находится в третьей нормальной форме (далее – 3НФ) тогда и только тогда, когда она находится во второй нормальной форме, и каждый ее неключевой атрибут нетранзитивно зависит от первичного ключа. Т.е. в отношении не должно быть атрибутов, которые не входят в состав первичного ключа и при этом транзитивно зависящих от первичного ключа.

https://info-comp.ru/third-normal-form

Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.

Транзитивная зависимость – это когда неключевые столбцы зависят от значений других неключевых столбцов.

Если: 
- в первой нормальной форме наше внимание было нацелено на ***соблюдение реляционных принципов***, 
- во второй нормальной форме в центре нашего внимания был ***первичный ключ***,
- то в третьей нормальной форме все наше внимание уделено ***столбцам***, которые ***не являются первичным ключом***, т.е. неключевым столбцам.

Иными словами, неключевые столбцы не должны пытаться играть роль ключа в таблице, т.е. они действительно должны быть неключевыми столбцами, такие столбцы не дают возможности получить данные из других столбцов, они дают возможность посмотреть на информацию, которая в них содержится, так как в этом их назначение.

Главное правило третьей нормальной форме (3NF) звучит следующим образом:

```
Таблица должна содержать правильные неключевые столбцы
```

***Нормальная форма Бойса-Кодда (BCNF)***

https://info-comp.ru/boyes-codd-normal-form

Требования нормальной формы Бойса-Кодда следующие:

- Таблица должна находиться в третьей нормальной форме. Здесь все как обычно, т.е. как и у всех остальных нормальных форм, первое требование заключается в том, чтобы таблица находилась в предыдущей нормальной форме, в данном случае в третьей нормальной форме;
- Ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов.
- 
Отсюда следует, что требования нормальной формы Бойса-Кодда предъявляются только к таблицам, у которых первичный ключ составной. Таблицы, у которых первичный ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной форме Бойса-Кодда.

Главное правило нормальной формы Бойса-Кодда (BCNF) звучит следующим образом:
```
Часть составного первичного ключа не должна зависеть от неключевого столбца.
```
[к оглавлению](#SQL-и-базы-данных)

## 16. Какие виды JOIN запросов вы знаете?

![image](https://github.com/artemaverin/summary/assets/97846877/9a41a92c-0b04-4a27-bec3-ac9843923d4a)

**INNER JOIN** - Из строк левой_таблицы и правой_таблицы объединяются и возвращаются только те строки, по которым выполняются условия_соединения.

**LEFT OUTER JOIN** - Возвращаются все строки левой_таблицы (ключевое слово LEFT). Данными правой_таблицы дополняются только те строки левой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк правой_таблицы вставляются NULL-значения.

**RIGHT OUTER JOIN** - Возвращаются все строки правой_таблицы (ключевое слово RIGHT). Данными левой_таблицы дополняются только те строки правой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк левой_таблицы вставляются NULL-значения.

**FULL OUTER JOIN** - Возвращаются все строки левой_таблицы и правой_таблицы. Если для строк левой_таблицы и правой_таблицы выполняются условия_соединения, то они объединяются в одну строку. Для строк, для которых не выполняются условия_соединения, NULL-значения вставляются на место левой_таблицы, либо на место правой_таблицы, в зависимости от того данных какой таблицы в строке не имеется.

**CROSS JOIN** - Объединение каждой строки левой_таблицы со всеми строками правой_таблицы. Этот вид соединения иногда называют декартовым произведением.

[к оглавлению](#SQL-и-базы-данных)

## 17. Чем TRANCATE отличается от DELETE?

![image](https://github.com/artemaverin/summary/assets/97846877/0f9af2e7-99d4-4e84-a67c-d8cc93fb777d)

[к оглавлению](#SQL-и-базы-данных)

## 18. Что такое транзакция?

https://job4j.ru/profile/exercise/179/task-view/800

Транзакция – это совокупность операций с БД, которые представляют собой логически неделимую единицу. При этом операции могут быть выполнены или целиком и успешно (должны быть соблюдены все правила консистентности БД и не зависит от параллельных транзакций), или же не выполнены вообще (при этом ни одна из операций, которые входят в совокупность, не должна внести изменения в БД).

Если говорить немного проще, то это совокупность операций, который или целиком и успешно завершится, или целиком отменяется в случае ошибки при выполнении любой из входящих в транзакцию операции.

При этом также к определению транзакции добавляют, что они являются единицей восстановления и конкурентного доступа.

Соответственно, обобщим все сказанное:

1. Всегда или выполнится, или не выполнится целиком;

2. Может быть использована для восстановления из-за сбоев и отказов системы. В случае сбоя системы во время выполнения транзакции методы восстановления отменяют любое влияние транзакции на базу данных.

3. Обеспечивает механизм конкурентного доступа к данным.

[к оглавлению](#SQL-и-базы-данных)

## 19. Какими свойствами должна обладать транзакция? (ACID)

https://job4j.ru/profile/exercise/179/task/806/393958

поговорим про свойства транзакций. Эти свойства известны под аббревиатурой ACID, которая получается из первых букв следующих английских слов:

1. Atomicity (атомарность);

2. Consistency (согласованность);

3. Isolation (изолированность);

4. Durability (устойчивость).

Представленные свойства обеспечивают точность и целостность данных в БД и гарантируют, что данные не будут повреждены в результате некоторого сбоя, обеспечивая при этом достоверность данных даже при возникновении ошибок или сбоев.

**Атомарность** (atomicity) означает, что транзакция не может быть выполнена частично. Таким образом, всегда все операции транзакции будут выполнены (все и до конца) или же не будут выполнены (ни одна, т.е. все изменения данных будут отменены).

Таким образом, согласно этому свойству промежуточного пути нет или транзакции не происходят частично. Каждая транзакция рассматривается как единое целое и должна выполниться полностью. При этом она включает следующие операции:

- прерывание выполнения: если транзакция прерывается, то изменения, внесенные в БД, не видны;
- фиксация изменений: если транзакция завершается успешно, то внесенные изменения в БД будут зафиксированы в БД.

**Согласованность** (consistency) означает, что успешно завершенная транзакция гарантированно сохраняет согласованность БД, т.е. фиксируются только допустимые результаты изменения данных (они не должны противоречить никаким ограничениям, которые реализованы на уровне СУБД или добавленные отдельно в БД проверки, триггеры и т.д.). Иногда проверки дополнительных условий реализуются непосредственно в коде транзакции.

Важно, что в процессе выполнения транзакции согласованность БД может нарушаться. Например, в представленном выше примере на рисунке во время выполнения операций одновременно обоими клиентами существует момент, когда баланс счета источника уже уменьшен, а баланс счета приемника еще не увеличен. Проще говоря деньги «ушли в никуда». Однако это внутреннее состояние СУБД не показывается другим транзакциям, которые работают с теми же данными, т.е. извне транзакции нарушения согласованности «почти» никогда не видны. Здесь мы говорим «почти» потому что существуют способы на свой страх и риск получить доступ к промежуточным состояниям БД. Однако лучше этого не делать.

Если ссылаться на пример выше, то для согласованности данных необходимо сохранить общую сумму до и после транзакции.

Итого до выполнения транзакции: T = 500 + 200 = 700.

Итого после выполнения транзакции: T = 400 + 300 = 700.

Таким образом, данные БД согласованны. Несогласованность возникает в том случае, если T1 завершается успешно, а Т2 терпит неудачу.

**Изолированность** (isolation) означает, что несколько выполняемых параллельно транзакций не должны влиять на результат выполнения друг друга.

Транзакции происходят независимо, без помех. Изменения, которые происходят в конкретной транзакции, не будут видны ни в одной другой транзакции, пока это изменение в транзакции не будет записано в память или не будет зафиксировано. Изолированность гарантирует, что одновременное выполнение транзакций приведет к состоянию, которое эквивалентно состоянию, в котором транзакции были выполнены последовательно в некотором порядке.

**Устойчивость** (durability) означает, что СУБД самостоятельно решает все «внутренние проблемы» и гарантирует, что после завершения транзакции (как успешного, так и неуспешного), все необходимые изменения были или зафиксированы, или отменены и что БД не окажется в некотором «промежуточном состоянии». Чаще всего это свойство ассоциируют с устойчивостью к сбоям в аппаратном обеспечении, сетевом взаимодействии и т.д. Даже в таких условиях СУБД всегда «в курсе», какие операции были выполнены и после возвращения к нормальным условиям работы может удостовериться, что данные не повреждены (или же сообщить о возникших проблемах).

[к оглавлению](#SQL-и-базы-данных)

## 20. Чем отличается UNION от UNION ALL?

https://job4j.ru/profile/exercise/179/task/976/395770

Операторы множества в SQL – это ключевые слова, которые позволяют объединить результаты двух и более запросов в один.

Существует несколько различных операторов множества, которые можно использовать в зависимости от наших потребностей и используемой системы управления базами данных (далее – СУБД).

В задании рассмотрим следующие операторы множества:

- UNION;
- UNION ALL;
- INTERSECT;
- EXCEPT.

```
SELECT first_select_query
set_operator
SELECT second_select_query;
```

Таким образом, операторы множества используют два и более запроса SELECT, при этом оператор множества ставится между запросами SELECT.

Однако есть некоторые ограничения, о которых необходимо обязательно помнить:

- при выборе столбцов в каждом из запросов SELECT количество столбцов должно совпадать;
- типы данных каждого из столбцов должны быть совместимыми;
- порядок столбцов в каждом из запросов SELECT должны быть одинаковыми.

Оператор множества UNION позволяет объединить результаты двух запросов. Этот оператор удаляет все повторяющиеся строки и показывает нам комбинацию обоих результатов выборок SELECT.

Оператор множества UNION ALL также объединяет результаты двух и более запросов. Однако в отличие от UNION, он не удаляет дубликаты

В чем же разница между UNION и UNION ALL? Основное различие между операторами заключается в том, что UNION удаляет все повторяющиеся результаты из окончательного набора результатов, а UNION ALL – нет. UNION выполняет DISTINCT для набора результатов, чтобы удалить дубликаты.

Таким образом, UNION ALL почти всегда будет показывать больше результатов, так как не удаляет повторяющиеся записи.

Стоит подчеркнуть, что UNION будет выполняться медленнее, чем UNION ALL, поскольку там присутствует операция по удалению повторяющихся значений (DISTINCT) – эта операция, как известно, является дорогостоящей частью запроса.

Таким образом, если нам не нужны уникальные строки в результирующем наборе или если мы уверены, что строки в базе данных или запросе уже уникальны, то стоит использовать UNION ALL.

[к оглавлению](#SQL-и-базы-данных)

## 21. Что такое первичный ключ?

первичный ключ (primary key) - это поле в таблице, однозначно идентифицирующее каждую строку (запись) в таблице БД. Первичный ключ должен содержать уникальные значения. Также не может содержать null. В таблице может быть только один первичный ключ. Ключ может состоять из одного и более полей. Первичный ключ, состоящий из нескольких полей, называется составным ключом.

Первичный ключ выбирается так, чтобы он состоял из минимально возможного количества полей. Например, если есть поля "имя", "фамилия", "дата рождения" и "номер телефона", нет смысла делать составной ключ из нескольких полей, так как имеется поле "номер телефона", и по нему одному мы можем в будущем уникально идентифицировать записи, так как номер телефона не может повторяться.

Так как в реляционных БД все таблицы почти всегда связаны друг с другом, первичные ключи используются для однозначной организации этой связи.

[к оглавлению](#SQL-и-базы-данных)

## 22. Что такое внешний ключ?

Для связи между собой таблиц существует понятие "внешний ключ" (foreign key). Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

[к оглавлению](#SQL-и-базы-данных)

## 23. Какие бывают представления в БД?

https://job4j.ru/profile/exercise/179/task-view/787

представления - это другой тип таблиц, поскольку представления по умолчанию не существуют физически, т.е. их содержимое не сохраняется на диске.

**Представления (views)** – это объекты базы данных, которые всегда создаются на основе одной или более базовых таблиц (или других представлений), используя информацию метаданных. Эта информация (включая имя представления и способ получения строк из базовых таблиц) – все, что сохраняется физически для представления. Именно по этой причине представления также называют виртуальными таблицами. упрощенно, это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени.

**Материализованное представление** – это объект базы данных, значением которого является сохраненный результат заранее выполненного запроса, заданного при создании материализованного представления. Повторное вычисление и сохранение полученного результата происходит согласно правилам, которые определяются при создании материализованного представления.

В упрощенном виде – это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени, и результат выполнения этого запроса сохраняется для дальнейшего использования.

Таким образом, мы выяснили, что представления можно условно поделить на 2 типа:

- «обычные» представления, результат вычисления которых нигде не сохраняется;
- материализованные представления, результат вычисления которых сохраняется и может быть повторно использован.

Отразим эти различия следующим образом:

1. Представление:

- при создании представления просто фиксируется то, что с этого момента некоторый SQL-запрос можно не писать заново, а вызывать по заранее заданному имени.
- только при вызове этого запроса по его имени происходит (заново каждый раз) реальное чтение данных из таблиц, на которое ссылается представление.

**Материализованное представление:**

- при создании представления фиксируется то, что с этого момента некоторый SQL-запрос можно не писать заново, а вызывать по заранее заданному имени.
- результат выполнения запроса фиксируется во временном хранилище.
- обновление хранилища происходит согласно алгоритму, который указывается при создании представления.
- при вызове запроса чтение происходит из временного хранилища.

Мы уже определили, что представления строятся на основе SQL-запросов. Соответственно:

- основой для построения представления может быть только SELECT-запрос (т.е. нельзя построить представление на основе запросов с INSERT, UPDATE, DELETE);
- иногда представление допускает так называемые двунаправленные отношения, т.е. с его использованием можно будет не только читать данные, но и изменять их. В рамках нашего курса это не рассматривается.

**Преимущества:**

1. Упрощение выполнения запросов. Как мы уже обсудили, представление может быть построено на SQL-запросе любой сложности. Поэтому при использовании представлений нам уже не придется переписывать запрос, который может состоять даже из 100 строк. Нам будет достаточно вызвать представление SELECT * FROM представление и в итоге получить тот же результат;

2. Возможность построения простого и надежного API. На стадии проектирования БД мы можем предусмотреть набор удобных представлений, т.е. мы можем заранее скрыть от разработчика сложные запросы, что, в свою очередь, упростит разработку приложения и к тому же снизит количество ошибок при разработке.

3. Упрощение бизнес-логики. В принципе, это следует из предыдущего пункта. Однако даже если мы не строим полноценный API, мы все равно можем заранее сформировать набор для наиболее сложных и часто встречаемых запросов.

4. Минимум накладных расходов. Представление (это касается простых представлений) практически не занимает места в БД, потому даже создание сотен и тысяч представлений не приводит к ощутимому увеличению размера БД.

5. Безопасность. Представления являются объектами БД, потому к ним применимы все механизмы СУБД по контролю прав доступа.

**Недостатки:**

1. Избыточность. Иногда представления просто не нужны. Например, БД небольшая, бизнес-логика простая, модель безопасности тривиальная. В таком случае представления чаще всего будут лишними.

2. Дополнительный код. Представления, как и все остальное, необходимо создавать, что ведет за собой остальные операции – тестирование, корректировка при изменении БД или бизнес-логики. Соответственно, растут трудозатраты и повышается вероятность появления ошибок.

3. Ограниченность возможностей. Мы уже говорили, что представления можно использовать для модификации данных. Однако это имеет много ограничений, поэтому можно утверждать, что не любую операцию с БД можно выполнить с помощью представлений.

Создание представления
```
create view имя_представления as запрос_select
```

```
create view show_students_with_2_or_more_books
    as select s.name as student, count(a.name), a.name as author from students as s
         join orders o on s.id = o.student_id
         join books b on o.book_id = b.id
         join authors a on b.author_id = a.id
         group by (s.name, a.name) having count(a.name) >= 2;
```

Вызов представления
```
select * from show_students_with_2_or_more_books;
```

изменить представление

```
alter view старое_имя rename to новое_имя
```

Удалить представление

```
drop view имя_представления
```
[к оглавлению](#SQL-и-базы-данных)

## 24. Для чего используется HAVING в SQL?

Ранее мы рассмотрели метод where. Однако, у него есть одно ограничение – его нельзя использовать с агрегатными функциями. Для этих целей специально служит оператор having. Применяется он аналогично where, только в нем обязательно должна быть агрегатная функция.

Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций.

Основное различие между WHERE и HAVING в SQL-запросах заключается в том, что WHERE используется для фильтрации строк до применения к ним групповых функций (например, SUM(), AVG(), COUNT()), а HAVING применяется после применения групповых функций и позволяет отфильтровать итоговые группы.

Например:
```
SELECT column_name(s)
FROM table_name
WHERE condition(s);
```
В этом запросе WHERE используется для применения условий фильтрации к отдельным строкам перед применением групповых функций.
```
SELECT column_name(s), function()
FROM table_name
GROUP BY column_name
HAVING condition;
```
Здесь HAVING используется для фильтрации групп после применения групповых функций. Это позволяет дополнительно отфильтровать группы на основе условия.

Важно отметить, что вы не можете использовать WHERE для группировки данных, вы должны использовать HAVING для этой цели.

Также стоит отметить, что в некоторых случаях использование HAVING может быть более эффективным, чем использование WHERE с подзапросом, особенно если подзапрос содержит сложную логику или соединения.

[к оглавлению](#SQL-и-базы-данных)

## 25. Какие бывают БД?

**Реляционная база данных** (SQL) — база, где данные хранятся в формате таблиц, они строго структурированы и связаны друг с другом. В таблице есть строки и столбцы, каждая строка представляет отдельную запись, а столбец — поле с назначенным ей типом данных. В каждой ячейке информация записана по шаблону.
Основная особенность — надежность и неизменяемость данных, низкий риск потери информации. При обновлении данных их целостность гарантирована, они заменяются в одной таблице.
Реляционные БД идеальны для работы со структурированными данными, структура которых не подвержена частым изменениям.


**Нереляционная база данных (NoSQL)** — хранит данные без четких связей друг с другом и четкой структуры. Вместо структурированных таблиц внутри базы находится множество разнородных документов, в том числе изображения, видео и даже публикации в социальных сетях. В отличие от реляционных БД, NoSQL базы данных не поддерживают запросы SQL.
Особенности. В отличие от реляционных, в нереляционных базах данных схема данных является динамической и может меняться в любой момент времени. К данным сложнее получить доступ, то есть найти внутри базы что-то нужное — с таблицей это просто, достаточно знать координаты ячейки. Зато такие СУБД отличаются производительностью и скоростью.
Базы данных NoSQL подходят для хранения больших объемов неструктурированной информации, а также хороши для быстрой разработки и тестирования гипотез.


_Четыре вида нереляционных баз данных_
- **Документоориентированные** базы данных — данные хранятся в коллекциях документов, обычно с использованием форматов JSON, XML или BSON
- Базы данных **ключ-значение** — каждая запись имеет ключ и значение. Её используют такие базы данных, когда данные не слишком сложные, а скорость является приоритетом.
- **Графовые** базы данных — состоят из узлов и связей между ними. Узлы обозначают элементы в базе данных, а связи между ними определяют их отношения между собой.
- **Колоночные** СУБД — хороший вариант для обработки больших данных, отличаются высокой производительностью, эффективным сжатием данных и отличной масштабируемостью.

![image](https://github.com/artemaverin/summary/assets/97846877/263e7a23-2a7b-46b6-b8ab-bca278b046bb)

[к оглавлению](#SQL-и-базы-данных)


# Интеграция

## 26. Что такое XML и что в нем содержится?

Расширяемый язык разметки (XML) – это язык разметки, который предоставляет правила для определения любых данных.

Файл XML представляет собой текстовый документ, в котором присутствуют теги для описания структуры и других его функций. Теги пишут в угловых скобках, причём их всегда два – один открывает запись, другим она заканчивается.

В отличие от других языков программирования, XML не может выполнять вычислительные операции сам по себе. Вместо этого для управления структурированными данными можно использовать любой язык программирования или программное обеспечение.

XML содержит мета-данные (об именах полей, классов, вложенности структур)

[к оглавлению](#Интеграция)

## 27. Что такое XSD?

XSD (XML Schema Definition) - это язык описания структуры XML-документов. Он определяет структуру, элементы и атрибуты документа XML. XSD позволяет проверить, соответствует ли XML-документ заданной структуре, и помогает обеспечить его корректность.

XSD — это язык описания структуры XML документа. Его также называют XML Schema. При использовании XML Schema XML парсер может проверить не только правильность синтаксиса XML документа, но также его структуру, модель содержания и типы данных.
Такой подход позволяет объектно-ориентированным языкам программирования легко создавать объекты в памяти, что, несомненно, удобнее, чем разбирать XML как обычный текстовый файл.

[к оглавлению](#Интеграция)

## 28. Чем sequence отличается от choice в XSD?

XSD-схемы могут содержать различные элементы, включая sequence и choice. Sequence указывает порядок, в котором должны быть представлены элементы в документе, а choice – позволяет выбирать из нескольких элементов только один.

[к оглавлению](#Интеграция)

## 29. Что такое пространство имен в XML?

Пространство имен в XML - это способ организации элементов и атрибутов в иерархическую структуру. Оно позволяет определять уникальные идентификаторы для элементов и атрибутов, а также задавать отношения между ними. Это делается с помощью механизма URI (Унифицированный идентификатор ресурса), который связывает элементы и атрибуты с определенными пространствами имен.

В XML-документе пространство имен указывается с помощью атрибута xmlns (XML Namespace), который содержит URI пространства имен. Этот атрибут может быть указан как для корневого элемента документа, так и для отдельных элементов и атрибутов. Если атрибут xmlns не указан, то элемент или атрибут считается принадлежащим пространству имен по умолчанию.

Использование пространств имен в XML позволяет избежать конфликтов имен элементов и атрибутов и обеспечивает возможность повторного использования и модульности кода.

[к оглавлению](#Интеграция)


## 30. Что такое WSDL?

WSDL (Web Services Description Language) - это язык описания веб-сервисов, который определяет структуру и функциональность веб-сервиса, а также протоколы и форматы данных, используемые для обмена информацией между клиентом и сервером. WSDL позволяет другим приложениям и системам понимать и использовать функции веб-сервиса, независимо от того, на каком языке программирования он написан и какие технологии используются для его разработки.

WSDL и XSD являются двумя разными стандартами, связанными с веб-сервисами и обменом данными. Вот основные различия между ними:

- WSDL (Язык описания веб-сервисов) определяет интерфейс веб-сервиса и включает информацию о том, какие операции доступны, какие параметры они принимают и какие результаты возвращают. Он также определяет формат сообщений, используемых для обмена данными между сервисом и клиентами.
- XSD (XML Schema Definition) описывает структуру XML-документов и определяет, какие элементы, атрибуты, типы данных и ограничения могут быть использованы в документе. Она используется для проверки правильности структуры XML-документа и обеспечения его соответствия требованиям.
- WSDL используется для описания веб-сервисов и определения их интерфейса, в то время как XSD используется для определения структуры XML-сообщений, используемых в обмене данными между веб-сервисом и клиентами.
- WSDL может использовать XSD для определения структуры сообщений, но не ограничивается только использованием XSD. Он также может определять другие форматы сообщений, такие как JSON или SOAP.
- WSDL определяет протоколы и форматы данных для обмена информацией, в то время как XSD только определяет структуру данных.

[к оглавлению](#Интеграция)

## 31. Чем SOAP отличается от REST?

REST:

https://skillbox.ru/media/code/rest-api-chto-eto-takoe-i-kak-rabotaet/

https://www.youtube.com/watch?v=XaTwnKLQi4A



REST и SOAP на самом деле не сопоставимы. REST — это архитектурный стиль. SOAP — это формат обмена сообщениями. Давайте сравним популярные реализации стилей REST и SOAP.

Пример реализации RESTful: JSON через HTTP
Пример реализации SOAP: XML поверх SOAP через HTTP

На верхнем уровне SOAP ограничивает структуры ваших сообщений, тогда как REST — это архитектурный подход, ориентированный на использование HTTP в качестве транспортного протокола.

![image](https://github.com/artemaverin/summary/assets/97846877/4cbc3f4d-9a18-4b23-9d52-4ec9e529d473)

[к оглавлению](#Интеграция)

## 32. Из чего состоит сообщение в SOAP?

SOAP-сообщение – это обычный XML-документ, содержащий следующие элементы:
- Конверт – определяет начало и конец сообщения. Это обязательный элемент.
- Заголовок – содержит любые необязательные атрибуты сообщения, используемые при обработке сообщения, либо в промежуточной точке, либо в конечной конечной точке. Это необязательный элемент.
- Тело – содержит данные XML, содержащие отправляемое сообщение. Это обязательный элемент.
- Неисправность – необязательный элемент неисправности, который предоставляет информацию об ошибках, возникающих при обработке сообщения.

![image](https://github.com/artemaverin/summary/assets/97846877/abd13126-43f0-4a86-9449-08af8a7fe96a)

![image](https://github.com/artemaverin/summary/assets/97846877/2f36b00a-bcea-44b3-af65-15ca68b99aba)

[к оглавлению](#Интеграция)

## 33. Что содержит HEADER в ответе REST?

Заголовок (header) в REST API — это часть запроса или ответа, которая содержит метаданные о содержимом сообщения, например тип контента или кодировку. Заголовки используются для передачи информации о запросах и ответах между клиентом и сервером. Некоторые общие примеры заголовков в REST API включают: Content-Type, Accept, Authorization и Cache-Control. Клиент может указать заголовки в запросе, а сервер может возвращать заголовки в ответе, чтобы согласовать параметры с клиентом.

![image](https://github.com/artemaverin/summary/assets/97846877/a99743f3-7d3d-4a82-bbdb-bf3eb02ff9e7)

[к оглавлению](#Интеграция)

## 34. Чем отличается ошибка 200 от 201?

https://ru.hostings.info/schools/kody-vseh-oshibok.html#:~:text=200%20OK.%20Сервер%20обработал%20запрос,но%20будет%20обрабатывать%20его%20позже

**200 Ok**
Сервер обработал запрос браузера (пользователя) и передал ему то, что он хотел. А пользователь должен увидеть сайт или файл, который запрашивал.

**201 Created**
Код сообщает, что сервером создан новый идентификатор URI. В ответе сервера (заголовок Location) можно найти место куда именно были помещены созданные данные.

[к оглавлению](#Интеграция)

## 35. Какие методы REST вы знаете?

* GET - метод используется для получения данных. Он не изменяет состояние сервера и не вносит изменения на стороне сервера.
* POST - метод используется, когда вы хотите добавить или создать ресурс на сервере.
* PUT - метод используется при обновлении ресурса на сервере. Он заменяет существующий ресурс на новый.
* PATCH - метод применяется, когда нужно внести изменения в определенный аспект ресурса.
* DELETE - метод удаляет ресурс на сервере.
- -
* OPTIONS - метод возвращает информацию о поддерживаемых методах для конкретного ресурса.
* HEAD - метод аналогичен GET, но возвращает только заголовки, без тела ответа.
* TRACE - метод отправляет обратно запрошенные данные, которые помогут увидеть, где и по какой причине произошла ошибка.
* CONNECT - метод используется для создания туннеля через защищенный протокол, такой как HTTPS.

[к оглавлению](#Интеграция)

## 36. Напишите пример rest-API для книжной библиотеки (напишите методы, эндпоинты и пример JSON)

В этом примере мы будем использовать формат JSON для обмена данными между библиотекой и клиентами. Допустим, у нас есть API, который позволяет пользователям получать информацию о книгах.

Пример запроса:


```java
GET /api/v1/books?title=harry%20potter HTTP/1.1
Host: mylibrary.com
Accept: application/json
```

Пример ответа:

```java
[
  {
    "id": 1,
    "title": "Harry Potter and the Sorcerer's Stone",
    "author": "J.K. Rowling",
    "genre": "Fantasy",
    "pages": 324,
    "published_date": "January 1998"
  },
  {
    "id": 2,
    ...
  }
]
```
Этот API позволяет пользователю искать книги по их заголовкам. В ответе мы видим список объектов, каждый из которых представляет одну книгу. Каждый объект содержит свойства, такие как идентификатор книги (id), название, автор, жанр, количество страниц и дата публикации.

Эндопоинты:
```java
/books: Получить список книг
/books/{id}: Получить информацию о книге по ее ID
/authors: Получить список авторов
/borrowings: Получить информацию о выдачах книг
/categories: Получить список категорий книг
/genres: Получить список жанров книг
/book_author: Связать книгу с автором
/book_category: Связать книгу с категорией
/book_genre: Связать книгу с жанром
/book/create: Создать новую книгу
/author/create: Создать нового автора
/category/create: Создать новую категорию
/genre/create: Создать новый жанр
/book/borrow: Взять книгу на выдачу
/book/return: Вернуть книгу
```

[к оглавлению](#Интеграция)

## 37. Знаете ли вы CAP-теорему?

В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств:

- C (consistency) — согласованность. Каждое чтение даст вам самую последнюю запись.
- A (availability) — доступность. Каждый узел (не упавший) всегда успешно выполняет запросы (на чтение и запись).
- P (partition tolerance) — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга.

![image](https://github.com/artemaverin/summary/assets/97846877/0aed38c1-2f13-4de1-9b34-d4d72fe5a0d3)

[к оглавлению](#Интеграция)

## 38. Что такое идемпотентность?

![image](https://github.com/artemaverin/summary/assets/97846877/fe0eaa3f-39cf-4ffa-8cee-22d75743db3f)

[к оглавлению](#Интеграция)

## 39. Что такое очередь сообщений?

**Очередь сообщений** – это форма асинхронной коммуникации между сервисами, применяемая в бессерверных и микросервисных архитектурах. Сообщения хранятся в очереди, пока не будут обработаны и удалены. Каждое сообщение обрабатывается только один раз и только одним потребителем. Очереди сообщений могут использоваться для разъединения сложных процессов обработки, для буферизации или организации пакетной обработки, а также для сглаживания пиковых нагрузок.

[к оглавлению](#Интеграция)

## 40. Что такое брокер сообщений?

**Брокер сообщений** — это программный компонент, который служит посредником между различными компонентами распределенной системы. В его работе используются две основные сущности: producer (отправитель) и consumer (потребитель/подписчик). Он обрабатывает сообщения, полученные от отправителей, и перенаправляет к соответствующим потребителям. Такое ПО реализуется как часть общей архитектуры системы, либо как отдельный сервис.

**Брокер сообщений** — это программное обеспечение для связи между приложениями, системами и службами, помогающее им обмениваться информацией друг с другом. Это делается посредством перевода сообщений из одного формального протокола обмена сообщениями в другой. Таким образом независимые службы могут «общаться» между собой напрямую, даже если они написаны на разных языках или реализованы на разных платформах.

`Очередь сообщений - это структура данных, или контейнер, способ хранения сообщений для последующего использования. Брокер сообщений-это отдельный компонент, который управляет очередями.`

- Распределение нагрузки: если у вас есть много пользователей, которые отправляют запросы одновременно, то очередь сообщений поможет распределить нагрузку между серверами.
- Асинхронная связь: доставка и чтение сообщений может происходить в разное время, когда удобно получатель будет готов получить его и не блокируется.
- Улучшение производительности: если вы используете очередь сообщений, то это может улучшить производительность вашей системы. Запросы будут обрабатываться быстрее, тк они не будут блокироваться на сервере.
- Гарантия порядка доставки: сама структура данных гарантирует что данные будут попадать и храниться в очереди в порядке добавления в нее.
- Гарантия доставки: данные будут доставлены в любом случае (если есть получатель сообщений).
- Масштабирование: если система будет расширяться, то можно добавить дополнительные серверы и использовать очередь сообщений для распределения нагрузки между ними.
- Отказоустойчивость: в случае сбоев в процессе передачи сообщения, то они будут добавлены в очередь позднее после восстановления системы.
- Безопасность: очередь сообщений может помочь защитить систему например от  ддос атак, тк она позволяет ограничить количество запросов, которые могут быть отправлены на сервер одновременно.
- Слабое связывание: при передаче сообщение через очередь возникают неявные связи между процессами, что позволяет им быть изолированными друг от друга и независимыми

[к оглавлению](#Интеграция)

## 41. Что такое корпоративная шина ESB?
Сервисная/Корпоративная шина предприятия (англ. enterprise service bus, ESB) — это связующее `программное обеспечение`, обеспечивающее `централизованный` и унифицированный событийно-ориентированный `обмен сообщениями` между различными информационными системами на принципах сервис-ориентированной архитектуры.

![image](https://github.com/artemaverin/summary/assets/97846877/0f511537-5409-41b4-8fd3-69c71e4207e8)

Брокеры сообщений облегчают обмен данными "точка-точка" между двумя приложениями. Если на предприятии много приложений и им необходимо взаимодействовать друг с другом, включение двухточечной связи между каждой парой **приведет к созданию сложной архитектуры, которой трудно управлять и устранять неполадки**. Кроме того, даже связь "один ко многим" также приводит к сетчатому шаблону связи, которым трудно управлять.

ESB решает эту проблему, **внедряя компонент, подобный центральной шине, к которому подключаются все приложения**. Таким образом, ESB устраняет необходимость в соединении "один к одному" между приложениями. Он обеспечивает подключаемую архитектуру связи, которая относительно упрощает подключение новых приложений к существующей инфраструктуре.

[к оглавлению](#Интеграция)

## 42. Чем корпоративная шина отличается от ETL – инструмента?

https://aws.amazon.com/ru/what-is/etl/

Извлечение, преобразование и загрузка (ETL) – это процесс объединения данных из нескольких источников в одном центральном хранилище, которое называется складом данных. ETL использует набор бизнес-правил для очистки и упорядочения необработанных данных и их подготовки к хранению, анализу данных и машинному обучению (ML). Вы можете решать определенные задачи бизнес-аналитики путем анализа данных (например, прогнозирование результата принятия бизнес-решений, генерирование отчетов и панелей управления, сокращение числа неэффективных операций и так далее).

Корпоративная шина (Enterprise Service Bus, ESB) и ETL-инструменты (Extract, Transform, Load – извлечение, преобразование, загрузка) имеют разные функции и роли в процессе обработки данных.

* Функции: Корпоративная шина используется для интеграции и согласования сервисов и приложений в рамках предприятия. Она обеспечивает передачу данных между различными системами, управляет коммуникацией между ними и обеспечивает безопасность передачи информации.
ETL-инструменты, с другой стороны, используются для сбора, преобразования и загрузки данных из различных источников в целевую систему или хранилище. Они выполняют операции извлечения данных из разных источников, их преобразования в нужный формат и загрузку в целевое место хранения.

* Роль в процессе работы с данными: Корпоративная шина играет роль “моста” между приложениями и сервисами, обеспечивая их взаимодействие. ETL-инструменты служат для предварительной обработки и подготовки данных перед загрузкой в целевую систему.

* Масштабируемость: Корпоративная шина может масштабироваться и адаптироваться к изменениям в структуре предприятия и используемых приложениях. ETL-инструменты обычно оптимизированы для работы с определенными типами источников данных и хранилищ, и их масштабируемость может быть ограничена.

[к оглавлению](#Интеграция)

## 43. Что такое синхронные и асинхронные вызовы?

Синхронизация означает, что при вызове функции вызов не возвращается, пока не будет получен результат

Асинхронный вызов процедуры, вызывающий не получает результат сразу. 
Часть, которая фактически обрабатывает этот вызов, находится после того, как вызов произведен

[к оглавлению](#Интеграция)

## 44. Как брокер сообщений гарантирует доставку сообщений?

Kafka обеспечивает гарантии доставки сообщений с помощью механизма подтверждений. Когда сообщение отправляется в Kafka, оно сохраняется в топике, который может иметь несколько партиций. Каждая партиция — это упорядоченный список сообщений, которые хранятся на одном сервере. После сохранения сообщения в топике Kafka отправляет подтверждение обратно отправителю, чтобы сообщить ему о том, что сообщение было получено.

[к оглавлению](#Интеграция)

## 45. Чем Kafka отличается от RabbitMQ?

![image](https://github.com/artemaverin/summary/assets/97846877/ce564a5b-acfb-41c7-9970-0517529abd45)

[к оглавлению](#Интеграция)

## 46. Есть две системы. Назовите все способы интеграции этих систем

1. Прямая интеграция: Системы соединяются напрямую через API или другие механизмы обмена данными.
2. Использование общей базы данных: Системы подключаются к общей базе данных, что позволяет им обмениваться данными друг с другом.
3. Использование шины сообщений: Системы обмениваются сообщениями через общую шину сообщений.
4. Использование очереди сообщений: Системы используют очередь сообщений для асинхронного обмена данными.
5. Использование событий: Системы подписываются на события друг друга и реагируют на них.
6. Использование RESTful API: Системы взаимодействуют друг с другом через RESTful API.
7. Использование GraphQL: GraphQL позволяет системам запрашивать и обновлять данные друг друга.
8. Использование микросервисов: Системы взаимодействуют через набор

[к оглавлению](#Интеграция)

## 47. Клиент читает в Kafka два последних сообщения. Как тому же клиенту заново прочитать эти два последние сообщения?

Для того чтобы клиенту заново прочитать два последних сообщения в Kafka, ему нужно выполнить следующие шаги:

1. Получить offset последнего прочитанного сообщения: клиент должен сохранить offset сообщения, которое он прочитал последним. Этот offset можно получить из свойства Consumer.position или с помощью API GetOffsetShell.
2. Откатиться к сохраненному offset: клиент использует команду seek() для отката к сохраненному offset. Это заставит клиента повторно прочитать все сообщения с момента сохранения offset.
3. Прочитать два последних сообщения: после того как клиент откатился к сохраненному offset, он может прочитать два последних сообщения, начиная с текущего offset и двигаясь назад.
4. Сохранить новый offset последнего сообщения: после прочтения двух последних сообщений, клиент должен сохранить новый offset последнего прочитанного сообщения для дальнейшего использования.

Важно отметить, что этот процесс может привести к дублированию сообщений, если они были добавлены в Kafka после сохранения offset клиентом. В таком случае, нужно настроить параметры конфигурации клиента, чтобы обеспечить нужную степень де-дупликации сообщений.

[к оглавлению](#Интеграция)


## 48. Опишите все способы снизить нагрузку на вебсервис.

1. Оптимизация запросов к базе данных: используйте индексы, кеширование, выбор наиболее подходящих SQL-запросов и т.д.
2. Кэширование данных: сохраняйте часто используемые данные на стороне сервера или клиента для уменьшения количества запросов к базе данных.
3. Минификация и сжатие кода: уменьшите размер передаваемых файлов, чтобы сократить время загрузки страницы.
4. Оптимизация изображений: уменьшайте размер изображений, используйте форматы с лучшим сжатием (например, WebP вместо JPEG).
5. Использование CDN (Content Delivery Network): CDN кэширует контент на разных серверах по всему миру, уменьшая нагрузку на основной сервер.
6. Использование балансировщика нагрузки: равномерно распределяет нагрузку между несколькими серверами.
7. Автоматическое масштабирование: автоматически увеличивает или уменьшает количество серверов в зависимости от нагрузки на веб-сервис.
8. Асинхронная обработка запросов: позволяет обрабатывать несколько запросов одновременно, уменьшая время ожидания пользователя.
9/ Разделение сервиса на микросервисы: разбиение большой системы на более мелкие и специализированные компоненты может снизить нагрузку на каждый из них.

[к оглавлению](#Интеграция)

## 49. Что такое монолитная архитектура?

Концепция монолитного программного обеспечения заключается в том, что различные компоненты приложения объединяются в одну программу на одной платформе. Обычно монолитное приложение состоит из базы данных, клиентского пользовательского интерфейса и серверного приложения. Все части программного обеспечения унифицированы, и все его функции управляются в одном месте.

![image](https://github.com/artemaverin/summary/assets/97846877/785bdc12-a15b-42f3-8db5-71bff3b2ddff)

Плюсы:

- Упрощенная разработка и развертывание
- Лучшая производительность

Минусы:

- Кодовая база со временем становится громоздкой
- Сложно внедрять новые технологии
- Ограниченная гибкость (В монолитных приложениях каждое небольшое обновление требует полного повторного развертывания.)

[к оглавлению](#Интеграция)

## 50. Что такое SOA?

**Сервис-ориентированная архитектура** (далее SOA — service-oriented architecture) — это стиль архитектуры программного обеспечения, который предполагает модульное приложение, состоящее из дискретных и слабосвязанных программных агентов, которые выполняют конкретные функции. SOA разделяет компоненты по двум основным ролям: `поставщик` и `потребитель` сервисов. Обе эти роли могут играть программные агенты. Концепция SOA заключается в следующем: приложение может быть спроектировано и построено таким образом, что его модули легко интегрируются и могут быть легко использованы повторно.

Плюсы:

- Повторное использование сервисов
- Легкость в сопровождении (Поскольку каждая служба программного обеспечения является независимой единицей, ее легко обновлять и поддерживать, не затрагивая другие службы)
- Более высокая надежность (Службы легче отлаживать и тестировать, чем огромные куски кода, как в монолитах. Это, в свою очередь, делает продукты на основе SOA более надежными.)
- Параллельная разработка

Минусы:

- Высокие инвестиционные затраты
- Сложность в управлении
- Дополнительная нагрузка

[к оглавлению](#Интеграция)

## 51. Что такое микросервисная архитектура?

**Микросервисы** — это тип сервисно-ориентированной архитектуры программного обеспечения, ориентированный на создание ряда автономных компонентов, составляющих приложение. В отличие от монолитных приложений, созданных как единое целое, микросервисные приложения состоят из нескольких независимых компонентов, которые склеены вместе посредством API.

Плюсы

- Легко разрабатывать, тестировать и развертывать
- Повышенная гибкость
- Возможность масштабирования по горизонтали

Минусы:

- Сложность
- Проблемы безопасности
- Разные языки программирования

[к оглавлению](#Интеграция)

## 52. Что такое Хореография и Оркестрация?

![image](https://github.com/artemaverin/summary/assets/97846877/ea32a97c-26dc-4d0c-9dbf-824e10fcb521)

Одним из главных преимуществ и драйверов использования микросервисной архитектуры – это взаимная независимость микросервисов, т.к. каждый из них  является автономным приложением, даже со своим хранилищем данных (паттерн Database per Service). Это позволяет быстрее разрабатывать и разворачивать части большой системы силами разных разработчиков или команд. Однако, микросервис реализует конкретную задачу в рамках большой системы, поэтому итоговую ценность для потребителя приносит слаженная работа всех входящих в нее элементов. В этом и кроется наибольшая сложность проектирования и реализации микросервисной архитектуры, поскольку надо обеспечить согласованную работу различных сервисов в рамках единого бизнес-процесса.

Для этого проектировщику систему следует выбрать стиль коммуникации между сервисами: оркестрацию или хореографию. 

Оркестрация предполагает наличие единого центра управления, который «дирижирует всем оркестром», например, направляя запросы к различным микросервисам в зависимости от обрабатываемой бизнес-логики.

![image](https://github.com/artemaverin/summary/assets/97846877/0ff2268b-23d2-4043-a08f-5c83b45e4f2e)


Подобный центр управления отсутствует в хореографическом стиле, где нет явно определенного рабочего процесса, а работа сервисов реализуется реактивно: по реакции на определенный набор событий. Это подходит для сценариев с частым обновлением или заменой одних сервисов на другие. Также хореография подходит для serverless-платформ, когда все части большой системы имеют короткий период жизни и управляются событиями. Однако, хореографический паттерн усложняет развитие большой системы, когда количество микросервисов растет. Кроме того, из-за отсутствия единого центра управления бизнес-логика «размазывается» по всем микросервисам, что усложняет рефакторинг и развитие всей системы. Поэтому для моего традиционного примера с интернет-магазином я выбрала оркестрационный стиль коммуникации между сервисами, что и покажу далее.

![image](https://github.com/artemaverin/summary/assets/97846877/78d363af-7ce2-4357-96a7-c62106481784)

![image](https://github.com/artemaverin/summary/assets/97846877/08e4cb77-20ee-4597-8cbd-0e449485b3c3)


[к оглавлению](#Интеграция)

## _К корпоративной шине подключены веб-сервисы. В одном веб-сервисе появились два новых обязательных поля. Что изменится в интеграции?_

Для того чтобы обеспечить передачу данных из веб-сервиса с новыми обязательными полями в корпоративную шину, необходимо будет выполнить следующие шаги:

– Определить формат данных, которые должны быть отправлены через новые поля. Это может включать определение типа данных (строка, число, дата и т. д.), а также максимальной длины и допустимых значений, если это применимо.
– Обновить клиентскую часть веб-сервиса, чтобы она могла отправлять данные через новые обязательные поля. Это включает в себя обновление кода приложения, которое взаимодействует с веб-сервисом, чтобы оно могло корректно отправлять данные через новые поля.
– Настроить обработку новых полей на стороне корпоративной шины. Это может потребовать обновления логики обработки данных в интеграционном решении, чтобы оно было способно обрабатывать данные, поступающие через новые поля. Возможно, потребуется добавить новые проверки или обработку исключений, чтобы гарантировать, что данные соответствуют требуемому формату.
– Протестировать интеграцию с обновленным веб-сервисом. После внесения всех изменений необходимо провести тестирование, чтобы убедиться, что все работает правильно и данные передаются через новые обязательные поля без ошибок.

## _Есть некий UI, нужно написать к нему веб-сервис. Опишите вашу постановку – что в ней будет._

Мне нужно знать больше информации о вашем UI и требованиях к веб-сервису, чтобы дать точную постановку. Вот общий шаблон, который может помочь:

Проект: Разработка веб-сервиса для поддержки UI

Цель: Обеспечить функциональность и гибкость для разработчиков, использующих наш UI, путем предоставления надежного и безопасного веб-сервиса.

Описание: Веб-сервис будет предоставлять API для взаимодействия с нашим UI, позволяя разработчикам интегрировать его с другими системами и приложениями. Он будет включать набор конечных точек для выполнения основных операций, таких как аутентификация, регистрация, изменение профиля и доступ к данным.

Требования:

– Совместимость с различными языками программирования и платформами.
– Поддержка аутентификации и авторизации пользователей.
– Возможность расширения функциональности веб-сервиса в будущем.
– Безопасность данных пользователей и защита от атак.
– Интеграция с существующими системами и приложениями.

Технические спецификации:

– Веб-сервис должен быть построен на основе RESTful архитектуры с использованием одного из следующих стеков технологий (на выбор): .NET Core + C#; Node.js + JavaScript; Python + Django; Java + Spring Boot.

## Методологии разработки ПО

## 6. Чем Kanban отличается от Scrum?

![image](https://github.com/artemaverin/summary/assets/97846877/651ebcbf-c252-4a22-8a6c-d7f33f52e9ab)

![image](https://github.com/artemaverin/summary/assets/97846877/3d95d431-bd40-4fc8-8dda-9c518514636f)

[к оглавлению](#Методологии-разработки-ПО)

## 7 Какие бывают подходы к разработке?

Waterfall - подход основанный на последовательном выполнении задач о подробном документировании. Для данного подхода характерны такие моменты как:
- нежелательность любых изменений по ходу проекта
- следование установленным правилам
- ТЗ первично, разработка без него не начинается

**Agile манифест**

- Люди и взаимодействие важнее процессов и инструментов.
- Работающий продукт важнее исчерпывающей документации.
- Сотрудничество с заказчиком важнее согласования условий контракта.
- Готовность к изменениям важнее следования плану.

Agile + Scrum - в первую очередь это гибкий подход, при котором продукт первичен, документация и прочая бюрократия вторична. 
Характерные моменты:
- неиерархическое построение команды
- самоорганизация команды
- скорость и прозрачность работы

	Особенность Scrum данного подхода:
проект разбивается на временные периоды (спринты) в рамках которого решаются определенные задачи
в команде помимо разработчиков и владельца есть scrum - мастер - человек из команды следящий за scrum-ритуалами
рабочий процесс:
- планирование
- daily-встречи
- обзор и тестирование
- ретроспективы


Agile + Kanban
В отличии от Scrum, команда разбивает рабочие процессы не по времени, а по этапам:
- «В плане»
- «В работе»
- «Готово»

[к оглавлению](#Методологии-разработки-ПО)

## 10. Какие существуют этапы разработки?

**Планирование**: интервьюирование и описание требований в ходе которых выявляются цели, согласовываются сроки и цена
	
**Проектирование**: бизнес-аналитик и системный аналитик составляют схемы бизнес-процессов, определяют стек технологий и вырабатывают ТЗ

**Разработка/ реализация**:

команда разработчиков начинает реализацию задач:
	- фронтэнд - отрисовывает макет/интерфейс
	- бэкэнд реализует техническую часть
в итоге на данном этапе получаем тестовый вариант продукта

**Тестирование**:  тестировщики проводят различные виды тестирования на предмет соответствия требованиям.

**Доработка**: обнаруженные баги отправляются на доработку

**Интеграция**: идет внедрение продукта итогом которого станет принятие заказчиком проекта

**Поддержка**: поддержка готового продукта , начиная от инструкций и консультаций до изменений функционала

[к оглавлению](#Методологии-разработки-ПО)

## Прочие вопросы

## 19. Что такое абсолютные и относительные ссылки?

Абсолютные и относительные ссылки используются в программировании и интернет-ссылках для определения местоположения определенного ресурса.

Абсолютная ссылка:
– Начинается с указания полного пути к ресурсу от корня доменного имени.
– Не изменяется при копировании и вставке ссылки на другую страницу или сайт.
– Позволяет легко определить, на каком сайте находится ресурс.

Относительная ссылка:
– Указывает путь к ресурсу относительно текущей страницы.
– Может быть вставлена на любую страницу сайта или блога без изменения.
– Удобна для пользователей, так как позволяет быстро переходить к связанным ресурсам на том же сайте.

[к оглавлению](#Прочие-вопросы)

## 23. Что такое бизнес процесс?

Бизнес-процесс - это набор действий и операций, которые выполняются для достижения определенной цели в рамках компании или организации. 

Это могут быть процессы, связанные с производством товаров, оказанием услуг, управлением персоналом, логистикой, финансами и т.д. Каждый бизнес-процесс имеет свои входы, выходы, ресурсы и участников, а также определенную последовательность действий, которые необходимо выполнить для достижения желаемого результата. Оптимизация бизнес-процессов помогает улучшить эффективность работы компании, сократить затраты и повысить качество продукции или услуг.

[к оглавлению](#Прочие-вопросы)

## 24. Чем авторизация отличается от аутентификации?

**Авторизация** - это предоставление доступа к чему либо (сервису). это проверка прав пользователя на доступ к определенным ресурсам.

**Аутентификация** - проверки подлинности пользователя путём сравнения введённого им логина/пароля с данными сохранёнными в базе данных.

Пример: вход в личный кабинет на сайте. Для этого нужно пройти авторизацию, которая грубо говоря авторизация делится на идентификацию и аутентификацию. идентификацию - это ввод емэйла или телефона, чтобы понять кто заходит, а аутентификация - это как проверка подлинности - это ввод пароля или отпечатка пальца

[к оглавлению](#Прочие-вопросы)

## 25. Чем отличается валидация от верификации?

**Валидация** - это проверка на то что мы создали правильный продукт, те проверка на соответствие требованиям клиента.

**Верификация** - это проверка продукта после какой-либо стадии разработки на соответствие заданным критериям

Другими словами, верификация — это подтверждение того, что техническое задание было выполнено верно и в полном объеме. А валидация — проверка того, что итоговый продукт функционирует так, как от него и ожидалось.

Пример: создаем автомобиль. проверка есть ли тормоза, коробка передач, сцепление, руль, колеса, из какого материала кузов и тд - это будет верификация. А когда мы проверяем что это изделие имеет признаки автомобиля, те может ли оно ехать, и как ехать - это уже валидация.

[к оглавлению](#Прочие-вопросы)

## 26. Что такое протоколы SFTP и FTP и какая между ними разница?

Для того чтобы компьютерная сеть могла обмениваться данными, требуется набор различных устройств, таких как роутеры, коммутаторы и компьютеры. Затем эта сеть должна будет следовать протоколу, а скорее всего, нескольким протоколам, чтобы установить надежную связь между всеми этими устройствами. FTP и SFTP – это два таких протокола.

FTP создает возможность обмена файлами по сети, в то время как SFTP гарантирует безопасный доступ и передачу файловв потоке данных. Другими словами, FTP передает данные в виде простого текста, а SFTP шифрует их для отправки.

Главное различие между этими протоколами заключается в безопасности. FTP не предоставляет безопасный канал для передачи информации и файлов между несколькими устройствами, SFTP – предоставляет, поэтому он более безопасен.
Источник: https://bezopasnik.info

[к оглавлению](#Прочие-вопросы)

## 27. Какие уровни протоколов знаете?

По определению Википедии, интернет - это всемирная система объединённых компьютерных сетей для хранения и передачи информации, которая построена на базе стека протоколов TCP/IP. 
 
TCP/IP  — это сетевая модель, описывающая процесс передачи цифровых данных. В данной модели предполагается прохождение информации через четыре уровня, на каждом из которых работают определенные сетевые протоколы. Протоколы в свою очередь, это просто наборы правил, которые помогают упорядочить обмен данными между различными устройствами.  
 
Название TCP/IP происходит из двух важнейших протоколов этой модели — Transmission Control Protocol (TCP) и Internet Protocol (IP). 
 
Модель TCP/IP включает в себя следующие уровни - канальный (сетевых интерфейсов), сетевой, транспортный и прикладной:

![image](https://github.com/artemaverin/summary/assets/97846877/bd740fe9-9be6-4f55-b3ec-595aadb7701a)

Как java - программисты мы будем взаимодействовать с самым верхним уровнем - прикладным, тем не менее, каждый веб - программист должен в целом понимать работу всей модели TCP/IP , так как она является основой сети Интернет. 
 
На **прикладном** уровне работают различные программы и пользовательские приложения. Они используют протоколы для того, чтобы получить и передать информацию по сети. 
 
Большая часть приложений использует несколько протоколов. Например, Web-браузер использует DNS, чтобы определить IP - адрес по доменному имени и после этого использует HTTP, чтобы загрузить веб страницу с этого IP - адреса. Протокол SMTP используется для передачи почты, а FTP– для передачи файлов. 

Далее идёт **транспортный** уровень, он отвечает за доставку данных конкретному приложению. Например, если на вашем компьютере открыто несколько браузеров, как понять, в какой из них направлять данные, приходящие из сети? Для этого на транспортном уровне вводится понятие порта. Порт - это число, являющееся идентификатором какого - либо приложения или программы, запущенных на вашем устройстве. 
 
На транспортном уровне используются два протокола - UDP и TCP. 

TCP - это протокол, который обеспечивает надежность доставки. Он гарантирует доставку всех данных и правильный порядок следования сообщений. Протокол UDP не гарантирует доставку данных, но зато работает быстрее, чем TCP. Например, UDP нельзя использовать для передачи файлов или почты, так как все данные должны быть переданы в полном объеме и без искажений. Но для онлайн трансляции протокол UDP вполне подходит.   
 
Следующий уровень - **сетевой**, именно здесь работает протокол IP, отвечающий за логическую адресацию в компьютерных сетях. 
Задачей IP является объединение сетей, построенных на основе разных технологий канального уровня, в одну крупную объединенную сеть. 
Вторая важная задача протокола IP, это маршрутизация, то есть поиск маршрута от отправителя к получателю в крупной составной сети через промежуточные узлы - маршрутизаторы (роутеры).
 
 Протокол IP использует IP - адреса - это уникальные числовые идентификаторы устройств в сети. 
 
И последний уровень - **канальный** (сетевых интерфейсов). На нем определяется, как будет происходить передача информации в зависимости от используемой среды передачи данных (проводная или беспроводная среда). Здесь информация кодируется, делится на пакеты и отправляется по нужному каналу связи. 
 
 При передаче по сети данные проходят через каждый уровень модели TCP/IP, начиная с прикладного. Происходит инкапсуляция данных, на каждом уровне используемый сетевой протокол добавляет свой заголовок:

 ![image](https://github.com/artemaverin/summary/assets/97846877/50f48e66-60ba-4e2e-ab56-0a323799fb43)

 Во время приема данные проходят через все уровни в обратном порядке, происходит считывание и снятие заголовков. Этот процесс называется декапсуляцией.

 ![image](https://github.com/artemaverin/summary/assets/97846877/d682662f-f3ca-4f9b-b59d-8176f09a7c8c)



[к оглавлению](#Прочие-вопросы)

# Оглавление


1. [Создание массива numpy](#создание-массива-numpy)
2. [Информация из массива](#информация-из-массива)
3. [Типы данных и их преобразование](#типы-данных-и-их-преобразование)
4. [Двумерные и трехмерные массивы](#двумерные-и-трехмерные-массивы)
5. [Маска и слайсинг вместе, прихотливая индексация, а еще reshap](#маска-и-слайсинг)
6. [Транспонирование, унарные и бинарные функции](#транспонирование-унарные-и-бинарные-функции)

### Создание массива Numpy 
На самом деле способов создания массивов очень много, разберем некоторые:
- функция **numpy.array**(*list*/*tuple*)\
массив может быть создан из обычного *списка* или *кортежа* Python
```python
import numpy as np

arr_list = np.array([1, 2, 3, 4])
arr_tuple = np.array((1, 2, 3, 4))
Вывод:
[1 2 3 4]
[1 2 3 4]
```
**данная конструкция работает как с одномерными так и сдвумерными массивами*

- функция **numpy.zeros**(*shape, dtype=float, order='C'*)\
возвращает новый массив указанной формы и типа, заполненный нулями. в качестве параметра принимает целое число, список или кортеж целых чисел
```python
print(np.zeros(5))
 Вывод:
 [0. 0. 0. 0. 0.]
 ------------------------
 print(np.zeros((2, 3)))
 Вывод:
 [[0. 0. 0.]
 [0. 0. 0.]]
```
- функция **numpy.ones**(*shape, dtype=float, order='C'*) - аналогична функции zeros,но заполняет массив единицами
- функция **numpy.full**(*shape, fill_value, dtype=None, order='C'*) - возвращает новый массив указанной формы и типа, заполненный указанным значением fill_value
```python
print(np.full((2, 3), 666))
 Вывод:
 [[666 666 666]
 [666 666 666]]
```
- функция **numpy.arange**(*[start, ]stop, [step, ]dtype=None*) - возвращает одномерный массив с равномерно разнесенными значениями внутри заданного интервала
```python
print(np.arange(5))
 Вывод:
 [0 1 2 3 4]
```
- функция **numpy.copy**(*a, order='K'*) - возвращает массив-копию указанного объекта.
```python
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m2 = m1[3:6].copy()
m2[0] = 111
print(m1)
Вывод:
[32 13  5  4 67  8 22]
------------------------
# для сравнения без копии
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m2 = m1[3:6]
m2[0] = 111
print(m1)
Вывод:
[ 32  13   5 111  67   8  22]
```
**ВНИМАНИЕ!!** 
в обычных питоновских списках срез , например такой: list[:] уже будет копией

###  Информация из массива
Из массива можно получать различную информацию:
- встроенная функция **len()** - функция возвращает размер первого измерения
```python
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
 print(len(arr_list))
 Вывод:
 2
 print(len(arr_list[0]))
 Вывод:
 4
```
свойство массива - **shape**\
это - кортеж натуральных чисел, показывающий длину массива по каждой оси. 
```python
print(arr_list.shape)
 Вывод:
 (2, 4)
```

атрибут **ndim** - число измерений (чаще их называют "оси") массива.
+ Если ndim =1 значит у вас 1D array (см. выше). Он же одномерный массив.
+ Если ndim =2 значит у вас 2D array (см. выше). Он же двумерный массив. Она же матрица.
+ Если ndim =3 значит у вас 3D array (см. выше).
```python
 print(arr_list.ndim)
 Вывод:
 2
```

атрибут **dtype** описыввает тип элементов массива
```python
print(arr_list.dtype)
 Вывод:
 int32
```

Способы получения данных из масссива:
```python
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(arr_list[1][2])
Вывод:
7
print(arr_list[1, 2])
Вывод:
7
```

### Типы данных и их преобразование
массиву можно задать нужный тип данных например с помощью параметра *dtype*
```python
print(np.array([1, 2, 3], dtype='float64'))
Вывод:
[1. 2. 3.]
```
функция **NDArray.astype** возвращает копию массива преобразованного к указанному типу:
```python
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
arr2 = arr_list.astype(np.float64)
print(arr2)
Вывод:
[[1. 2. 3. 4.]
 [5. 6. 7. 8.]]
```
Рассмотрим случай преобразования данных float в int:
```python
arr1 = np.array([1.2, 3.4, 4.5, 3.1, 5.5], dtype=np.float64)
arr2 = arr1.astype(np.int32)
print(arr2)
Вывод:
[1 3 4 3 5]
```
Если поменять тип данных с float_ на int_, то numpy отрежет десятичную часть от каждого числа и оставит только целую.
Рассмотрим случай общего массива чисел и строк:
```python
arr1 = np.array([1.2, 3.4, '', 3.1, 5.5], dtype=np.float64)
Вывод:
ValueError: could not convert string to float: ''
```
с массивами numpy можно выполнять различные арифметические операции, результаты которых будут отличаться от обычных операций python
1. Умножение

```python
#Python
m1 = [1, 2, 3, 4]
print(m1 * 2)
Вывод:
[1, 2, 3, 4, 1, 2, 3, 4]
-------------------------
#Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 * 2)
Вывод:
[2 4 6 8]
```
В случае обычного листа с помощью умножения дублируем его дважды. В случае numpy перемножаем все элементы массива\
2. Сложение
```python
#Python
m1 = [1, 2, 3, 4]
print(m1 + 2)
Вывод:
TypeError: can only concatenate list (not "int") to list
-------------------------
#Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 + 2)
Вывод:
[3 4 5 6]
```
Аналогичная ситуация с операциями вычитания и деления, возведения в степень( ** ).\
Также все это работает и с массивами большей размерности\
Массивы можно также сравнивать между собой
```python
m1 = np.array([32, 13, 5])
m2 = np.array([54, 23, 2])
m3 = m1 > m2
print(m3)
Вывод:
[False False  True]
```
В результатье получаем булевский массив(* *сравнивать массивы numpy можно только одинаковой длины*)\
В созданных массивах можно менять значения обращаясь по индексу или массово через срез\
рассмотрим на примере одномерного массива:
```python
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m1[4] = 444
print(m1)
Вывод:
[ 32  13   5   4 444   8  22]
------------------------------
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m1[3:6] = 0
print(m1)
Вывод:
[32 13  5  0  0  0 22]
```
то же самое можно конечно работает и для 3-х мерного массива
```python
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d[0] = 0
print(arr3d)
Вывод:
[[[ 0  0  0]
  [ 0  0  0]]

 [[ 7  8  9]
  [10 11 12]]]
```
**важный факт!!**\
Если мы делаем слайс, например, m1[3:5], а затем присваиваем этот кусочек в новую переменную, то в новой переменной будет лежать ваш кусочек, который всё еще ссылается на основной массив.
```python
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m2 = m1[3:6]
m2[0] = 666
print(m1)
Вывод:
[ 32  13   5 666  67   8  22]
```

### Двумерные и трехмерные массивы
на примере двумерного массива разберем, как вырезать из него те или иные части
```
array[*срез по строкам/ срез по стобцам*]
```
```python
# информация по строкам
#1
m2d = np.array([[1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 12],
                [13, 14, 15, 16],
                [17, 18, 19, 20]])
print(m2d[2:4])
Вывод:
[[ 9 10 11 12]
 [13 14 15 16]]
 -------------------------------
 #2 возьмем все строки начиная со 2(начиня с индекса 1)
 print(m2d[1:])
 Вывод:
 [[ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]
 [17 18 19 20]]
 ===============================
# информация по солбцам
#1 возьмем 1-ый столбец
print(m2d[:, 0])
Вывод:
[ 1  5  9 13 17]
-------------------------------
#2 возьмем 2 столбца начиная со 2
print(m2d[:, 1:3])
Вывод:
[[ 2  3]
 [ 6  7]
 [10 11]
 [14 15]
 [18 19]]
```
данная конструкция позволяет выбирать и не стандартные сложные куски массива

```python
print(m2d[0:2, 0:2])
Вывод:
[[1 2]
 [5 6]]
 -------------------
 print(m2d[1:4, 1:3])
 Вывод:
 [[ 6  7]
 [10 11]
 [14 15]]
```
Есть также альтернативный вариант индексации - маска. Маска - это массив (одномерный или многомерный), который состоит из булевых значений. Если True - то элемент будет вытянут, если False - нет.
```Python
m = np.array([0, 1, 2, 3, 4]);
mask = [True, True, False,False, True]
print(m[mask])
Вывод:
[0 1 4]
```
![](https://ucarecdn.com/2707fa1a-60ca-413b-a7ae-37a96883d721/)
**Нужно помнить** , при обращении по маске, в отличие от индексов значения будут скопированы)\

Маска из примера выше задавалась явно через список, но ее также можно задать как условие
```python
m = np.array([5, 4, 3, 6, 8, 10]);
mask = m > 5
print(m[mask])
```
Пример использования маски:
```python
users = np.array(['Андрей', 'Иван', 'Николай', 'Александр', 'Андрей'])
visits = np.array([
    [1, 2, 1, 0, 0, 1, 1],
    [0, 0, 1, 0, 3, 1, 2],
    [2, 1, 0, 2, 0, 2, 1],
    [1, 2, 1, 0, 1, 1, 1],
    [1, 2, 1, 0, 0, 1, 0]
])
mask = users == 'Андрей'
print(visits[mask])
Вывод:
[[1 2 1 0 0 1 1]
 [1 2 1 0 0 1 0]]
```
Следует отметить что вместе с маской мы можем использовать и индексы для нужного среза данных
```python
print(visits[mask, 5:])
[[1 1]
 [1 0]]
```
Если необходима инверсия булевых значений(True заменить на False, а False на True), то не стоит использовать команду not. Для этого есть знак ~ (тильда). 
```python
mask = users == 'Андрей'
print(mask)
Вывод:
[ True False False False  True]
print(~mask)
Вывод:
[False  True  True  True False]
```
### Маска и слайсинг
При работе с numpy для логических операций вы не работаете со стандартными питоновскими and и or. У numpy свои операторы:\
Логическое ИЛИ:  ' | '\
Логическое И:  ' & '
```python
users = np.array(['Андрей', 'Иван', 'Николай', 'Александр', 'Андрей'])
mask1 = users == 'Иван'
print(mask1)
Вывод:
[False  True False False False]
mask2 = users == 'Александр'
print(mask2)
Вывод:
[False False False  True False]
print(mask2 & mask1)
Вывод:
[False False False False False]
print(mask2 | mask1)
Вывод:
[False  True False  True False]
```

Раньше мы умели вытягивать значения вот так:\
m2d[1, : ]  <- передаем конкретный индекс (один)\
m2d[1:4, : ]  <- передаем слайсинг (диапазон индексов)\
m2d[[True, True, False, True], : ]  <- передаем маску\
А теперь знаем еще про один способ - прихотливая индексация:\
m2d[[0, 2, 4], : ]  <- передаем список/массив с индексами по которым надо вытащить значения. Индексы могут идти не по порядку.

```python
visits = np.array([
    [1, 2, 1, 0, 0, 1, 1],
    [0, 0, 1, 0, 3, 1, 2],
    [2, 1, 0, 2, 0, 2, 1],
    [1, 2, 1, 0, 1, 1, 1],
    [1, 2, 1, 0, 0, 1, 0]
])
print(visits[[4, 2, 0]])
Вывод:
[[1 2 1 0 0 1 0]
 [2 1 0 2 0 2 1]
 [1 2 1 0 0 1 1]]
```
в следующей ситуации, при добавлении второго списка, указанные числа будут возвращать в одномерный массив элементы по индексам строк из певрого списка
```python
print(visits[[4, 2, 0], [1, 3, 5]])
Вывод:
[2 2 1]
```
Если же нам нужно "вырезать" какой-то определенный кусок из массива, можно сделать следующее:
```python
print(visits[[4, 2, 0]][:, [1, 2, 4]])
Вывод:
[[2 1 0]
 [1 0 0]
 [2 1 0]]
```
- функция **numpy.reshape**(*a, newshape, order='C'*) - изменяет форму массива без изменения его данных
```python
m1 = np.arange(50)
m1 = m1.reshape((2, 5, 5))
print(m1)
Вывод:
[[[ 0  1  2  3  4]
  [ 5  6  7  8  9]
  [10 11 12 13 14]
  [15 16 17 18 19]
  [20 21 22 23 24]]

 [[25 26 27 28 29]
  [30 31 32 33 34]
  [35 36 37 38 39]
  [40 41 42 43 44]
  [45 46 47 48 49]]]
```
**замечание!**
 * количество элементов первоначального массива должно соответствовать кол-ву элементов после решейпа (2 * 5 * 5 = 50)
 
 ### Транспонирование, унарные и бинарные функции
 В numpy существует функция странспонирования -> m2d.transpose()\
 или аналогичная запись -> m2d.T
Функции округления:
- функция **numpy.round**(*a, decimals=0, out=None*) - возвращает (результат - массив NumPy) массив с округленными значениями входного массива a. Тип результирующего массива совпадает с типом входного массива. Если параметр out не указан, то будет создан новый массив.\
функция round() округляет в меньшую сторону если число четное 2.5 = 2, а если нечетное в большую 7.5 = 8
- функция **numpy.ceil**(*x, *ufunc_args*) = <ufunc 'ceil'> - округляет к большему целому числу. Возвращает число или массив чисел, которые округлены к наибольшему целому числу.
- функция **numpy.floor**(*x, *ufunc_args*) = <ufunc 'floor'>* - выполняет округление к меньшему целому числу.Возвращает число или массив чисел, которые округлены к наименьшему целому числу.
#### Работа с nan
Nan - значение, которое означает неопределяемое число (или "не число"). Но оно ведет себя как число, и в каком бы выражении оно не появилось, результат всегда будет nan (кроме nan/0 т.к. деление на 0 всегда приводит к появлению ошибки)\
функция **numpy.isnan** - проверяет содержится ли nan в массиве\
выражение : np.sum(np.isnan(m)) - подсчитывает количество nan в массиве *m*\
стоит отметить что при вычислениях можно получить значение *inf*(бесконечность) и для провеки на это значение существует функция **isinf()**

Если нужно заполнить нулями пропуски, то в библиотеке numpy есть функция **nan_to_num**:\
![nan_to_num](https://ucarecdn.com/ef5353b1-462e-48ea-bbe1-b095b060b9ca/)\
Или вариант с булевой маской:\
![Маска](https://ucarecdn.com/a82c87e0-30be-44ce-8d3d-41401f750e44/)\

У многих функций работающих с массивами есть необязательны параметр *out* - Массив в который можно поместить результат функции\
out работает только если переменная, в которую он выводит, ранее определена
```python
m1 = np.array([4.6, 6.8, -2.3])
np.abs(m1, out = m1)
#такая запись выдаст ошибку:
np.abs(m1, out = m2)
```
#### бинарные функции:
Бинарные функции содержат два обязательных параметра, например функции
- **np.maximum(arr1,arr2)** - возвращает наибольшие значения поэлементного сравнения значений массивов.
- **np.minimum(arr1,arr2)** - возвращает наименьшее значения поэлементного сравнения значений массивов.
- **np.add((arr1,arr2)** - поэлементное сложение массивов
- **np.subtract(arr1,arr2)** | Поэлементно вычесть arr2 из arr1
- **np.multiply(arr1,arr2)** | Поэлементно умножить arr1 на arr2
- **np.divide(arr1,arr2)** | Поэлементно разделить arr1 на arr2
- **np.power(arr1,arr2)** | Поэлементно поднять arr1 в степени arr2
- **np.array_equal(arr1,arr2)** | Возвращает True, если массивы имеют одинаковые элементы и форму
- **np.sqrt(arr)** | Квадратный корень каждого элемента массива
- **np.sin(arr)** | Синус каждого элемента массива
- **np.log(arr)** | Натуральный логарифм каждого элемента массива
- **np.abs(arr)** | Абсолютное значение каждого элемента в массиве
- **np.exp(arr)** | Экспонента каждого элемента в массиве
- **np.matmul(mat1,mat2)** | Матричное умножение mat1 и mat1


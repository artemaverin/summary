# Оглавление


1. [Создание массива numpy](#создание-массива-numpy)
2. [Информация из массива](#информация-из-массива)
3. [Типы данных и их преобразование](#типы-данных-и-их-преобразование)

### Создание массива Numpy 
На самом деле способов создания массивов очень много, разберем самые основные:
- функция **numpy.array**(*list*/*tuple*)\
массив может быть создан из обычного *списка* или *кортежа* Python
```python
import numpy as np

arr_list = np.array([1, 2, 3, 4])
arr_tuple = np.array((1, 2, 3, 4))
Вывод:
[1 2 3 4]
[1 2 3 4]
```
**данная конструкция работает как с одномерными так и сдвумерными массивами*

- функция **numpy.zeros**(*shape, dtype=float, order='C'*)\
возвращает новый массив указанной формы и типа, заполненный нулями. в качестве параметра принимает целое число, список или кортеж целых чисел
```python
print(np.zeros(5))
 Вывод:
 [0. 0. 0. 0. 0.]
 ------------------------
 print(np.zeros((2, 3)))
 Вывод:
 [[0. 0. 0.]
 [0. 0. 0.]]
```
- функция **numpy.ones**(*shape, dtype=float, order='C'*) - аналогична функции zeros,но заполняет массив единицами
- функция **numpy.full**(*shape, fill_value, dtype=None, order='C'*) - возвращает новый массив указанной формы и типа, заполненный указанным значением fill_value
```python
print(np.full((2, 3), 666))
 Вывод:
 [[666 666 666]
 [666 666 666]]
```
- функция **numpy.arange**(*[start, ]stop, [step, ]dtype=None*) - возвращает одномерный массив с равномерно разнесенными значениями внутри заданного интервала
```python
print(np.arange(5))
 Вывод:
 [0 1 2 3 4]
```

###  Информация из массива
Из массива можно получать различную информацию:
- встроенная функция **len()** - функция возвращает размер первого измерения
```python
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
 print(len(arr_list))
 Вывод:
 2
 print(len(arr_list[0]))
 Вывод:
 4
```
свойство массива - **shape**\
это - кортеж натуральных чисел, показывающий длину массива по каждой оси. 
```python
print(arr_list.shape)
 Вывод:
 (2, 4)
```
<ul>
 
 <li>атрибут <b>ndim</b> - число измерений (чаще их называют "оси") массива.</li> 
  <p><br>Если ndim =1 значит у вас 1D array (см. выше). Он же одномерный массив.
  <br>Если ndim =2 значит у вас 2D array (см. выше). Он же двумерный массив. Она же матрица.
  <br>Если ndim =3 значит у вас 3D array (см. выше). </br></p>
<pre>
 print(arr_list.ndim)
 Вывод:
 2
 </pre>
 
 <li>атрибут <b>dtype</b> описыввает тип элементов массива</li>
 <pre>
 print(arr_list.dtype)
 Вывод:
 int32
 </pre>
</ul>

### Типы данных и их преобразование
массиву можно задать нужный тип данных например с помощью параметра <i>dtype</i>
<pre>
print(np.array([1, 2, 3], dtype='float64'))
Вывод:
[1. 2. 3.]
</pre>
функция <b>NDArray.astype</b> возвращает копию массива преобразованного к указанному типу:
<pre>
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
arr2 = arr_list.astype(np.float64)
print(arr2)
Вывод:
[[1. 2. 3. 4.]
 [5. 6. 7. 8.]]
</pre>
Рассмотрим случай преобразования данных float в int:
<pre>
arr1 = np.array([1.2, 3.4, 4.5, 3.1, 5.5], dtype=np.float64)
arr2 = arr1.astype(np.int32)
print(arr2)
Вывод:
[1 3 4 3 5]
</pre>
<br>Если поменять тип данных с float_ на int_, то numpy отрежет десятичную часть от каждого числа и оставит только целую.</br>
Рассмотрим случай общего массива чисел и строк:
<pre>
arr1 = np.array([1.2, 3.4, '', 3.1, 5.5], dtype=np.float64)
Вывод:
ValueError: could not convert string to float: ''
</pre>
с массивами numpy можно выполнять различные арифметические операции, результаты которых будут отличаться от обычных операций python
<br>1. Умножение</br>
<pre>
Python
m1 = [1, 2, 3, 4]
print(m1 * 2)
Вывод:
[1, 2, 3, 4, 1, 2, 3, 4]
-------------------------
Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 * 2)
Вывод:
[2 4 6 8]
</pre>
В случае обычного листа с помощью умножения дублируем его дважды. В случае numpy перемножаем все элементы массива
<br>2. Сложение</br>
<pre>
Python
m1 = [1, 2, 3, 4]
print(m1 + 2)
Вывод:
TypeError: can only concatenate list (not "int") to list
-------------------------
Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 + 2)
Вывод:
[3 4 5 6]
</pre>
Аналогичная ситуация с операциями вычитания и деления, возведения в степень(**).Также все это работает и с массивами большей размерности
<br>Массив можно также сравнивать между собой</br>
<pre>
m1 = np.array([32, 13, 5])
m2 = np.array([54, 23, 2])
m3 = m1 > m2
print(m3)
Вывод:
[False False  True]
</pre>
В результатье получаем булевский массив(*<i>сравнивать массивы numpy можно только одинаковой длины</i>)
<br>В созданных массивах можно менять значения обращаясб по индексу или массово через срез
<br>рассмотрим на примере одномерного массива:</br>
<pre>
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m1[4] = 444
print(m1)
Вывод:
[ 32  13   5   4 444   8  22]
------------------------------
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m1[3:6] = 0
print(m1)
Вывод:
[32 13  5  0  0  0 22]
</pre>
<br><b>важный факт!!</b></br>
Если мы делаем слайс, например, m1[3:5], а затем присваиваем этот кусочек в новую переменную, то в новой переменной будет лежать ваш кусочек, который всё еще ссылается на основной массив.
<pre>
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m2 = m1[3:6]
m2[0] = 666
print(m1)
Вывод:
[ 32  13   5 666  67   8  22]
</pre>

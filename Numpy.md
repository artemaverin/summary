# Оглавление


1. [Создание массива numpy](#создание-массива-numpy)
2. [Информация из массива](#информация-из-массива)
3. [Типы данных и их преобразование](#типы-данных-и-их-преобразование)

### Создание массива Numpy 
На самом деле способов создания массивов очень много, разберем самые основные:
- функция **numpy.array**(*list*/*tuple*)\
массив может быть создан из обычного *списка* или *кортежа* Python
```python
import numpy as np

arr_list = np.array([1, 2, 3, 4])
arr_tuple = np.array((1, 2, 3, 4))
Вывод:
[1 2 3 4]
[1 2 3 4]
```
**данная конструкция работает как с одномерными так и сдвумерными массивами*

- функция **numpy.zeros**(*shape, dtype=float, order='C'*)\
возвращает новый массив указанной формы и типа, заполненный нулями. в качестве параметра принимает целое число, список или кортеж целых чисел
```python
print(np.zeros(5))
 Вывод:
 [0. 0. 0. 0. 0.]
 ------------------------
 print(np.zeros((2, 3)))
 Вывод:
 [[0. 0. 0.]
 [0. 0. 0.]]
```
- функция **numpy.ones**(*shape, dtype=float, order='C'*) - аналогична функции zeros,но заполняет массив единицами
- функция **numpy.full**(*shape, fill_value, dtype=None, order='C'*) - возвращает новый массив указанной формы и типа, заполненный указанным значением fill_value
```python
print(np.full((2, 3), 666))
 Вывод:
 [[666 666 666]
 [666 666 666]]
```
- функция **numpy.arange**(*[start, ]stop, [step, ]dtype=None*) - возвращает одномерный массив с равномерно разнесенными значениями внутри заданного интервала
```python
print(np.arange(5))
 Вывод:
 [0 1 2 3 4]
```

###  Информация из массива
Из массива можно получать различную информацию:
- встроенная функция **len()** - функция возвращает размер первого измерения
```python
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
 print(len(arr_list))
 Вывод:
 2
 print(len(arr_list[0]))
 Вывод:
 4
```
свойство массива - **shape**\
это - кортеж натуральных чисел, показывающий длину массива по каждой оси. 
```python
print(arr_list.shape)
 Вывод:
 (2, 4)
```

атрибут **ndim** - число измерений (чаще их называют "оси") массива.
+ Если ndim =1 значит у вас 1D array (см. выше). Он же одномерный массив.
+ Если ndim =2 значит у вас 2D array (см. выше). Он же двумерный массив. Она же матрица.
+ Если ndim =3 значит у вас 3D array (см. выше).
```python
 print(arr_list.ndim)
 Вывод:
 2
```

атрибут **dtype** описыввает тип элементов массива
```python
print(arr_list.dtype)
 Вывод:
 int32
```

### Типы данных и их преобразование
массиву можно задать нужный тип данных например с помощью параметра *dtype*
```python
print(np.array([1, 2, 3], dtype='float64'))
Вывод:
[1. 2. 3.]
```
функция **NDArray.astype** возвращает копию массива преобразованного к указанному типу:
```python
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
arr2 = arr_list.astype(np.float64)
print(arr2)
Вывод:
[[1. 2. 3. 4.]
 [5. 6. 7. 8.]]
```
Рассмотрим случай преобразования данных float в int:
```python
arr1 = np.array([1.2, 3.4, 4.5, 3.1, 5.5], dtype=np.float64)
arr2 = arr1.astype(np.int32)
print(arr2)
Вывод:
[1 3 4 3 5]
```
Если поменять тип данных с float_ на int_, то numpy отрежет десятичную часть от каждого числа и оставит только целую.
Рассмотрим случай общего массива чисел и строк:
```python
arr1 = np.array([1.2, 3.4, '', 3.1, 5.5], dtype=np.float64)
Вывод:
ValueError: could not convert string to float: ''
```
с массивами numpy можно выполнять различные арифметические операции, результаты которых будут отличаться от обычных операций python
1. Умножение

```python
#Python
m1 = [1, 2, 3, 4]
print(m1 * 2)
Вывод:
[1, 2, 3, 4, 1, 2, 3, 4]
-------------------------
#Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 * 2)
Вывод:
[2 4 6 8]
```
В случае обычного листа с помощью умножения дублируем его дважды. В случае numpy перемножаем все элементы массива\
2. Сложение
```python
#Python
m1 = [1, 2, 3, 4]
print(m1 + 2)
Вывод:
TypeError: can only concatenate list (not "int") to list
-------------------------
#Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 + 2)
Вывод:
[3 4 5 6]
```
Аналогичная ситуация с операциями вычитания и деления, возведения в степень( ** ).\
Также все это работает и с массивами большей размерности\
Массивы можно также сравнивать между собой
```python
m1 = np.array([32, 13, 5])
m2 = np.array([54, 23, 2])
m3 = m1 > m2
print(m3)
Вывод:
[False False  True]
```
В результатье получаем булевский массив(* *сравнивать массивы numpy можно только одинаковой длины*)\
В созданных массивах можно менять значения обращаясб по индексу или массово через срез\
рассмотрим на примере одномерного массива:
```python
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m1[4] = 444
print(m1)
Вывод:
[ 32  13   5   4 444   8  22]
------------------------------
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m1[3:6] = 0
print(m1)
Вывод:
[32 13  5  0  0  0 22]
```
**важный факт!!**\
Если мы делаем слайс, например, m1[3:5], а затем присваиваем этот кусочек в новую переменную, то в новой переменной будет лежать ваш кусочек, который всё еще ссылается на основной массив.
```python
m1 = np.array([32, 13, 5, 4, 67, 8, 22])
m2 = m1[3:6]
m2[0] = 666
print(m1)
Вывод:
[ 32  13   5 666  67   8  22]
```


<h2><b1>Оглавление</b1> </h2>
<a href="#name_link1">1. Создание массива Numpy</a>
<br><a href="#name_link2">2. Информация из массива</a></br>
<a href="#name_link3">3. Типы данных и их преобразование</a>
 
<h3><a name="name_link1">1. Создание массива Numpy</a></h3>
<p><h7>На самом деле способов создания массивов очень много, разберем самые основные:</h7></p>
<ul>
  <li>функция <b>numpy.array</b>(<i>list</i>/<i>tuple</i>)</li>
 <p>массив может быть создан из обычного <em>списка</em> или <em>кортежа</em> Python</p>
 <pre>
import numpy as np

arr_list = np.array([1, 2, 3, 4])
arr_tuple = np.array((1, 2, 3, 4))
Вывод:
[1 2 3 4]
[1 2 3 4]</pre>
*данная конструкция работает как с одномерными так и сдвумерными массивами
  <li>функция <b>numpy.zeros</b>(<i>shape, dtype=float, order='C'</i>)</li>
  <p>возвращает новый массив указанной формы и типа, заполненный нулями. в качестве параметра принимает целое число, список или кортеж целых чисел</p>
  <pre>
 print(np.zeros(5))
 Вывод:
 [0. 0. 0. 0. 0.]
 ------------------------
 print(np.zeros((2, 3)))
 Вывод:
 [[0. 0. 0.]
 [0. 0. 0.]]
 </pre>
  <li>функция <b>numpy.ones</b>(<i>shape, dtype=float, order='C'</i>) - аналогична функции zeros,но заполняет массив единицами</li>
  <li>функция <b>numpy.full</b>(<i>shape, fill_value, dtype=None, order='C'</i>) - возвращает новый массив указанной формы и типа, заполненный указанным значением fill_value</li>
 <pre>
 print(np.full((2, 3), 666))
 Вывод:
 [[666 666 666]
 [666 666 666]]
 </pre>
  <li>функция <b>numpy.arange</b>(<i>[start, ]stop, [step, ]dtype=None</i>) - возвращает одномерный массив с равномерно разнесенными значениями внутри заданного интервала</li>
 <pre>
 print(np.arange(5))
 Вывод:
 [0 1 2 3 4]
 </pre>
</ul>


<h3><a name="name_link2">2. Информация из массива</a></h3>
Из массива можно получать различную информацию:
<ul>
 <li>встроенная функция <b>len()</b> - функция возвращает размер первого измерения</li>
  <pre>
 arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
 print(len(arr_list))
 Вывод:
 2
 print(len(arr_list[0]))
 Вывод:
 4
 </pre>
 
 <li>свойство массива - <b>shape</b></li>
 это - кортеж натуральных чисел, показывающий длину массива по каждой оси. 
 <pre>
 print(arr_list.shape)
 Вывод:
 (2, 4)
 </pre>
 
 <li>атрибут <b>ndim</b> - число измерений (чаще их называют "оси") массива.</li> 
  <p><br>Если ndim =1 значит у вас 1D array (см. выше). Он же одномерный массив.
  <br>Если ndim =2 значит у вас 2D array (см. выше). Он же двумерный массив. Она же матрица.
  <br>Если ndim =3 значит у вас 3D array (см. выше). </br></p>
<pre>
 print(arr_list.ndim)
 Вывод:
 2
 </pre>
 
 <li>атрибут <b>dtype</b> описыввает тип элементов массива</li>
 <pre>
 print(arr_list.dtype)
 Вывод:
 int32
 </pre>
</ul>

<h3><a name="name_link3">3. Типы данных и их преобразование</a></h3>
массиву можно задать нужный тип данных например с помощью параметра <i>dtype</i>
<pre>
print(np.array([1, 2, 3], dtype='float64'))
Вывод:
[1. 2. 3.]
</pre>
функция <b>NDArray.astype</b> возвращает копию массива преобразованного к указанному типу:
<pre>
arr_list = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
arr2 = arr_list.astype(np.float64)
print(arr2)
Вывод:
[[1. 2. 3. 4.]
 [5. 6. 7. 8.]]
</pre>
Рассмотрим случай преобразования данных float в int:
<pre>
arr1 = np.array([1.2, 3.4, 4.5, 3.1, 5.5], dtype=np.float64)
arr2 = arr1.astype(np.int32)
print(arr2)
Вывод:
[1 3 4 3 5]
</pre>
<br>Если поменять тип данных с float_ на int_, то numpy отрежет десятичную часть от каждого числа и оставит только целую.</br>
Рассмотрим случай общего массива чисел и строк:
<pre>
arr1 = np.array([1.2, 3.4, '', 3.1, 5.5], dtype=np.float64)
Вывод:
ValueError: could not convert string to float: ''
</pre>
с массивами numpy можно выполнять различные арифметические операции, результаты которых будут отличаться от обычных операций python
<br>1. Умножение</br>
<pre>
Python
m1 = [1, 2, 3, 4]
print(m1 * 2)
Вывод:
[1, 2, 3, 4, 1, 2, 3, 4]
-------------------------
Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 * 2)
Вывод:
[2 4 6 8]
</pre>
В случае обычного листа с помощью умножения дублируем его дважды. В случае numpy перемножаем все элементы массива
<br>2. Сложение</br>
<pre>
Python
m1 = [1, 2, 3, 4]
print(m1 + 2)
Вывод:
TypeError: can only concatenate list (not "int") to list
-------------------------
Numpy
m2 = np.array([1, 2, 3, 4])
print(m2 + 2)
Вывод:
[3 4 5 6]
</pre>
Аналогичная ситуация с операциями вычитания и деления, возведения в степень(**).Также все это работает и с массивами большей размерности
<br>Массив можно также сравнивать между собой</br>
<pre>
m1 = np.array([32, 13, 5])
m2 = np.array([54, 23, 2])
m3 = m1 > m2
print(m3)
Вывод:
[False False  True]
</pre>
В результатье получаем булевский массив(*<i>сравнивать массивы numpy можно только одинаковой длины</i>)

## Garbage Collection

[1. Чем Java отличается от C++?](#1-Чем-Java-отличается-от-C)

[2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-Что-такое-ссылки)

[9. Какие типы ссылок вы знаете?](#9-Какие-типы-ссылок-вы-знаете)

[10. Чем они отличаются?](#10-Чем-они-отличаются)

[11. Расскажите про String pool и Integer pool (Integer cache)](#11-Расскажите-про-String-pool-и-Integer-pool-Integer-cache)

[12. Расскажите о методе String.intern()](#12-Расскажите-о-методе-String-intern)

[13. Расскажите, что такое профайлер](#13-Расскажите-что-такое-профайлер)

[14. Расскажите, как использовать VisualVM](#14-Расскажите-как-использовать-VisualVM)

[15. Расскажите, чем отличается sampling от profiling?](#15-Расскажите-чем-отличается-sampling-от-profiling)

## 1. Чем Java отличается от C++?

автоматическая сборка мусора отличает Java от языков более низкого уровня, в частности С/С++.

В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов new и delete).

В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. (освобождает память в куче, занятой неиспользуемыми объектами)

Т.е. в отличие от С++ нет явной необходимости уничтожать объект.

[к оглавлению](#Garbage-Collection)

## 2. Что такое менеджер памяти?

Менеджер памяти — часть компьютерной программы (как прикладной, так и операционной системы), обрабатывающая запросы на выделение и освобождение оперативной памяти или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

В Java, “Менеджер памяти” - это часть среды исполнения Java (JVM), которая отвечает за управление памятью, выделяя ее для объектов, которые создает и использует ваша Java-программа.

Когда вы создаете новый объект в Java, менеджер памяти выделяет память для его хранения. Когда объект больше не используется, менеджер памяти освобождает эту память обратно, чтобы она могла быть использована для других целей.

Важно понимать, что менеджер памяти управляет только памятью для объектов. Он не имеет ничего общего с оперативной памятью или памятью компьютера, на котором выполняется программа. Вместо этого, менеджер памяти работает внутри виртуальной машины Java (JVM) и управляет памятью в рамках этой виртуальной машины.

[к оглавлению](#Garbage-Collection)

## 3. Какой механизм используется в Java для управления памятью?

**v1**

В Java используется несколько механизмов для управления памятью. `Один из них - это сборка мусора (Garbage Collection)`. Сборка мусора - это процесс, во время которого менеджер памяти ищет все объекты, которые больше не используются программой, и удаляет их из памяти.

Кроме того, Java также использует технику под названием “аллокатор памяти” для управления памятью на более низком уровне. Алокатор памяти отвечает за выделение и освобождение памяти для объектов на протяжении всего времени выполнения программы.

`GC смотрит на достижимость объекта по ссылке. Это значит, что если мы не можем получить к нему доступ из программы, т.е. у нас нет ссылки на него, то он помечается как мусор и будет удален при следующей сборке мусора.`

**v2**

Распределение памяти в java реализует технология Java HotSpot от Oracle. 
Она обеспечивает динамическое выделение памяти для объектов и сборщиков мусора.

Память процесса делится на non-heap (до JDK 8 stack) и heap (куча):

В предыдущих выпусках Java Hotspot VM метаданные класса выделялись в Permanent Generation.
Начиная с JDK 8, permanent generation было удалено, а метаданные класса размещены в собственной памяти. 
Объем собственной памяти, которую можно использовать для метаданных класса, по умолчанию не ограничен. 

+ Stack (структура non-heap до JDK 8)
    + Permanent Generation — содержит необходимые для управления программой метаданные классов, 
    в том числе метаданные о созданных объектах, методах и т.п.
    + Code Cache — используемая JVM память при включенной JIT-компиляции 
    (в этой области памяти кешируется скомпилированный платформенно-зависимый код)     
 
+ Heap - куча (тут и работает GC)
    + New (Yang) Generation - хранит короткоживущие объекты.
        + Eden Space — сюда аллоцируются среднестатистические объекты*. Если нет места запускается малая сборка мусора (minor GC). 
        + Survivor Space — точнее их два, S1 и S2, и они меняются ролями. 
        Хранятся перемещенные из Eden Space объекты, признанные живыми во время сборки мусора (без разницы малой или полной). 
        Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
    + Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется, 
    выполняется полная сборка мусора (full GC).

Алгоритм GC исходит из того предположения, что большинство java-объектов живут недолго. 
Быстро становятся мусором. От них необходимо довольно оперативно избавляться. Что и происходит в New Generation. 
Там сбор мусора гораздо чаще, чем в Old Generation, где хранятся долгоживущие объекты. 
После создания объект попадает в New Generation и имеет шанс попасть в Old Generation по прошествии нескольких циклов GC.

*объекты-акселераты, размер которых настолько велик, что создавать их в Eden, 
а потом таскать за собой по Survivor’ам слишком накладно, размещаются сразу в Tenured Generation.

[к оглавлению](#Garbage-Collection)

## 4. Опишите процесс работы сборщика мусора

Прежде чем удалить объект, нужно знать, где он находится. Давайте рассмотрим структуру памяти в Java. Все объекты хранятся в куче (heap). Куча делится на поколения (generation). Есть всего два поколения: молодое (young) и старое (old). Young generation состоит из eden и survivor space.

![image](https://github.com/artemaverin/summary/assets/97846877/2e67f82c-1f51-43dc-9cf3-2cf2569ef139)

# Сборка мусора

Сборка мусора происходит, когда заполнена вся область памяти. Память делится на два поколения, поэтому есть два типа сборки мусора: _minor GC_ и _major GC_. Первый происходит, когда переполняется young generation, второй, когда переполняется область из old generation.

Теперь поговорим какие стадии проходят объекты до сборки мусора.

1. Объект рождается. Во время исполнения JVM видит, что стоит оператор new. Происходит выделение памяти под объект и возврат ссылки, которая будет ссылаться на занятый участок памяти. Все объекты рождаются в eden

![image](https://github.com/artemaverin/summary/assets/97846877/a2cdacdf-071a-4fc0-837e-14323d34eb34)

2. Этап 1 выполняет до тех пор, пока не будет заполнен eden

![image](https://github.com/artemaverin/summary/assets/97846877/75718acc-1717-46fc-8d0d-b2da743c8e6a)

Когда eden заполнен происходит minor GC:

3. Объекты, у которых уже нет ссылки удаляются

![image](https://github.com/artemaverin/summary/assets/97846877/b38f1d9b-81d0-4124-a379-a7d3f4f4cd3d)

4. Объекты, у которых есть ссылки попадают в survivor space из eden. Причем survivor space делиться на две части. Между этими частями происходит перемещения объектов. В один момент времени одна из частей пуста, чтоб мочь вместить объекты пришедшие из eden.

![image](https://github.com/artemaverin/summary/assets/97846877/6fae5c49-d684-4279-a060-5945ed94a4de)

5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age). Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется «взрослением» (aging).

![image](https://github.com/artemaverin/summary/assets/97846877/fc80edb6-89a3-4755-aa06-9f68828592da)

6. Объекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением» promotion.

![image](https://github.com/artemaverin/summary/assets/97846877/21013d1a-0778-47b3-a9ca-a3a6a1fe1aab)

Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для очищения young generation.

7. Когда old generation заполняется производиться major GC

8. Этапы 1-7 происходят на протяжении работы программы

[к оглавлению](#Garbage-Collection)

## 5. Какие алгоритмы сборщика вы знаете?

https://job4j.ru/profile/exercise/59/task-view/371

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

- Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .

- Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.

- Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

![image](https://github.com/artemaverin/summary/assets/97846877/5d492fb8-9075-4468-a597-8587bb96425c)

**Характеристики сборщиков мусора**

Сборщики мусора различаются относительно характеристик какими они обладают. Рассмотрим эти характеристики.

**Виды сборок мусора.**

После того как сборщик мусора определил, что нужно удалить объекты, он может пользоваться следующими сборками: Compacting, Non-compacting and Copying.

- _Compacting (Compact с англ. уплотнить):_

Собирает "живые" объекты в одном месте и очищает оставшуюся часть памяти, где находятся объекты, которые нужно уничтожить.

Преимущество такого подхода - легко можно выделять память для новых объектов.

Недостаток - требуется время на компоновку объектов в одном месте.

- _Non-compacting._

Удаляет объекты по месту. Т.е. он понимает, что данную часть памяти занимает объект, который нужно удалить, и чистит эту часть памяти.

Преимущество: не нужно производить лишние действия, нужно просто удалить объекты.

Недостаток: при создании объекта нужно находить для него подходящее место, что приводит к фрагментации памяти (это когда большая часть вашей памяти выделена в большом количестве несмежных блоков, оставляя приличный процент вашей общей памяти нераспределенной, но при этом непригодной для большинства типичных сценариев использования памяти), то есть много свободных мест памяти между занятыми ячейками, но из-за малых ее размеров, ее практически ничем не занять, и эта память простаивает.

- _Copying._

Копирует "живые" объекты в отдельную часть памяти, очистив старую часть, где они были (С этим типом вы встречались в прошлом задании).

Преимущество: нет препятствий выделению памяти.

Недостаток: требуется время на копирование.

**v2**

Имеется два подхода к очистке памяти, которые в совокупности определяют принцип функционирования Garbage Collection.

1. *Copying collectors* - в чистом виде в HotSpot VM не используется.

    Область памяти делится на две части: в одной части размещаются объекты, а вторая часть остается чистой. 
    На время очистки мусора приложение останавливает работу и запускается `GC`, который находит в первой области 
    объекты со ссылками и переносит их во вторую (чистую) область. После этого, первая область очищается от оставшихся 
    там объектов без ссылок, и области меняются местами.

    Достоинство данного подхода - плотное заполнение памяти. 
    
    Недостаток - необходимость остановки приложения и размеры двух частей памяти должны быть одинаковыми на случай, 
    когда все объекты остаются «живыми».

2. *Mark-and-sweep* - также в чистом виде в HotSpot VM не используется.

    Все объекты размещаются в одном сегменте памяти. Сборка мусора также приостанавливает приложение, и GC проходит 
    по дереву объектов, помечая занятые ими области памяти, как «живые». После этого, все не помеченные участки памяти 
    сохраняются в «free list», в которой будут, после завершения сборки мусора, размещаться новые объекты.
    
    Недостатки - необходимость приостановки приложения. 
    Кроме этого, время сборки мусора, как и время приостановки приложения, зависит от размера памяти. 
    Память становится «решетчатой», и, если не применить «уплотнение», то память будет использоваться неэффективно.

[к оглавлению](#Garbage-Collection)

## 6. Чем отличаются сборщики мусора?

**v1**

1. Serial GC.

Это самый простой вид сборщика. Он является Serial, Stop The World, Copying, т.е. выполняет сборку мусора в одном потоке, вызывается событие Stop The World и используется Copying сборку мусора. Подходит для простых клиентских приложений, к примеру проигрывателя музыки.

Плюс: минимальные требования к среде. Минус: медленный.

2. Parallel GC

Это усовершенствованная версия сборщика GC. Он является Parallel, Stop The World, Copying, т.е. его единственное отличие в том, что он выполняет сборку мусора в нескольких потоках. Подходит для более сложных клиентских приложений, где нет серьезных требований к скорости сборки, но ее наличие было бы неплохим преимуществом. К примеру, несложное приложение для работы с графикой.

Плюс: пошустрее, чем Serial GC. Минус: недостаточно быстрый, по сравнению с CMS, требует наличие нескольких ядер.

3. CMS (Concurrent Mark Sweep)

Это улучшенная версия Parallel GC. Он является Parallel, Concurrent, Copying. Лучше прошлого он тем, что используется параллелизм, т.е. часть heap чиститься наряду с работой приложения. Подходит для клиентских приложений, где длительные паузы не допустимы, например, настольное приложения для торговли на бирже.

Убран с JDK 14.

Плюс: небольшие паузу на сборку мусора. Минус: более высокие системные требования.

4. G1

Мощный сборщик сборщик мусора, усовершенствованная версия CMS. Он является Parallel, Concurrent, Copying. Его особенностью является высокая пропускная способность. Следовательно сборка мусора выполняется редко. Данный сборщик мусора используется для серверных приложений требующих быстрого отклика и не терпящих долгих пауз на сборку мусора.

Плюс: скорость. Минус: нужен большой heap (> 4gb)

5. ZGC

Данный сборщик появился недавно. Он является Parallel, Concurrent, Copying. Причем он использует параллелизм на полную мощь. Тем самым для очистки вовсе не требует остановки приложения, в отличие от G1, где паузы хоть и маленькие но присутствуют. Используется для приложений где допустимы лишь паузы < 10ms

Плюс: нет паузы. Минус: требует сверх большой heap в несколько терабайтов для эффективной работы

Доступен только с JDK 11.

- ---------------

**v2**

![image](https://github.com/artemaverin/summary/assets/97846877/f89b6bde-6855-4fe0-823b-7f7016b59299)

- -------------

**v3**

**Serial (последовательный)** — самый простой вариант для приложений, 
которым не требуется большой размер кучи для работы (Oracle указывает условную границу 100 МБ), 
которые не очень чувствительны к коротким остановкам и им для работы доступно только одно ядро процессора.
Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

**+** Непритязательность по части ресурсов компьютера. Т.к. всю работу он выполняет последовательно в одном потоке, никаких заметных оверхедов и негативных побочных эффектов у него нет.

**-** Долгие паузы на сборку мусора при заметных объемах данных. 

**-** Все настройки Serial GC крутятся вокруг размеров различных регионов кучи, т.е. для тонкой настройки 
требуется вручную что-то изучать, настраивать, экспериментировать и т.д. 

**Parallel (параллельный)** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в 
некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для большинства приложений. 
У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

**+** в сравнении с Serial GC есть возможность автоматической подстройки под требуемые параметры производительности 
и меньшие паузы на время сборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.

**-** Определенная фрагментация памяти, но вряд ли она будет существенной для большинства приложений, 
т.к. сборщиком используется относительно небольшое количество потоков.

**Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора 
параллельно с основными потоками приложения. Более требователен к ресурсам процессора.
Подходит для работы в приложениях с относительно большими объемами долгоживущих данных,
для приложений, имеющих доступ к нескольким ядрам процессора и чувствительных к паузам STW.

**+** по сравнению с рассмотренными ранее Serial/Parallel GC ориентирован на минимизацию времени простоя, 
что является критическим фактором для многих приложений. 
Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.

**-** не уплотняет объекты в старшем поколении, что приводит к фрагментации области Tenured. 
Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению 
(конкретно — старшему поколению) больше памяти, чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).

**-** долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. 
Хотя они не частые, и при наличии достаточного объема памяти сборщику CMS удается их полностью избегать.

**Garbage-First (G1)** — создан для замены CMS, но не является явным продолжением линейки Serial/Parallel/CMS. 
Мспользуется в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных 
(размер кучи от 4 ГБ и выше), для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет 
уменьшения пропускной способности.

**+** G1 более точно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, 
чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. 

**+** В отличие от CMS, например, он не фрагментирует память.

**-** Тратит ресурсы процессора, которые использует для выполнения достаточно большой части своей работы параллельно с основной программой. 
В результате страдает пропускная способность приложения. 
Целевое значением пропускной способности по умолчанию для G1 равно 90%, для Parallel GC составляет 99%. 
Это не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует учитывать.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_6.1.png)
 
«Монолитный» означает то, что всё поколение должно быть очищено за проход.

«В большинстве случаев одновременный» — mostly concurrent, одновременный имеется в виду фоновый, «работающий вместе с потоками приложения».

**Z Garbage Collector (ZGC)** - это масштабируемый сборщик мусора с малой задержкой. 
ZGC выполняет всю дорогостоящую работу одновременно, не останавливая выполнение потоков приложения.

ZGC предназначен для приложений, которые требуют малой задержки (паузы менее 10 мс) и/или используют очень большую кучу 
(мульти-терабайты). Включается с помощью опции `-XX:+UseZGC`.

ZGC доступен в качестве экспериментальной функции, начиная с JDK 11.

Подробнее здесь https://habr.com/ru/post/269621/

[к оглавлению](#Garbage-Collection)

## 7. Расскажите про утилиты для анализа памяти?

встроенные в JDK утилиты: jps, jmap, jstat, jconsole, visualvm до java 9.

внешние: VisualVM c java 9 и утилита от NetBeans - YourKit Java Profiler.

jconsole, visualvm и yourkit profiler предоставляют удобный визуальный интерфейс.

**jps** - выводит pid-ы процессов, которые использует VM

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.1.png)

 
**jmap** - выводит информацию о состоянии памяти виртуальной машины
	
`jmap -heap 14152` или `jhsdb jmap --heap --pid 14152`
	
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.2.png)
 
**jstat** - аналогично jmap

**jstack** - показывает какие процессы запущены в  виртуальной машине (нет инфы о памяти)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.3.png)
 
...

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.4.png) 

**jconsole**
 
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.5.png) 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.6.png)

**VisualVM** (с плагином VisualGC)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.7.png) 

**YourKit Profiler** - универсальный расширенный профилировщик, используется не только для анализа памяти, 
но и ,например, для поиска узких мест в коде (повторения и тп)

[к оглавлению](#Garbage-Collection)

## 8. Что такое ссылки?

Перед сборкой мусора сборщик мусора маркирует объекты. В зависимости от этого он решает какие нужно удалить, а какие нет. На принятие решения об удалении влияет тип ссылки объекта.

Ссылки в Java — это механизм, позволяющий работать с объектами в памяти компьютера. Ссылки используются для обращения к объектам и вызова их методов. В Java все объекты создаются в динамической памяти, и для работы с ними используются ссылки.

Ссылки в Java работают следующим образом: при создании объекта в памяти выделяется блок памяти определенного размера, который содержит данные объекта. Затем создается ссылка на этот блок памяти. Ссылка может указывать на объект определенного типа или интерфейса.
- -----------------------

Ссылки в Java — это указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, 
в которой хранится объект. Кроме того, ссылка может быть инициализирована как `null` — нулевая ссылка, не указывающая 
ни на какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом 
контексте также может быть использована ссылка `this`, указывающая на текущий объект, и ссылка `super`, 
указывающая на текущий объект суперкласса.

Абстрактный класс `java.lang.ref.Reference` предоставляет базу для ссылочных классов. В нём определены следующие методы:

+ `get` — метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
+ `clear` — очищает ссылку.
+ `isEnqueued` и `enqueue`, отвечающие за взаимодействие ссылки и объекта `ReferenceQueue`.

[к оглавлению](#Garbage-Collection)

## 9. Какие типы ссылок вы знаете?

https://job4j.ru/profile/exercise/61/task-view/375

https://habr.com/ru/articles/169883/

https://www.youtube.com/watch?v=5HC8qVHQPi8

В Java существует четыре типа ссылок, различающихся по способу сбора мусора и 
предоставляющие пользователю возможность более гибко работать с памятью:
                                                                            
+ **Сильные ссылки (Strong References)** - стандартные ссылки, создаются каждый раз, когда аллоцируем место в памяти через 
оператор new. Если на объект есть хоть одна жесткая ссылка, то данный объект не будет утилизирован при сборке мусора, что может привести к утечке памяти, что в свою очередь может привести к ошибке OutOfMemoryException - ситуации когда программе не хватает выделенной памяти.

```java
Counter counter = new Counter(); // strong reference
```

+ **Мягкие ссылки (Soft References)** - создаются с помощью вызова `new SoftReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new SoftReference(T obj)`. Если на объект есть только мягкая ссылка, то будет выполнена попытка утилизации данного 
объекта при сборке мусора в случае, если приложению не хватает памяти.т.е. они могут пережить более одной сборки мусора.

Данный тип ссылок подходит для реализации кэша - такой структуры данных, при которой часть данных запоминается, а потом часто переиспользуется.

Например, можно запоминать данные из файлов или тяжелых запросов.

При нехватке памяти JVM может удалить объекты по этим ссылкам, если на них нет сильных ссылок.

Есть контракт для данного типа ссылок: GC гарантировано удалит из кучи все объекты, доступные только по soft-ссылке, перед тем, как бросит OutOfMemoryError

```java
Counter prime = new Counter();  // prime holds a strong reference - line 2
SoftReference<Counter> soft = new SoftReference<Counter>(prime) ; //soft reference variable has SoftReference to Counter Object created at line 2

prime = null;  // now Counter object is eligible for garbage collection but only be collected when JVM absolutely needs memory
```

Корректным использованием безопасных ссылок является сначала получение сильной ссылки на данные, а потом работа с сильной ссылкой.

Это гарантирует, что в интервалах получения сильной ссылки из безопасной GC не затрет объект. Это касается не только локальных переменных, но и возвращаемых значений и аргументов.

+ **Слабые ссылки (WeakReferences)** - создаются с помощью вызова `new WeakReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new WeakReference<T>(T obj)`.Объекты, на которые ссылаются слабые ссылки, удаляются сразу, если на них нет сильных или безопасных ссылок.

```java
Counter counter = new Counter(); // strong reference - line 1
WeakReference<Counter> weakCounter = new WeakReference<Counter>(counter); //weak reference
counter = null; // now Counter object is eligible for garbage collection
```

Данный тип ссылок служит для реализации структур, для которых у одного значения типа может быть только один объект, например пул строк, и объекты чаще всего используется всего один раз, т.е. сохранили-получили-забыли.

+**ReferenceQueue** - Все типы ссылок, за исключением сильных, в Java являются наследниками класса Reference. Все его наследники всегда попадают в ReferenceQueue, это может происходить явно (мы можем задать свою очередь) или неявно (когда мы не задаем). В нее попадают ссылки тех объектов, которые уже помечены на удаление.

+ **Фантомные ссылки (PhantomReferences)** - создаются с помощью вызова `new PhantomReference<T>(T obj, ReferenceQueue<T> queue)`.
Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок. 
Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора. 
Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка или данная 
фантомная ссылка не очищена с помощью вызова метода `clear()`. Так же стоит заметить, что метод `get()` фантомной ссылки 
всегда возвращает `null`.

```java
DigitalCounter digit = new DigitalCounter(); // digit reference variable has strong reference - line 3
PhantomReference<DigitalCounter> phantom = new PhantomReference<DigitalCounter>(digit); // phantom reference to object created at line 3

digit = null;
```

[к оглавлению](#Garbage-Collection)

## 10. Чем они отличаются?

https://habr.com/ru/articles/549176/

https://habr.com/ru/articles/169883/

Сначала общее правило: политика зачистки для некоего объекта и очистки ссылок на него определяется самыми жёсткими из 
всех ссылок, что на него указывают.

Различие между всеми типами ссылок только одно — поведение GC с объектами, на которые они ссылаются:

+ **StrongReference** нужны для указания на объекты, которые должны обязательно оставаться в памяти всё то время, 
что эти ссылки на него существуют. Объект будет уничтожен только в том случае, если мы явно назначим ссылке `null`, 
либо потеряем доступ к ссылке через класс родитель (например класс родитель обнулится и объект также обнулиться. 
Обнулится, т.е. его будет обрабатывать GC и высвобождать память из этого объекта)

+ **WeakReference** — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.

Пример использования: `WeakHashMap` - это реализация которая хранит ключ, используя weak-ссылку. 
Когда сильная ссылка на фактический объект удалена и затем GC удаляет ключ из памяти, то удаляется вся запись из Map: 
при добавлении новой пары <ключ, значение>, создается WeakReference для ключа и в конструктор передается ReferenceQueue. 
Когда GC удаляет ключ с памяти, то ReferenceQueue возвращает соответствующий WeakReference для этого ключа. 
После этого соответствующий Entry удаляется с Map. 

`WeakHashMap` не предназначена для использования в качестве кэша. WeakReference создается для ключа, а не для значения. 
И данные будут удалены только после того, как в программе не останется strong-ссылок на ключ, а не на значение. 
В большинстве случаев это не то, чего вы хотите достичь кэшированием.
Данные с `WeakHashMap` будут удалены не сразу после того как GC обнаружит, что ключ доступен только через weak-ссылки. 
Фактически очистка произойдет при следующем обращении к `WeakHashMap`.
В первую очередь `WeakHashMap` предназначен для использования с ключами, у которых метод `equals` проверяет идентичность 
объектов (использует оператор `==`). Как только доступ к ключу потерян, его уже нельзя создать заново.

+ **SoftReference** — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти 
только в случае необходимости. По сути SoftReference - это механизм кэширования объектов в памяти, но в критической 
ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует 
спасти JVM от завершения работы.

Общий контракт звучит следующим образом: GC гарантировано удалит из кучи все объекты, доступные только по soft-ссылке, 
перед тем как бросит `OutOfMemoryError`. 

Например, если нужно насоздавать ещё объектов с сильными ссылками, а уже негде, лучше освободить кэш и 
замедлить работу, чем уронить процесс напрочь.

*Основная разница между SoftReference и WeakReference, в том, что SoftReference являются более подходящим для кэшей, а 
WeakReference для хранения метаданных.*

+ **PhantomReference** — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти, 
когда это ему "понравится" (зависит от реализации GC, возможно после нескольких запусков)

[к оглавлению](#Garbage-Collection)

## 11. Расскажите про String pool и Integer pool (Integer cache)

**String pool**

Для создания строк в Java существует класс String. Строки являются самыми частоиспользуемыми объектами в Java. Среди множества строк часто встречаются их дубликаты, поэтому в Java существуют механизмы, оптимизирующие память, которую занимают строки и числа - String pool и Integer pool.

Созданные строки являются неизменяемыми (immutable) объектами. Данное свойство позволяет организовать пул строк (String pool). Пула строк оптимизирует память путем хранения исключительно уникальных строк.

Пул строк  - это специальная область памяти в куче (heap), куда сохраняются только уникальные значения строк. 

Строка, созданная с помощью конструктора через ключевое слово new, будет создана непосредственно в heap, как и любой другой объект. При таком способе создания строк дубликаты значений никак учитываться не будут, и каждое повторное значение будет отдельным объектом со своим выделенным местом в памяти и ссылкой.

**Когда строки попадают в String pool**. Процесс помещения строки в пул строк называется интернированием.:

- Присвоить строке строковый литерал в двойных кавычках.

```java
String string1 = "Hello";
```

- В результате конкатенации литералов

```java
String string1 = "Hello, world"; 
String string2 = "Hello, " + "world";  
System.out.println(string1 == string2); \\true
```

- метод ***intern*** гарантирует, что возвращенная ссылка будет указывать на объект, находящийся в пуле строк

```java
String string1 = "Hello"; 
String string2 = new String("Hello");  
String string3 = string2.intern(); 
System.out.println(string1 == string3);
```

**Когда строки не попадут в String pool**

- C помощью конструктора, передав в него строковый литерал.

```java
String str = new String("Hello");
```

- C помощью конструктора, передав в него массив символов

```java
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String str = new String(chars);
```

`Важно! Интернирование в пул строк происходит только на этапе компиляции. Все строковые литералы, с помощью которых мы создаем новые строки в примере выше, известны нам на этапе компиляции.`

Сравнение ссылок полученной в результате конкатенации целой строки string3 и идентичной ей по значению string1 вернет false, потому что вычисление string3 будет происходить только во время выполнения программы, а результирующая строка string3 будет **создана в куче**.

```java
String string1 = "Hello, world"; 
String string2 = "Hello, "; 
String string3 = string2 + "world";  
System.out.println(string1 == string3)
```

**Integer pool**

Также в Java существует аналогичный пул для хранения объектов Integer. Также называется Integer cache. В нем хранятся числа от -128 до 127 включительно, то есть пул Integer хранит все числа, которые помещаются в тип byte. Суть пула Integer в оптимизации, также как и пула строк. Когда мы создаем объекты Integer, то все объекты, входящие в указанный диапазон, будут взяты из пула Integer. Благодаря пулу Integer системе не придется создавать новые объекты, так как они уже есть в пуле. Этого диапазона чисел достаточно для оптимизации большинства вычислений.

```java
Integer pool1 = 127; 
Integer pool2 = 127; 
System.out.println(pool1 == pool2); 
Integer heap1 = -129;
Integer heap2 = -129;
System.out.println(heap1 == heap2); 
```

В данном примере число 127 входит в диапазон [-128;127], поэтому переменные pool1 и pool2 ссылаются на один и тот же объект, который хранится в пуле Integer. А число -129 выходит за рамки этого диапазона, поэтому переменные heap1 и heap2 ссылаются на разные объекты, созданные в куче. В результате сравнение pool1 и pool2 возвращает true, а сравнение heap1 и heap2 возвращает false. 

[к оглавлению](#Garbage-Collection)

## 12. Расскажите о методе String.intern()

**Метод intern()**

Данный метод гарантирует, что возвращенная ссылка будет указывать на объект, находящийся в пуле строк.

```java
String string1 = "Hello"; 
String string2 = new String("Hello");  
String string3 = string2.intern(); 
System.out.println(string1 == string3);
```

Данный метод используется очень редко и применяется в ситуациях, когда нужно очень много раз сравнивать одни и те же строки. Мы всегда используем метод equals() для сравнения объектов на содержание идентичных данных - equals() посимвольно сравнивает данные. С помощью метода intern() можно немного повысить производительность, так как этот метод гарантирует, что строка будет взята из пула строк, в котором она хранится в единственном экземпляре (уникальна). Поэтому при необходимости многократного сравнения одних и тех же строк можно получить преимущество в производительности за счет использования оператора сравнения идентичности '==' (сравнивает ссылки) вместо equals (сравнивает данные объектов посимвольно), так как метод intern() будет гарантировать, что сравниваемые ссылки интернированных строк будут вести на один и тот же объект, хранящийся в пуле строк.

Что касается занимаемой строками памяти, то интернированные в пул строки будут удалены сборщиком мусора после того, как на эти строки не останется живых ссылок.

Метод intern() используется для оптимизации памяти. Например, если мы с базы данных загружаем справочники, а они имеют одинаковые значения, то можно весь справочник провести через intern() - это сократит память.

[к оглавлению](#Garbage-Collection)

## 13. Расскажите, что такое профайлер

**v1**

Профилировщик (profiler) - это специальная программа, с помощью которой можно оценить где, при выполнении каких операций и в каком количестве потребляются ресурсы при работе нашего приложения. Профилировщик отслеживает конструкции и операции байт-кода на уровне виртуальной машины Java. Сюда входят создание объекта, выполнение методов, состояние нитей, сборка мусора и т.д. Также с помощью профайлера можно отслеживать производительность и загрузку ЦП и использование памяти приложением. Состояние нитей и упоминание нитей в этом уроке относится к многопоточности. Многопоточность мы будем проходить в уровне Мидл. Сейчас достаточно только знать, что многопоточность - это работа приложения одновременно в нескольких нитях выполнения. Глубже сейчас в это вдаваться не нужно.

С помощью профилировщиков производится профилирование. Профилирование - это сбор и анализ данных приложения во время ее выполнения для выявления "горячих точек" и узких мест в программе.

Горячие точки - это высокая трата ресурсов - сильная загрузка ЦП или расход памяти.

Узкие места - части кода, где приложение замедляется. Например, доступ к БД.

С помощью профилировщика можно отследить где тратится память, сколько ее тратится и сколько времени это занимает в программе.

**v2**

Профилирование - это сбор и анализ характеристик работы приложения.

Проще говоря, запускаем приложение, "подключаемся" к нему, в реальном времени смотрим как оно работает, делаем выводы. Далее предпринимаем меры.

Профайлер – программа, которая осуществляет эти действия. (jmap, jconsole)

**v3**

Java профайлер — это инструмент, который позволяет анализировать производительность Java-приложений. Он позволяет идентифицировать узкие места в коде и оптимизировать производительность приложения. В данной статье мы рассмотрим, что такое Java профайлер, зачем он нужен и как им пользоваться.

Что такое Java профайлер?

Java профайлер — это программное обеспечение, которое используется для анализа производительности Java-приложений. Он позволяет определить, сколько времени занимает выполнение каждой строки кода, вызовов методов и других операций в приложении. Эта информация может быть использована для улучшения производительности и оптимизации кода.

Java профайлеры работают, измеряя время, которое занимает выполнение каждого метода и каждой строки кода в приложении. Они могут также отображать, какие методы вызывают другие методы, и сколько времени заняло выполнение каждого вызова. Эта информация может быть полезна для идентификации мест, которые занимают больше всего времени, и оптимизации кода для ускорения работы приложения.

Зачем нужен Java профайлер?

Java профайлеры могут использоваться для различных целей:

1. Идентификация узких мест в приложении. Java профайлеры позволяют идентифицировать узкие места в приложении, которые могут быть причиной замедления его работы. Это позволяет разработчикам сосредоточиться на оптимизации кода и ускорении работы приложения.

2. Оптимизация производительности приложения. Используя информацию, полученную от Java профайлера, разработчики могут оптимизировать код приложения, чтобы ускорить его работу. Оптимизация может включать в себя рефакторинг кода, изменение алгоритмов и применение оптимизаций, которые могут ускорить работу приложения.

3. Валидация производительности приложения. Java профайлеры могут использоваться для проверки производительности приложения в разных условиях. Например, профайлер может показать, как изменится производительность приложения при различных нагрузках и конфигурациях.

[к оглавлению](#Garbage-Collection)

## 14. Расскажите, как использовать VisualVM

https://job4j.ru/profile/exercise/60/task-view/1014

Java Visual VM - это инструмент, который предоставляет визуальный интерфейс для просмотра приложений на основе технологии Java (приложений Java), работающих на виртуальной машине Java (JVM). С его помощью можно анализировать производительность приложения, загрузку ЦП и памяти, снимать дампы памяти, а также хорошим преимуществом является возможность подключения плагинов для более гибкого профилирования.

В Java Visual VM поддерживается локальное и удаленное профилирование. Профилировать можно в реальном времени, а также сохранять периодические снимки сеанса профилирования (snapshot) с целью их последующего анализа.

**Вкладка Overview.**

Здесь отображается общая информация о системных параметрах, параметрах JVM, некоторые параметры приложения и тд.

![image](https://github.com/artemaverin/summary/assets/97846877/833bf74c-094f-4ba4-9d56-28c41714bd29)


**Вкладка Monitor.**

В данной вкладке показывается загрузка ЦП и памяти, количество и состояние нитей, и количество загруженных классов.

В окне CPU показывается загрузка ЦП онлайн. В окне Heap показывается загрузка памяти онлайн. Здесь же видна и ее очистка, когда это делает сборщик мусора (линия на графике идет вниз).

![image](https://github.com/artemaverin/summary/assets/97846877/9cbe5ae3-f68a-426e-ae52-ab3b92ad6bcc)

**Вкладка Threads**

В этой вкладке можно следить за состоянием нитей. Цвет обозначает состояние, в котором находится нить. Пока полоса идет по графику - нить жива. На картинке ниже верхняя нить уже закончила работу, вторая нить недавно завершила работу, и место окончания ее работы тоже видно на графике. 

![image](https://github.com/artemaverin/summary/assets/97846877/b8800e38-a9e5-44e4-802a-1f9b59fea6df)

**Вкладка Sampler**

В этой вкладке можно отслеживать время выполнения методов процессором и загрузку памяти.

Здесь производится сэмплинг. Сэмплинг - это выборка. Запуск выборки работы процесса осуществляется нажатием на кнопку CPU. Сохранить данные можно кнопкой Snapshot. Выборка по загрузке памяти делается аналогично - нажать кнопку Memory, а после сохранить кнопкой Snapshot. Сохраненные снимки (Snapshot) можно отдельно проанализировать в дальнейшем.

CPU:

![image](https://github.com/artemaverin/summary/assets/97846877/8b8de6ad-1262-4421-9156-1a9ed0c0e384)

Memory:

![image](https://github.com/artemaverin/summary/assets/97846877/f2aee79b-2a4e-48ad-a632-29d4ce7a01b8)

**Вкладка Profiler**

В этой вкладке можно делать более точное профилирование с помощью инструментирования. Инструментирование - это добавление байт-кодов в уже существующий байт-код для сбора дополнительной информации о работе методов и т.д. Похож на режим Sampling, но имеет возможность детальной настройки профилирования элементов приложения с помощью предоставленных Java инструментов.

![image](https://github.com/artemaverin/summary/assets/97846877/a6740802-05f0-4112-9bc9-f01343592318)

**Дампы**

- Дамп кучи (Heap Dump) - это мгновенный снимок (snapshot) всех Java-объектов в приложении на текущий момент. Дампы помогают в анализе проблем, связанных с памятью. Например, частая сборка мусора или переполнение памяти.

Дамп кучи помогает узнать, сколько объектов создано, какого они типа, размера, живые или нет. То есть найти причины, например, какими объектами забилась память при ее переполнении и тд. 

Создать дамп кучи можно на вкладке Monitor, нажав кнопку Heap Dump:

![image](https://github.com/artemaverin/summary/assets/97846877/226a9073-33f7-449d-bbdd-e6b510652da1)

Дамп нитей (Thread Dump).

С помощью дампа нитей можно узнать активность нитей приложения. Дамп делает мгновенный снимок всех нитей в приложении, что позволяет при последующем анализе узнать в каком состоянии была та или иная нить, заблокирована она или нет и т.д. Собрать дамп нитей можно нажав кнопку Thread Dump в разделе Threads:

![image](https://github.com/artemaverin/summary/assets/97846877/c6c9f3ca-74d8-4001-b0ee-975995cbf3f3)

[к оглавлению](#Garbage-Collection)

## 15. Расскажите, чем отличается sampling от profiling?

Profiling это единоразовый снимок состояния в памяти на момент запуска профайлера.

Sampling это периодическое обновление состояния в памяти, что позволяет наблюдать динамику использования памяти работающим приложением.

Sampling и Profiling - это два разных типа техник сбора данных в программировании и разработке.

**Sampling** (выборка): Это процесс сбора данных, когда система или приложение работает в реальном времени. Sampling обычно используется для мониторинга и анализа производительности системы. Он основан на выборке случайных точек во время выполнения программы, чтобы собрать информацию о состоянии системы. Этот метод менее ресурсоемкий, но может привести к потере данных и неточностям, особенно если выборка нерепрезентативна.

**Profiling** (профилирование): Это продвинутый метод сбора данных, который включает в себя глубокий анализ производительности и поведения системы. Profiling позволяет получить подробную информацию о времени выполнения кода, используемых ресурсах, загрузке процессора и т.д. Он позволяет определить “горячие точки” или участки кода, которые занимают больше всего времени на выполнение. Profiling обычно требует остановки приложения или запуска специального инструмента, который будет собирать данные. Этот метод более ресурсоемкий и может повлиять на производительность системы, но он обеспечивает более точные и детальные данные, чем sampling.

[к оглавлению](#Garbage-Collection)

## Источники:

**Сравнение языков программирования** 

https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F

**Описание распределения памяти в JVM, принципы работы и виды GC** 

HotSpot Virtual Machine Garbage Collection Tuning Guide https://docs.oracle.com/en/java/javase/12/gctuning/index.html

"Сборщик мусора Garbage Collection" http://java-online.ru/garbage-collection.xhtml

"Дюк, вынеси мусор! — Часть 1" https://habr.com/ru/post/269621/

"How Garbage Collection works in Java" https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html

"Краткий конспект реализации Garbage Collector в Java" https://ziginsider.github.io/Garbage_Collector_Java/

"Секреты сборки мусора в Java" http://profyclub.ru/docs/305

"Сборщик мусора G1 в Java 9" https://urvanov.ru/2018/03/25/%d1%81%d0%b1%d0%be%d1%80%d1%89%d0%b8%d0%ba-%d0%bc%d1%83%d1%81%d0%be%d1%80%d0%b0-g1-%d0%b2-java-9/

**Типы ссылок в Java** 

"Ссылка (Java)" http://cyclowiki.org/wiki/%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B0_(Java)#targetText=%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8%20%D0%B2%20Java%20%E2%80%94%20%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8%20%D0%BD%D0%B0,%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20%D0%BF%D0%BE%20%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E).

"Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Java" https://javarevisited.blogspot.com/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html

"Types of References in Java" https://www.geeksforgeeks.org/types-references-java/

"Мягкие ссылки на страже доступной памяти или как экономить память правильно" https://habr.com/ru/post/169883/

"Weak, Soft, and Phantom References in Java (and Why They Matter)" https://dzone.com/articles/weak-soft-and-phantom-references-in-java-and-why-they-matter

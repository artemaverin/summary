## Garbage Collection

[1. Чем Java отличается от C++?](#1-Чем-Java-отличается-от-C)

[2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)

## 1. Чем Java отличается от C++?

автоматическая сборка мусора отличает Java от языков более низкого уровня, в частности С/С++.

[к оглавлению](#Garbage-Collection)

## 2. Что такое менеджер памяти?

Менеджер памяти — часть компьютерной программы (как прикладной, так и операционной системы), обрабатывающая запросы на выделение и освобождение оперативной памяти или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

В Java, “Менеджер памяти” - это часть среды исполнения Java (JVM), которая отвечает за управление памятью, выделяя ее для объектов, которые создает и использует ваша Java-программа.

Когда вы создаете новый объект в Java, менеджер памяти выделяет память для его хранения. Когда объект больше не используется, менеджер памяти освобождает эту память обратно, чтобы она могла быть использована для других целей.

Важно понимать, что менеджер памяти управляет только памятью для объектов. Он не имеет ничего общего с оперативной памятью или памятью компьютера, на котором выполняется программа. Вместо этого, менеджер памяти работает внутри виртуальной машины Java (JVM) и управляет памятью в рамках этой виртуальной машины.

[к оглавлению](#Garbage-Collection)

## 3. Какой механизм используется в Java для управления памятью?

В Java используется несколько механизмов для управления памятью. `Один из них - это сборка мусора (Garbage Collection)`. Сборка мусора - это процесс, во время которого менеджер памяти ищет все объекты, которые больше не используются программой, и удаляет их из памяти.

Кроме того, Java также использует технику под названием “аллокатор памяти” для управления памятью на более низком уровне. Алокатор памяти отвечает за выделение и освобождение памяти для объектов на протяжении всего времени выполнения программы.

`GC смотрит на достижимость объекта по ссылке. Это значит, что если мы не можем получить к нему доступ из программы, т.е. у нас нет ссылки на него, то он помечается как мусор и будет удален при следующей сборке мусора.`

## 4. Опишите процесс работы сборщика мусора

Прежде чем удалить объект, нужно знать, где он находится. Давайте рассмотрим структуру памяти в Java. Все объекты хранятся в куче (heap). Куча делится на поколения (generation). Есть всего два поколения: молодое (young) и старое (old). Young generation состоит из eden и survivor space.

![image](https://github.com/artemaverin/summary/assets/97846877/2e67f82c-1f51-43dc-9cf3-2cf2569ef139)

# Сборка мусора

Сборка мусора происходит, когда заполнена вся область памяти. Память делится на два поколения, поэтому есть два типа сборки мусора: _minor GC_ и _major GC_. Первый происходит, когда переполняется young generation, второй, когда переполняется область из old generation.

Теперь поговорим какие стадии проходят объекты до сборки мусора.

1. Объект рождается. Во время исполнения JVM видит, что стоит оператор new. Происходит выделение памяти под объект и возврат ссылки, которая будет ссылаться на занятый участок памяти. Все объекты рождаются в eden

![image](https://github.com/artemaverin/summary/assets/97846877/a2cdacdf-071a-4fc0-837e-14323d34eb34)

2. Этап 1 выполняет до тех пор, пока не будет заполнен eden

![image](https://github.com/artemaverin/summary/assets/97846877/75718acc-1717-46fc-8d0d-b2da743c8e6a)

Когда eden заполнен происходит minor GC:

3. Объекты, у которых уже нет ссылки удаляются

![image](https://github.com/artemaverin/summary/assets/97846877/b38f1d9b-81d0-4124-a379-a7d3f4f4cd3d)

4. Объекты, у которых есть ссылки попадают в survivor space из eden. Причем survivor space делиться на две части. Между этими частями происходит перемещения объектов. В один момент времени одна из частей пуста, чтоб мочь вместить объекты пришедшие из eden.

![image](https://github.com/artemaverin/summary/assets/97846877/6fae5c49-d684-4279-a060-5945ed94a4de)

5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age). Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется «взрослением» (aging).

![image](https://github.com/artemaverin/summary/assets/97846877/fc80edb6-89a3-4755-aa06-9f68828592da)

6. Объекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением» promotion.

![image](https://github.com/artemaverin/summary/assets/97846877/21013d1a-0778-47b3-a9ca-a3a6a1fe1aab)

Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для очищения young generation.

7. Когда old generation заполняется производиться major GC

8. Этапы 1-7 происходят на протяжении работы программы

## 5. Какие алгоритмы сборщика вы знаете?

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

- Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .

- Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.

- Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

![image](https://github.com/artemaverin/summary/assets/97846877/5d492fb8-9075-4468-a597-8587bb96425c)

**Характеристики сборщиков мусора**

Сборщики мусора различаются относительно характеристик какими они обладают. Рассмотрим эти характеристики.



**Последовательное (Serial) vs параллельное (Parallel) исполнение сборки мусора.**

Вы уже знаете, что чтобы очистить память нужно остановить приложение - событие Stop The World.

Причем сам процесс сборки может быть ускорен за счет использования нескольких процессоров, если они присутствуют физически.

Если мы используем последовательную сборку, то она выполняется только в одном потоке и задействует только один процессор, что увеличивает время сборки.

С другой стороны мы можем использовать несколько процессоров за счет распараллеливания сборки, что уменьшает время сборки, ценой затрат ресурсов (процессоров) и некоторых накладных расходов (overhead), требуемых для организации работы потоков исполнения (Thread).



**Параллелизм (Concurrency) vs Stop The World**

Еще одним способом уменьшения времени пауз является использование параллелизма. Данный подход заключается в том, что сборщик мусора работает одновременно с самим приложением. При этом он не ждет пока heap заполнится полностью, он периодически производит "мелкие" сборки.

Причем эти сборки тоже вызывают событие Stop The World, но по времени оно занимает меньше чем если бы сборщик мусора чистил бы полностью heap.

Использование данного подхода оправдано в системах, где требуется минимальный отклик от приложения и не допустимы долгие паузы.

Однако эти минимальные паузы достигаются за счет того, что сборщик мусора требует heap больше.



**Виды сборок мусора.**

После того как сборщик мусора определил, что нужно удалить объекты, он может пользоваться следующими сборками: Compacting, Non-compacting and Copying.

- _Compacting (Compact с англ. уплотнить):_

Собирает "живые" объекты в одном месте и очищает оставшуюся часть памяти, где находятся объекты, которые нужно уничтожить.

Преимущество такого подхода - легко можно выделять память для новых объектов.

Недостаток - требуется время на компоновку объектов в одном месте.

- _Non-compacting._

Удаляет объекты по месту. Т.е. он понимает, что данную часть памяти занимает объект, который нужно удалить, и чистит эту часть памяти.

Преимущество: не нужно производить лишние действия, нужно просто удалить объекты.

Недостаток: при создании объекта нужно находить для него подходящее место, что приводит к фрагментации памяти (это когда большая часть вашей памяти выделена в большом количестве несмежных блоков, оставляя приличный процент вашей общей памяти нераспределенной, но при этом непригодной для большинства типичных сценариев использования памяти), то есть много свободных мест памяти между занятыми ячейками, но из-за малых ее размеров, ее практически ничем не занять, и эта память простаивает.

- _Copying._

Копирует "живые" объекты в отдельную часть памяти, очистив старую часть, где они были (С этим типом вы встречались в прошлом задании).

Преимущество: нет препятствий выделению памяти.

Недостаток: требуется время на копирование.

## 6. Чем отличаются сборщики мусора?

1. Serial GC.

Это самый простой вид сборщика. Он является Serial, Stop The World, Copying, т.е. выполняет сборку мусора в одном потоке, вызывается событие Stop The World и используется Copying сборку мусора. Подходит для простых клиентских приложений, к примеру проигрывателя музыки.

Плюс: минимальные требования к среде. Минус: медленный.

2. Parallel GC

Это усовершенствованная версия сборщика GC. Он является Parallel, Stop The World, Copying, т.е. его единственное отличие в том, что он выполняет сборку мусора в нескольких потоках. Подходит для более сложных клиентских приложений, где нет серьезных требований к скорости сборки, но ее наличие было бы неплохим преимуществом. К примеру, несложное приложение для работы с графикой.

Плюс: пошустрее, чем Serial GC. Минус: недостаточно быстрый, по сравнению с CMS, требует наличие нескольких ядер.

3. CMS (Concurrent Mark Sweep)

Это улучшенная версия Parallel GC. Он является Parallel, Concurrent, Copying. Лучше прошлого он тем, что используется параллелизм, т.е. часть heap чиститься наряду с работой приложения. Подходит для клиентских приложений, где длительные паузы не допустимы, например, настольное приложения для торговли на бирже.

Убран с JDK 14.

Плюс: небольшие паузу на сборку мусора. Минус: более высокие системные требования.

4. G1

Мощный сборщик сборщик мусора, усовершенствованная версия CMS. Он является Parallel, Concurrent, Copying. Его особенностью является высокая пропускная способность. Следовательно сборка мусора выполняется редко. Данный сборщик мусора используется для серверных приложений требующих быстрого отклика и не терпящих долгих пауз на сборку мусора.

Плюс: скорость. Минус: нужен большой heap (> 4gb)

5. ZGC

Данный сборщик появился недавно. Он является Parallel, Concurrent, Copying. Причем он использует параллелизм на полную мощь. Тем самым для очистки вовсе не требует остановки приложения, в отличие от G1, где паузы хоть и маленькие но присутствуют. Используется для приложений где допустимы лишь паузы < 10ms

Плюс: нет паузы. Минус: требует сверх большой heap в несколько терабайтов для эффективной работы

Доступен только с JDK 11.

- ---------------

![image](https://github.com/artemaverin/summary/assets/97846877/f89b6bde-6855-4fe0-823b-7f7016b59299)




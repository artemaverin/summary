## Garbage Collection

[1. Чем Java отличается от C++?](#1-Чем-Java-отличается-от-C)

[2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-Что-такое-ссылки)

[9. Какие типы ссылок вы знаете?](#9-Какие-типы-ссылок-вы-знаете)

[10. Чем они отличаются?](#10-Чем-они-отличаются)

[11. Расскажите про String pool и Integer pool (Integer cache)](#11-Расскажите-про-String-pool-и-Integer-pool-Integer-cache)

[12. Расскажите о методе String.intern()](#12-Расскажите-о-методе-String-intern)

[13. Расскажите, что такое профайлер](#13-Расскажите-что-такое-профайлер)

[14. Расскажите, как использовать VisualVM](#14-Расскажите-как-использовать-VisualVM)

[15. Расскажите, чем отличается sampling от profiling?](#15-Расскажите-чем-отличается-sampling-от-profiling)

[16. Расскажите о методе finalize()](#16-Расскажите-о-методе-finalize)

[17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?](#17-Расскажите-о-методе-clone-Что-такое-Deep-clone-and-Shallow-clone)

[18. Расскажите о Stack, Heap и Metaspace](#18-Расскажите-о-Stack-Heap-и-Metaspace)

[19. Что такое ClassLoader? Перечислите основные реализации ClassLoader](#19-Что-такое-ClassLoader-Перечислите-основные-реализации-ClassLoader)

[20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?](#20-Расскажите-иерархию-штатных-загрузчиков-классов-в-Java-Какой-загрузчик-находится-в-корне-иерархии)

[21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?](#21-Какой-загрузчик-классов-нельзя-получить-методом-getClassLoader-Почему)

[22. Расскажите алгоритм поиска и загрузки класса в JVM](#22-Расскажите-алгоритм-поиска-и-загрузки-класса-в-JVM)

## 1. Чем Java отличается от C++?

автоматическая сборка мусора отличает Java от языков более низкого уровня, в частности С/С++.

В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов new и delete).

В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. (освобождает память в куче, занятой неиспользуемыми объектами)

Т.е. в отличие от С++ нет явной необходимости уничтожать объект.

![image](https://github.com/artemaverin/summary/assets/97846877/6b722446-92bb-4525-9e74-b6cce2db05ed)


[к оглавлению](#Garbage-Collection)

## 2. Что такое менеджер памяти?

Менеджер памяти — часть компьютерной программы (как прикладной, так и операционной системы), обрабатывающая запросы на выделение и освобождение оперативной памяти или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

В Java, “Менеджер памяти” - это часть среды исполнения Java (JVM), которая отвечает за управление памятью, выделяя ее для объектов, которые создает и использует ваша Java-программа.

Когда вы создаете новый объект в Java, менеджер памяти выделяет память для его хранения. Когда объект больше не используется, менеджер памяти освобождает эту память обратно, чтобы она могла быть использована для других целей.

Важно понимать, что менеджер памяти управляет только памятью для объектов. Он не имеет ничего общего с оперативной памятью или памятью компьютера, на котором выполняется программа. Вместо этого, менеджер памяти работает внутри виртуальной машины Java (JVM) и управляет памятью в рамках этой виртуальной машины.

[к оглавлению](#Garbage-Collection)

## 3. Какой механизм используется в Java для управления памятью?

https://job4j.ru/profile/exercise/58/task-view/369

**v1**

В Java используется несколько механизмов для управления памятью. `Один из них - это сборка мусора (Garbage Collection)`. Сборка мусора - это процесс, во время которого менеджер памяти ищет все объекты, которые больше не используются программой, и удаляет их из памяти.

Кроме того, Java также использует технику под названием “аллокатор памяти” для управления памятью на более низком уровне. Алокатор памяти отвечает за выделение и освобождение памяти для объектов на протяжении всего времени выполнения программы.

`GC смотрит на достижимость объекта по ссылке. Это значит, что если мы не можем получить к нему доступ из программы, т.е. у нас нет ссылки на него, то он помечается как мусор и будет удален при следующей сборке мусора.`

**v2**

Распределение памяти в java реализует технология Java HotSpot от Oracle. 
Она обеспечивает динамическое выделение памяти для объектов и сборщиков мусора.

Память процесса делится на non-heap (до JDK 8 stack) и heap (куча):

В предыдущих выпусках Java Hotspot VM метаданные класса выделялись в Permanent Generation.
Начиная с JDK 8, permanent generation было удалено, а метаданные класса размещены в собственной памяти. 
Объем собственной памяти, которую можно использовать для метаданных класса, по умолчанию не ограничен. 

+ Stack (структура non-heap до JDK 8)
    + Permanent Generation — содержит необходимые для управления программой метаданные классов, 
    в том числе метаданные о созданных объектах, методах и т.п.
    + Code Cache — используемая JVM память при включенной JIT-компиляции 
    (в этой области памяти кешируется скомпилированный платформенно-зависимый код)     
 
+ Heap - куча (тут и работает GC)
    + New (Yang) Generation - хранит короткоживущие объекты.
        + Eden Space — сюда аллоцируются среднестатистические объекты*. Если нет места запускается малая сборка мусора (minor GC). 
        + Survivor Space — точнее их два, S1 и S2, и они меняются ролями. 
        Хранятся перемещенные из Eden Space объекты, признанные живыми во время сборки мусора (без разницы малой или полной). 
        Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
    + Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется, 
    выполняется полная сборка мусора (full GC).

Алгоритм GC исходит из того предположения, что большинство java-объектов живут недолго. 
Быстро становятся мусором. От них необходимо довольно оперативно избавляться. Что и происходит в New Generation. 
Там сбор мусора гораздо чаще, чем в Old Generation, где хранятся долгоживущие объекты. 
После создания объект попадает в New Generation и имеет шанс попасть в Old Generation по прошествии нескольких циклов GC.

*объекты-акселераты, размер которых настолько велик, что создавать их в Eden, 
а потом таскать за собой по Survivor’ам слишком накладно, размещаются сразу в Tenured Generation.

![image](https://github.com/artemaverin/summary/assets/97846877/cd7ad861-6d2a-4091-8ae3-40accc6d4c96)

![image](https://github.com/artemaverin/summary/assets/97846877/2283348d-a8f1-4634-bc55-22939361788d)


[к оглавлению](#Garbage-Collection)

## 4. Опишите процесс работы сборщика мусора

Прежде чем удалить объект, нужно знать, где он находится. Давайте рассмотрим структуру памяти в Java. Все объекты хранятся в куче (heap). Куча делится на поколения (generation). Есть всего два поколения: молодое (young) и старое (old). Young generation состоит из eden и survivor space.

![image](https://github.com/artemaverin/summary/assets/97846877/2e67f82c-1f51-43dc-9cf3-2cf2569ef139)

# Сборка мусора

Сборка мусора происходит, когда заполнена вся область памяти. Память делится на два поколения, поэтому есть два типа сборки мусора: _minor GC_ и _major GC_. Первый происходит, когда переполняется young generation, второй, когда переполняется область из old generation.

Теперь поговорим какие стадии проходят объекты до сборки мусора.

1. Объект рождается. Во время исполнения JVM видит, что стоит оператор new. Происходит выделение памяти под объект и возврат ссылки, которая будет ссылаться на занятый участок памяти. Все объекты рождаются в eden

![image](https://github.com/artemaverin/summary/assets/97846877/a2cdacdf-071a-4fc0-837e-14323d34eb34)

2. Этап 1 выполняет до тех пор, пока не будет заполнен eden

![image](https://github.com/artemaverin/summary/assets/97846877/75718acc-1717-46fc-8d0d-b2da743c8e6a)

Когда eden заполнен происходит minor GC:

3. Объекты, у которых уже нет ссылки удаляются

![image](https://github.com/artemaverin/summary/assets/97846877/b38f1d9b-81d0-4124-a379-a7d3f4f4cd3d)

4. Объекты, у которых есть ссылки попадают в survivor space из eden. Причем survivor space делиться на две части. Между этими частями происходит перемещения объектов. В один момент времени одна из частей пуста, чтоб мочь вместить объекты пришедшие из eden.

![image](https://github.com/artemaverin/summary/assets/97846877/6fae5c49-d684-4279-a060-5945ed94a4de)

5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age). Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется «взрослением» (aging).

![image](https://github.com/artemaverin/summary/assets/97846877/fc80edb6-89a3-4755-aa06-9f68828592da)

6. Объекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением» promotion.

![image](https://github.com/artemaverin/summary/assets/97846877/21013d1a-0778-47b3-a9ca-a3a6a1fe1aab)

Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для очищения young generation.

7. Когда old generation заполняется производиться major GC

8. Этапы 1-7 происходят на протяжении работы программы

[к оглавлению](#Garbage-Collection)

## 5. Какие алгоритмы сборщика вы знаете?

Виды сборщиков:

· Serial GC

· Parallel GC

· Concurrent Mark Sweep (CMS)

· Garbage-First (G1)

· Z Garbage Collector (ZGC)

https://job4j.ru/profile/exercise/59/task-view/371

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

- Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .

- Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.

- Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

![image](https://github.com/artemaverin/summary/assets/97846877/5d492fb8-9075-4468-a597-8587bb96425c)

**v2**

Имеется два подхода к очистке памяти, которые в совокупности определяют принцип функционирования Garbage Collection.

1. *Copying collectors* - в чистом виде в HotSpot VM не используется.

    Область памяти делится на две части: в одной части размещаются объекты, а вторая часть остается чистой. 
    На время очистки мусора приложение останавливает работу и запускается `GC`, который находит в первой области 
    объекты со ссылками и переносит их во вторую (чистую) область. После этого, первая область очищается от оставшихся 
    там объектов без ссылок, и области меняются местами.

    Достоинство данного подхода - плотное заполнение памяти. 
    
    Недостаток - необходимость остановки приложения и размеры двух частей памяти должны быть одинаковыми на случай, 
    когда все объекты остаются «живыми».

2. *Mark-and-sweep* - также в чистом виде в HotSpot VM не используется.

    Все объекты размещаются в одном сегменте памяти. Сборка мусора также приостанавливает приложение, и GC проходит 
    по дереву объектов, помечая занятые ими области памяти, как «живые». После этого, все не помеченные участки памяти 
    сохраняются в «free list», в которой будут, после завершения сборки мусора, размещаться новые объекты.
    
    Недостатки - необходимость приостановки приложения. 
    Кроме этого, время сборки мусора, как и время приостановки приложения, зависит от размера памяти. 
    Память становится «решетчатой», и, если не применить «уплотнение», то память будет использоваться неэффективно.

[к оглавлению](#Garbage-Collection)

## 6. Чем отличаются сборщики мусора?

**Характеристики сборщиков мусора**

Сборщики мусора различаются относительно характеристик какими они обладают. Рассмотрим эти характеристики.


**Последовательное (Serial) vs параллельное (Parallel) исполнение сборки мусора.**

Вы уже знаете, что чтобы очистить память нужно остановить приложение - событие Stop The World.

Причем сам процесс сборки может быть ускорен за счет использования нескольких процессоров, если они присутствуют физически.

Если мы используем последовательную сборку, то она выполняется только в одном потоке и задействует только один процессор, что увеличивает время сборки.

С другой стороны мы можем использовать несколько процессоров за счет распараллеливания сборки, что уменьшает время сборки, ценой затрат ресурсов (процессоров) и некоторых накладных расходов (overhead), требуемых для организации работы потоков исполнения (Thread).


**Параллелизм (Concurrency) vs Stop The World**

Еще одним способом уменьшения времени пауз является использование параллелизма. Данный подход заключается в том, что сборщик мусора работает одновременно с самим приложением. При этом он не ждет пока heap заполнится полностью, он периодически производит "мелкие" сборки.

Причем эти сборки тоже вызывают событие Stop The World, но по времени оно занимает меньше чем если бы сборщик мусора чистил бы полностью heap.

Использование данного подхода оправдано в системах, где требуется минимальный отклик от приложения и не допустимы долгие паузы.

Однако эти минимальные паузы достигаются за счет того, что сборщик мусора требует heap больше.


**Виды сборок мусора.**

После того как сборщик мусора определил, что нужно удалить объекты, он может пользоваться следующими сборками: Compacting, Non-compacting and Copying.

- Compacting (Compact с англ. уплотнить):

Собирает "живые" объекты в одном месте и очищает оставшуюся часть памяти, где находятся объекты, которые нужно уничтожить.

Преимущество такого подхода - легко можно выделять память для новых объектов.

Недостаток - требуется время на компоновку объектов в одном месте.

- Non-compacting.

Удаляет объекты по месту. Т.е. он понимает, что данную часть памяти занимает объект, который нужно удалить, и чистит эту часть памяти.

Преимущество: не нужно производить лишние действия, нужно просто удалить объекты.

Недостаток: при создании объекта нужно находить для него подходящее место, что приводит к фрагментации памяти (это когда большая часть вашей памяти выделена в большом количестве несмежных блоков, оставляя приличный процент вашей общей памяти нераспределенной, но при этом непригодной для большинства типичных сценариев использования памяти), то есть много свободных мест памяти между занятыми ячейками, но из-за малых ее размеров, ее практически ничем не занять, и эта память простаивает.

- Copying.

Копирует "живые" объекты в отдельную часть памяти, очистив старую часть, где они были (С этим типом вы встречались в прошлом задании).

Преимущество: нет препятствий выделению памяти.

Недостаток: требуется время на копирование.



Метрики оценки сборщиков мусора

Для того, чтобы оценить сборщик мусора смотрят на следующие характеристики:

- Thoughput (Пропускная способность) - процентное соотношение, показывающее сколько GC может работать БЕЗ полной сборки мусора.

Формально, (1 - время_на_сборки / общ_время) * 100

- GC Overhead - процентное соотношение, показывающее сколько требуется на времени на сборку.

Формально, (время_на_сборки / общ_время) * 100

- Pause Time (или Latency) - это время на которое требуется остановить приложение, чтобы произвести сборку мусора

- Freequency of collection - это количество сборок проводимых за все время работы приложения.

- Promptness - это время между началом сборки мусора и моментом, когда память снова становится доступной для размещения объектов.

- Footprint - это количество памяти доступное приложению


**v1**

1. Serial GC.

Это самый простой вид сборщика. Он является Serial, Stop The World, Copying, т.е. выполняет сборку мусора в одном потоке, вызывается событие Stop The World и используется Copying сборку мусора. Подходит для простых клиентских приложений, к примеру проигрывателя музыки.

Плюс: минимальные требования к среде. Минус: медленный.

2. Parallel GC

Это усовершенствованная версия сборщика GC. Он является Parallel, Stop The World, Copying, т.е. его единственное отличие в том, что он выполняет сборку мусора в нескольких потоках. Подходит для более сложных клиентских приложений, где нет серьезных требований к скорости сборки, но ее наличие было бы неплохим преимуществом. К примеру, несложное приложение для работы с графикой.

Плюс: пошустрее, чем Serial GC. Минус: недостаточно быстрый, по сравнению с CMS, требует наличие нескольких ядер.

3. CMS (Concurrent Mark Sweep)

Это улучшенная версия Parallel GC. Он является Parallel, Concurrent, Copying. Лучше прошлого он тем, что используется параллелизм, т.е. часть heap чиститься наряду с работой приложения. Подходит для клиентских приложений, где длительные паузы не допустимы, например, настольное приложения для торговли на бирже.

Убран с JDK 14.

Плюс: небольшие паузу на сборку мусора. Минус: более высокие системные требования.

4. G1

Мощный сборщик сборщик мусора, усовершенствованная версия CMS. Он является Parallel, Concurrent, Copying. Его особенностью является высокая пропускная способность. Следовательно сборка мусора выполняется редко. Данный сборщик мусора используется для серверных приложений требующих быстрого отклика и не терпящих долгих пауз на сборку мусора.

Плюс: скорость. Минус: нужен большой heap (> 4gb)

5. ZGC

Данный сборщик появился недавно. Он является Parallel, Concurrent, Copying. Причем он использует параллелизм на полную мощь. Тем самым для очистки вовсе не требует остановки приложения, в отличие от G1, где паузы хоть и маленькие но присутствуют. Используется для приложений где допустимы лишь паузы < 10ms

Плюс: нет паузы. Минус: требует сверх большой heap в несколько терабайтов для эффективной работы

Доступен только с JDK 11.

- ---------------

**v2**

![image](https://github.com/artemaverin/summary/assets/97846877/f89b6bde-6855-4fe0-823b-7f7016b59299)

- -------------

**v3**

**Serial (последовательный)** — самый простой вариант для приложений, 
которым не требуется большой размер кучи для работы (Oracle указывает условную границу 100 МБ), 
которые не очень чувствительны к коротким остановкам и им для работы доступно только одно ядро процессора.
Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

**+** Непритязательность по части ресурсов компьютера. Т.к. всю работу он выполняет последовательно в одном потоке, никаких заметных оверхедов и негативных побочных эффектов у него нет.

**-** Долгие паузы на сборку мусора при заметных объемах данных. 

**-** Все настройки Serial GC крутятся вокруг размеров различных регионов кучи, т.е. для тонкой настройки 
требуется вручную что-то изучать, настраивать, экспериментировать и т.д. 

**Parallel (параллельный)** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в 
некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для большинства приложений. 
У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

**+** в сравнении с Serial GC есть возможность автоматической подстройки под требуемые параметры производительности 
и меньшие паузы на время сборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.

**-** Определенная фрагментация памяти, но вряд ли она будет существенной для большинства приложений, 
т.к. сборщиком используется относительно небольшое количество потоков.

**Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора 
параллельно с основными потоками приложения. Более требователен к ресурсам процессора.
Подходит для работы в приложениях с относительно большими объемами долгоживущих данных,
для приложений, имеющих доступ к нескольким ядрам процессора и чувствительных к паузам STW.

**+** по сравнению с рассмотренными ранее Serial/Parallel GC ориентирован на минимизацию времени простоя, 
что является критическим фактором для многих приложений. 
Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.

**-** не уплотняет объекты в старшем поколении, что приводит к фрагментации области Tenured. 
Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению 
(конкретно — старшему поколению) больше памяти, чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).

**-** долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. 
Хотя они не частые, и при наличии достаточного объема памяти сборщику CMS удается их полностью избегать.

**Garbage-First (G1)** — создан для замены CMS, но не является явным продолжением линейки Serial/Parallel/CMS. 
Мспользуется в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных 
(размер кучи от 4 ГБ и выше), для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет 
уменьшения пропускной способности.

**+** G1 более точно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, 
чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. 

**+** В отличие от CMS, например, он не фрагментирует память.

**-** Тратит ресурсы процессора, которые использует для выполнения достаточно большой части своей работы параллельно с основной программой. 
В результате страдает пропускная способность приложения. 
Целевое значением пропускной способности по умолчанию для G1 равно 90%, для Parallel GC составляет 99%. 
Это не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует учитывать.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_6.1.png)
 
«Монолитный» означает то, что всё поколение должно быть очищено за проход.

«В большинстве случаев одновременный» — mostly concurrent, одновременный имеется в виду фоновый, «работающий вместе с потоками приложения».

**Z Garbage Collector (ZGC)** - это масштабируемый сборщик мусора с малой задержкой. 
ZGC выполняет всю дорогостоящую работу одновременно, не останавливая выполнение потоков приложения.

ZGC предназначен для приложений, которые требуют малой задержки (паузы менее 10 мс) и/или используют очень большую кучу 
(мульти-терабайты). Включается с помощью опции `-XX:+UseZGC`.

ZGC доступен в качестве экспериментальной функции, начиная с JDK 11.

Подробнее здесь https://habr.com/ru/post/269621/

[к оглавлению](#Garbage-Collection)

## 7. Расскажите про утилиты для анализа памяти?

встроенные в JDK утилиты: jps, jmap, jstat, jconsole, visualvm до java 9.

внешние: VisualVM c java 9 и утилита от NetBeans - YourKit Java Profiler.

jconsole, visualvm и yourkit profiler предоставляют удобный визуальный интерфейс.

**jps** - выводит pid-ы процессов, которые использует VM

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.1.png)

 
**jmap** - выводит информацию о состоянии памяти виртуальной машины
	
`jmap -heap 14152` или `jhsdb jmap --heap --pid 14152`
	
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.2.png)
 
**jstat** - аналогично jmap

**jstack** - показывает какие процессы запущены в  виртуальной машине (нет инфы о памяти)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.3.png)
 
...

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.4.png) 

**jconsole**
 
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.5.png) 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.6.png)

**VisualVM** (с плагином VisualGC)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.7.png) 

**YourKit Profiler** - универсальный расширенный профилировщик, используется не только для анализа памяти, 
но и ,например, для поиска узких мест в коде (повторения и тп)

[к оглавлению](#Garbage-Collection)

## 8. Что такое ссылки?

Перед сборкой мусора сборщик мусора маркирует объекты. В зависимости от этого он решает какие нужно удалить, а какие нет. На принятие решения об удалении влияет тип ссылки объекта.

Ссылки в Java — это механизм, позволяющий работать с объектами в памяти компьютера. Ссылки используются для обращения к объектам и вызова их методов. В Java все объекты создаются в динамической памяти, и для работы с ними используются ссылки.

Ссылки в Java работают следующим образом: при создании объекта в памяти выделяется блок памяти определенного размера, который содержит данные объекта. Затем создается ссылка на этот блок памяти. Ссылка может указывать на объект определенного типа или интерфейса.
- -----------------------

Ссылки в Java — это указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, 
в которой хранится объект. Кроме того, ссылка может быть инициализирована как `null` — нулевая ссылка, не указывающая 
ни на какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом 
контексте также может быть использована ссылка `this`, указывающая на текущий объект, и ссылка `super`, 
указывающая на текущий объект суперкласса.

Абстрактный класс `java.lang.ref.Reference` предоставляет базу для ссылочных классов. В нём определены следующие методы:

+ `get` — метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
+ `clear` — очищает ссылку.
+ `isEnqueued` и `enqueue`, отвечающие за взаимодействие ссылки и объекта `ReferenceQueue`.

[к оглавлению](#Garbage-Collection)

## 9. Какие типы ссылок вы знаете?

https://job4j.ru/profile/exercise/61/task-view/375

https://habr.com/ru/articles/169883/

https://www.youtube.com/watch?v=5HC8qVHQPi8

В Java существует четыре типа ссылок, различающихся по способу сбора мусора и 
предоставляющие пользователю возможность более гибко работать с памятью:
                                                                            
+ **Сильные ссылки (Strong References)** - стандартные ссылки, создаются каждый раз, когда аллоцируем место в памяти через 
оператор new. Если на объект есть хоть одна жесткая ссылка, то данный объект не будет утилизирован при сборке мусора, что может привести к утечке памяти, что в свою очередь может привести к ошибке OutOfMemoryException - ситуации когда программе не хватает выделенной памяти.

```java
Counter counter = new Counter(); // strong reference
```

+ **Мягкие ссылки (Soft References)** - создаются с помощью вызова `new SoftReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new SoftReference(T obj)`. Если на объект есть только мягкая ссылка, то будет выполнена попытка утилизации данного 
объекта при сборке мусора в случае, если приложению не хватает памяти.т.е. они могут пережить более одной сборки мусора.

Данный тип ссылок подходит для реализации кэша - такой структуры данных, при которой часть данных запоминается, а потом часто переиспользуется.

Например, можно запоминать данные из файлов или тяжелых запросов.

При нехватке памяти JVM может удалить объекты по этим ссылкам, если на них нет сильных ссылок.

Есть контракт для данного типа ссылок: GC гарантировано удалит из кучи все объекты, доступные только по soft-ссылке, перед тем, как бросит OutOfMemoryError

```java
Counter prime = new Counter();  // prime holds a strong reference - line 2
SoftReference<Counter> soft = new SoftReference<Counter>(prime) ; //soft reference variable has SoftReference to Counter Object created at line 2

prime = null;  // now Counter object is eligible for garbage collection but only be collected when JVM absolutely needs memory
```

Корректным использованием безопасных ссылок является сначала получение сильной ссылки на данные, а потом работа с сильной ссылкой.

Это гарантирует, что в интервалах получения сильной ссылки из безопасной GC не затрет объект. Это касается не только локальных переменных, но и возвращаемых значений и аргументов.

+ **Слабые ссылки (WeakReferences)** - создаются с помощью вызова `new WeakReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new WeakReference<T>(T obj)`.Объекты, на которые ссылаются слабые ссылки, удаляются сразу, если на них нет сильных или безопасных ссылок.

```java
Counter counter = new Counter(); // strong reference - line 1
WeakReference<Counter> weakCounter = new WeakReference<Counter>(counter); //weak reference
counter = null; // now Counter object is eligible for garbage collection
```

Данный тип ссылок служит для реализации структур, для которых у одного значения типа может быть только один объект, например пул строк, и объекты чаще всего используется всего один раз, т.е. сохранили-получили-забыли.

+**ReferenceQueue** - Все типы ссылок, за исключением сильных, в Java являются наследниками класса Reference. Все его наследники всегда попадают в ReferenceQueue, это может происходить явно (мы можем задать свою очередь) или неявно (когда мы не задаем). В нее попадают ссылки тех объектов, которые уже помечены на удаление.

+ **Фантомные ссылки (PhantomReferences)** - создаются с помощью вызова `new PhantomReference<T>(T obj, ReferenceQueue<T> queue)`.
Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок. 
Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора. 
Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка или данная 
фантомная ссылка не очищена с помощью вызова метода `clear()`. Так же стоит заметить, что метод `get()` фантомной ссылки 
всегда возвращает `null`.

```java
DigitalCounter digit = new DigitalCounter(); // digit reference variable has strong reference - line 3
PhantomReference<DigitalCounter> phantom = new PhantomReference<DigitalCounter>(digit); // phantom reference to object created at line 3

digit = null;
```

[к оглавлению](#Garbage-Collection)

## 10. Чем они отличаются?

https://habr.com/ru/articles/549176/

https://habr.com/ru/articles/169883/

Сначала общее правило: политика зачистки для некоего объекта и очистки ссылок на него определяется самыми жёсткими из 
всех ссылок, что на него указывают.

Различие между всеми типами ссылок только одно — поведение GC с объектами, на которые они ссылаются:

+ **StrongReference** нужны для указания на объекты, которые должны обязательно оставаться в памяти всё то время, 
что эти ссылки на него существуют. Объект будет уничтожен только в том случае, если мы явно назначим ссылке `null`, 
либо потеряем доступ к ссылке через класс родитель (например класс родитель обнулится и объект также обнулиться. 
Обнулится, т.е. его будет обрабатывать GC и высвобождать память из этого объекта)

+ **WeakReference** — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.

Пример использования: `WeakHashMap` - это реализация которая хранит ключ, используя weak-ссылку. 
Когда сильная ссылка на фактический объект удалена и затем GC удаляет ключ из памяти, то удаляется вся запись из Map: 
при добавлении новой пары <ключ, значение>, создается WeakReference для ключа и в конструктор передается ReferenceQueue. 
Когда GC удаляет ключ с памяти, то ReferenceQueue возвращает соответствующий WeakReference для этого ключа. 
После этого соответствующий Entry удаляется с Map. 

`WeakHashMap` не предназначена для использования в качестве кэша. WeakReference создается для ключа, а не для значения. 
И данные будут удалены только после того, как в программе не останется strong-ссылок на ключ, а не на значение. 
В большинстве случаев это не то, чего вы хотите достичь кэшированием.
Данные с `WeakHashMap` будут удалены не сразу после того как GC обнаружит, что ключ доступен только через weak-ссылки. 
Фактически очистка произойдет при следующем обращении к `WeakHashMap`.
В первую очередь `WeakHashMap` предназначен для использования с ключами, у которых метод `equals` проверяет идентичность 
объектов (использует оператор `==`). Как только доступ к ключу потерян, его уже нельзя создать заново.

+ **SoftReference** — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти 
только в случае необходимости. По сути SoftReference - это механизм кэширования объектов в памяти, но в критической 
ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует 
спасти JVM от завершения работы.

Общий контракт звучит следующим образом: GC гарантировано удалит из кучи все объекты, доступные только по soft-ссылке, 
перед тем как бросит `OutOfMemoryError`. 

Например, если нужно насоздавать ещё объектов с сильными ссылками, а уже негде, лучше освободить кэш и 
замедлить работу, чем уронить процесс напрочь.

*Основная разница между SoftReference и WeakReference, в том, что SoftReference являются более подходящим для кэшей, а 
WeakReference для хранения метаданных.*

+ **PhantomReference** — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти, 
когда это ему "понравится" (зависит от реализации GC, возможно после нескольких запусков)

[к оглавлению](#Garbage-Collection)

## 11. Расскажите про String pool и Integer pool (Integer cache)

**String pool**

Для создания строк в Java существует класс String. Строки являются самыми частоиспользуемыми объектами в Java. Среди множества строк часто встречаются их дубликаты, поэтому в Java существуют механизмы, оптимизирующие память, которую занимают строки и числа - String pool и Integer pool.

Созданные строки являются неизменяемыми (immutable) объектами. Данное свойство позволяет организовать пул строк (String pool). Пула строк оптимизирует память путем хранения исключительно уникальных строк.

Пул строк  - это специальная область памяти в куче (heap), куда сохраняются только уникальные значения строк. 

Строка, созданная с помощью конструктора через ключевое слово new, будет создана непосредственно в heap, как и любой другой объект. При таком способе создания строк дубликаты значений никак учитываться не будут, и каждое повторное значение будет отдельным объектом со своим выделенным местом в памяти и ссылкой.

**Когда строки попадают в String pool**. Процесс помещения строки в пул строк называется интернированием.:

- Присвоить строке строковый литерал в двойных кавычках.

```java
String string1 = "Hello";
```

- В результате конкатенации литералов

```java
String string1 = "Hello, world"; 
String string2 = "Hello, " + "world";  
System.out.println(string1 == string2); \\true
```

- метод ***intern*** гарантирует, что возвращенная ссылка будет указывать на объект, находящийся в пуле строк

```java
String string1 = "Hello"; 
String string2 = new String("Hello");  
String string3 = string2.intern(); 
System.out.println(string1 == string3);
```

**Когда строки не попадут в String pool**

- C помощью конструктора, передав в него строковый литерал.

```java
String str = new String("Hello");
```

- C помощью конструктора, передав в него массив символов

```java
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String str = new String(chars);
```

`Важно! Интернирование в пул строк происходит только на этапе компиляции. Все строковые литералы, с помощью которых мы создаем новые строки в примере выше, известны нам на этапе компиляции.`

Сравнение ссылок полученной в результате конкатенации целой строки string3 и идентичной ей по значению string1 вернет false, потому что вычисление string3 будет происходить только во время выполнения программы, а результирующая строка string3 будет **создана в куче**.

```java
String string1 = "Hello, world"; 
String string2 = "Hello, "; 
String string3 = string2 + "world";  
System.out.println(string1 == string3)
```

**Integer pool**

Также в Java существует аналогичный пул для хранения объектов Integer. Также называется Integer cache. В нем хранятся числа от -128 до 127 включительно, то есть пул Integer хранит все числа, которые помещаются в тип byte. Суть пула Integer в оптимизации, также как и пула строк. Когда мы создаем объекты Integer, то все объекты, входящие в указанный диапазон, будут взяты из пула Integer. Благодаря пулу Integer системе не придется создавать новые объекты, так как они уже есть в пуле. Этого диапазона чисел достаточно для оптимизации большинства вычислений.

```java
Integer pool1 = 127; 
Integer pool2 = 127; 
System.out.println(pool1 == pool2); 
Integer heap1 = -129;
Integer heap2 = -129;
System.out.println(heap1 == heap2); 
```

В данном примере число 127 входит в диапазон [-128;127], поэтому переменные pool1 и pool2 ссылаются на один и тот же объект, который хранится в пуле Integer. А число -129 выходит за рамки этого диапазона, поэтому переменные heap1 и heap2 ссылаются на разные объекты, созданные в куче. В результате сравнение pool1 и pool2 возвращает true, а сравнение heap1 и heap2 возвращает false. 

[к оглавлению](#Garbage-Collection)

## 12. Расскажите о методе String.intern()

**Метод intern()**

Данный метод гарантирует, что возвращенная ссылка будет указывать на объект, находящийся в пуле строк.

```java
String string1 = "Hello"; 
String string2 = new String("Hello");  
String string3 = string2.intern(); 
System.out.println(string1 == string3);
```

Данный метод используется очень редко и применяется в ситуациях, когда нужно очень много раз сравнивать одни и те же строки. Мы всегда используем метод equals() для сравнения объектов на содержание идентичных данных - equals() посимвольно сравнивает данные. С помощью метода intern() можно немного повысить производительность, так как этот метод гарантирует, что строка будет взята из пула строк, в котором она хранится в единственном экземпляре (уникальна). Поэтому при необходимости многократного сравнения одних и тех же строк можно получить преимущество в производительности за счет использования оператора сравнения идентичности '==' (сравнивает ссылки) вместо equals (сравнивает данные объектов посимвольно), так как метод intern() будет гарантировать, что сравниваемые ссылки интернированных строк будут вести на один и тот же объект, хранящийся в пуле строк.

Что касается занимаемой строками памяти, то интернированные в пул строки будут удалены сборщиком мусора после того, как на эти строки не останется живых ссылок.

Метод intern() используется для оптимизации памяти. Например, если мы с базы данных загружаем справочники, а они имеют одинаковые значения, то можно весь справочник провести через intern() - это сократит память.

[к оглавлению](#Garbage-Collection)

## 13. Расскажите, что такое профайлер

**v1**

Профилировщик (profiler) - это специальная программа, с помощью которой можно оценить где, при выполнении каких операций и в каком количестве потребляются ресурсы при работе нашего приложения. Профилировщик отслеживает конструкции и операции байт-кода на уровне виртуальной машины Java. Сюда входят создание объекта, выполнение методов, состояние нитей, сборка мусора и т.д. Также с помощью профайлера можно отслеживать производительность и загрузку ЦП и использование памяти приложением. Состояние нитей и упоминание нитей в этом уроке относится к многопоточности. Многопоточность мы будем проходить в уровне Мидл. Сейчас достаточно только знать, что многопоточность - это работа приложения одновременно в нескольких нитях выполнения. Глубже сейчас в это вдаваться не нужно.

С помощью профилировщиков производится профилирование. Профилирование - это сбор и анализ данных приложения во время ее выполнения для выявления "горячих точек" и узких мест в программе.

Горячие точки - это высокая трата ресурсов - сильная загрузка ЦП или расход памяти.

Узкие места - части кода, где приложение замедляется. Например, доступ к БД.

С помощью профилировщика можно отследить где тратится память, сколько ее тратится и сколько времени это занимает в программе.

**v2**

Профилирование - это сбор и анализ характеристик работы приложения.

Проще говоря, запускаем приложение, "подключаемся" к нему, в реальном времени смотрим как оно работает, делаем выводы. Далее предпринимаем меры.

Профайлер – программа, которая осуществляет эти действия. (jmap, jconsole)

**v3**

Java профайлер — это инструмент, который позволяет анализировать производительность Java-приложений. Он позволяет идентифицировать узкие места в коде и оптимизировать производительность приложения. В данной статье мы рассмотрим, что такое Java профайлер, зачем он нужен и как им пользоваться.

Что такое Java профайлер?

Java профайлер — это программное обеспечение, которое используется для анализа производительности Java-приложений. Он позволяет определить, сколько времени занимает выполнение каждой строки кода, вызовов методов и других операций в приложении. Эта информация может быть использована для улучшения производительности и оптимизации кода.

Java профайлеры работают, измеряя время, которое занимает выполнение каждого метода и каждой строки кода в приложении. Они могут также отображать, какие методы вызывают другие методы, и сколько времени заняло выполнение каждого вызова. Эта информация может быть полезна для идентификации мест, которые занимают больше всего времени, и оптимизации кода для ускорения работы приложения.

Зачем нужен Java профайлер?

Java профайлеры могут использоваться для различных целей:

1. Идентификация узких мест в приложении. Java профайлеры позволяют идентифицировать узкие места в приложении, которые могут быть причиной замедления его работы. Это позволяет разработчикам сосредоточиться на оптимизации кода и ускорении работы приложения.

2. Оптимизация производительности приложения. Используя информацию, полученную от Java профайлера, разработчики могут оптимизировать код приложения, чтобы ускорить его работу. Оптимизация может включать в себя рефакторинг кода, изменение алгоритмов и применение оптимизаций, которые могут ускорить работу приложения.

3. Валидация производительности приложения. Java профайлеры могут использоваться для проверки производительности приложения в разных условиях. Например, профайлер может показать, как изменится производительность приложения при различных нагрузках и конфигурациях.

[к оглавлению](#Garbage-Collection)

## 14. Расскажите, как использовать VisualVM

https://job4j.ru/profile/exercise/60/task-view/1014

Java Visual VM - это инструмент, который предоставляет визуальный интерфейс для просмотра приложений на основе технологии Java (приложений Java), работающих на виртуальной машине Java (JVM). С его помощью можно анализировать производительность приложения, загрузку ЦП и памяти, снимать дампы памяти, а также хорошим преимуществом является возможность подключения плагинов для более гибкого профилирования.

В Java Visual VM поддерживается локальное и удаленное профилирование. Профилировать можно в реальном времени, а также сохранять периодические снимки сеанса профилирования (snapshot) с целью их последующего анализа.

**Вкладка Overview.**

Здесь отображается общая информация о системных параметрах, параметрах JVM, некоторые параметры приложения и тд.

![image](https://github.com/artemaverin/summary/assets/97846877/833bf74c-094f-4ba4-9d56-28c41714bd29)


**Вкладка Monitor.**

В данной вкладке показывается загрузка ЦП и памяти, количество и состояние нитей, и количество загруженных классов.

В окне CPU показывается загрузка ЦП онлайн. В окне Heap показывается загрузка памяти онлайн. Здесь же видна и ее очистка, когда это делает сборщик мусора (линия на графике идет вниз).

![image](https://github.com/artemaverin/summary/assets/97846877/9cbe5ae3-f68a-426e-ae52-ab3b92ad6bcc)

**Вкладка Threads**

В этой вкладке можно следить за состоянием нитей. Цвет обозначает состояние, в котором находится нить. Пока полоса идет по графику - нить жива. На картинке ниже верхняя нить уже закончила работу, вторая нить недавно завершила работу, и место окончания ее работы тоже видно на графике. 

![image](https://github.com/artemaverin/summary/assets/97846877/b8800e38-a9e5-44e4-802a-1f9b59fea6df)

**Вкладка Sampler**

В этой вкладке можно отслеживать время выполнения методов процессором и загрузку памяти.

Здесь производится сэмплинг. Сэмплинг - это выборка. Запуск выборки работы процесса осуществляется нажатием на кнопку CPU. Сохранить данные можно кнопкой Snapshot. Выборка по загрузке памяти делается аналогично - нажать кнопку Memory, а после сохранить кнопкой Snapshot. Сохраненные снимки (Snapshot) можно отдельно проанализировать в дальнейшем.

CPU:

![image](https://github.com/artemaverin/summary/assets/97846877/8b8de6ad-1262-4421-9156-1a9ed0c0e384)

Memory:

![image](https://github.com/artemaverin/summary/assets/97846877/f2aee79b-2a4e-48ad-a632-29d4ce7a01b8)

**Вкладка Profiler**

В этой вкладке можно делать более точное профилирование с помощью инструментирования. Инструментирование - это добавление байт-кодов в уже существующий байт-код для сбора дополнительной информации о работе методов и т.д. Похож на режим Sampling, но имеет возможность детальной настройки профилирования элементов приложения с помощью предоставленных Java инструментов.

![image](https://github.com/artemaverin/summary/assets/97846877/a6740802-05f0-4112-9bc9-f01343592318)

**Дампы**

- Дамп кучи (Heap Dump) - это мгновенный снимок (snapshot) всех Java-объектов в приложении на текущий момент. Дампы помогают в анализе проблем, связанных с памятью. Например, частая сборка мусора или переполнение памяти.

Дамп кучи помогает узнать, сколько объектов создано, какого они типа, размера, живые или нет. То есть найти причины, например, какими объектами забилась память при ее переполнении и тд. 

Создать дамп кучи можно на вкладке Monitor, нажав кнопку Heap Dump:

![image](https://github.com/artemaverin/summary/assets/97846877/226a9073-33f7-449d-bbdd-e6b510652da1)

Дамп нитей (Thread Dump).

С помощью дампа нитей можно узнать активность нитей приложения. Дамп делает мгновенный снимок всех нитей в приложении, что позволяет при последующем анализе узнать в каком состоянии была та или иная нить, заблокирована она или нет и т.д. Собрать дамп нитей можно нажав кнопку Thread Dump в разделе Threads:

![image](https://github.com/artemaverin/summary/assets/97846877/c6c9f3ca-74d8-4001-b0ee-975995cbf3f3)

[к оглавлению](#Garbage-Collection)

## 15. Расскажите, чем отличается sampling от profiling?

Profiling это единоразовый снимок состояния в памяти на момент запуска профайлера.

Sampling это периодическое обновление состояния в памяти, что позволяет наблюдать динамику использования памяти работающим приложением.

Sampling и Profiling - это два разных типа техник сбора данных в программировании и разработке.

**Sampling** (выборка): Это процесс сбора данных, когда система или приложение работает в реальном времени. Sampling обычно используется для мониторинга и анализа производительности системы. Он основан на выборке случайных точек во время выполнения программы, чтобы собрать информацию о состоянии системы. Этот метод менее ресурсоемкий, но может привести к потере данных и неточностям, особенно если выборка нерепрезентативна.

**Profiling** (профилирование): Это продвинутый метод сбора данных, который включает в себя глубокий анализ производительности и поведения системы. Profiling позволяет получить подробную информацию о времени выполнения кода, используемых ресурсах, загрузке процессора и т.д. Он позволяет определить “горячие точки” или участки кода, которые занимают больше всего времени на выполнение. Profiling обычно требует остановки приложения или запуска специального инструмента, который будет собирать данные. Этот метод более ресурсоемкий и может повлиять на производительность системы, но он обеспечивает более точные и детальные данные, чем sampling.

[к оглавлению](#Garbage-Collection)

## 16. Расскажите о методе finalize()

https://habr.com/ru/articles/183344/

https://habr.com/ru/articles/130370/

В классе Object есть метод finalize(). Этот метод вызывается перед тем как объект уничтожется, однако этот метод является устаревшим и не рекомендуется его использовать. 

Finalize() - это метод, определенный в Java, который используется для выполнения очистки ресурсов или завершения задач перед сборкой мусора. Он вызывается автоматически, когда объект становится неиспользуемым и готовым к сборке мусора.

Обычно finalize() используется для освобождения ресурсов, таких как закрытие подключений к базе данных, освобождение файлов или освобождение сетевых соединений. Важно помнить, что использование finalize() не гарантирует, что эти ресурсы будут обязательно освобождены, так как JVM может отложить вызов этого метода до тех пор, пока не соберет достаточно мусора.

При использовании finalize() нужно быть осторожным, так как этот метод может вызвать проблемы с производительностью и может привести к утечке ресурсов. Вместо finalize() рекомендуется использовать более явные механизмы освобождения ресурсов, такие как try-with-resources для автоматического закрытия ресурсов или использование шаблонов проектирования, таких как Builder или Factory для управления ресурсами.

В Java 7 и более поздних версиях рекомендуется использовать метод ReferenceQueue.poll(), который позволяет более гибко управлять освобождением ресурсов и предоставляет более точные гарантии освобождения ресурсов.
- ----------------

Метод находится в классе Object, поэтому наследуется всеми классами.

Вызывается сборщиком мусора для объекта, когда сборщик мусора определяет, что больше нет ссылок на объект. Подкласс переопределяет метод finalize, чтобы избавиться от системных ресурсов или выполнить другую очистку.

Общий контракт finalize заключается в том, что он вызывается, если и когда виртуальная машина Java определила, что больше нет никаких средств, с помощью которых этот объект может быть доступен любому потоку, который еще не умер, кроме как в результате предпринятого действия. финализацией какого-либо другого объекта или класса, который готов к финализации. Метод finalize может выполнять любые действия, в том числе снова делать этот объект доступным для других потоков; обычная цель finalize, однако, состоит в том, чтобы выполнить действия по очистке перед тем, как объект будет безвозвратно отброшен. Например, метод finalize для объекта, представляющего соединение ввода-вывода, может выполнять явные транзакции ввода-вывода, чтобы разорвать соединение до того, как объект будет окончательно удален.

Метод finalize класса Object не выполняет никаких специальных действий; он просто возвращается нормально. Подклассы Object могут переопределить это определение.

Язык программирования Java не гарантирует, какой поток вызовет метод finalize для любого заданного объекта. Однако гарантируется, что поток, вызывающий finalize, не будет удерживать никаких видимых пользователю блокировок синхронизации при вызове finalize. Если методом finalize выдается неперехваченное исключение, оно игнорируется, и завершение этого объекта завершается.

После вызова метода finalize для объекта никакие дальнейшие действия не предпринимаются до тех пор, пока виртуальная машина Java снова не определит, что больше нет средств, с помощью которых этот объект может быть доступен для любого потока, который еще не умер, включая возможные действия. другими объектами или классами, которые готовы к завершению, после чего объект может быть отброшен.

Метод finalize никогда не вызывается виртуальной машиной Java более одного раза для любого заданного объекта.

Любое исключение, созданное методом finalize, приводит к остановке финализации этого объекта, но в противном случае игнорируется.

Механизм финализации по своей сути проблематичен. Завершение может привести к проблемам с производительностью, взаимоблокировкам и зависаниям. Ошибки в финализаторах могут привести к утечке ресурсов; нет возможности отменить финализацию, если в ней больше нет необходимости; и не указан порядок среди вызовов финализации методов разных объектов. Кроме того, нет никаких гарантий относительно сроков завершения. Метод finalize может быть вызван для финализируемого объекта только после неопределенной задержки, если вообще будет вызван. Классы, экземпляры которых содержат ресурсы, не относящиеся к куче, должны предоставлять метод для включения явного освобождения этих ресурсов, а также должны реализовывать AutoCloseable, если это необходимо. Cleaner и PhantomReference предоставляют более гибкие и эффективные способы высвобождения ресурсов, когда объект становится недоступным.

[к оглавлению](#Garbage-Collection)

## 17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

https://job4j.ru/profile/exercise/196/task-view/1013

https://habr.com/ru/articles/138594/

**Поверхностное копирование (Shallow copy).**

Если нам нужно создать копию объекта, можно использовать метод clone() класса Object. Для реализации копирования с помощью clone() класс, копию которого нужно сделать, должен реализовывать интерфейс Cloneable. Данный интерфейс не содержит никаких методов. Это маркер, сигнализирующий системе о том, что этот класс можно клонировать. 

```java
package ru.job4j.clone;

public class TestObject implements Cloneable {
    int num;

    @Override
    protected TestObject clone() throws CloneNotSupportedException {
        return (TestObject) super.clone();
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        TestObject testObj1 = new TestObject();
        testObj1.num = 5;
        TestObject testObj2 = testObj1.clone();
        testObj2.num = 10;
        System.out.println(testObj1.num);
        System.out.println(testObj2.num);
    }
}
```

Сделаем класс TestObject клонируемым - реализуем его от интерфейса Cloneable и переопределим в нём метод clone():

Метод clone() можно переопределить только вместе с реализацией интерфейса Cloneable, иначе при попытке клонировать объект этого класса будет выброшено исключение CloneNotSupportedException.

происходит копирование объекта, на который ссылается testObj1. Метод clone() создает новый объект в памяти, идентичный копируемому объекту. Теперь ссылки testObj1 и testObj2 ведут на разные объекты в памяти. То есть мы сделали копию объекта.

**Глубокое копирование (Deep copy)**

В предыдущем примере мы копировали класс, поля которого содержали только примитивные значения. При поверхностном копировании такого класса будет создан полностью уникальный объект. Если же в копируемом классе присутствуют поля, которые хранят ссылки на объекты, то в новый объект будут скопированы только сами ссылки на эти объекты, поэтому копирование с помощью метода clone() называется *поверхностным копированием*.

На картинке ниже демонстрируется, что ссылки из оригинального и скопированного классов ссылаются на один и тот же объект в памяти, то есть при изменении объекта Object, эти изменения будут видны в обоих объектах:

![image](https://github.com/artemaverin/summary/assets/97846877/6178a3af-e631-448a-a18c-5ff4d6caf6c3)

Для того, чтобы корректно скопировать объект полностью при наличии в нем полей, хранящих ссылочные типы данных, нужно применить глубокое копирование (Deep copy). Глубокое копирование создает клон, полностью независимый от исходного объекта, то есть изменения в скопированном объекте не повлияют на исходный объект.

При глубоком копировании нужно выполнить следующие условия:

- Поля, хранящие примитивные типы данные, не нуждаются в отдельном копировании.

- Каждый класс-член исходного класса должен поддерживать клонирование (реализовывать Cloneable и переопределять clone()).

- Если член класса не поддерживает клонирование, то в методе клонирования создается новый экземпляр этого класса, куда копируется каждый член исходного класса со всеми атрибутами, и этот объект устанавливается в поле этого члена класса, куда его нужно скопировать.

**Конструктор копирования**

Также сделать копию объекта можно с помощью конструктора копирования. В конструктор передается объект этого же класса, а поля нового объекта инициализируются значениями полей переданного объекта.
- ---------

Цель этого метода – клонировать объект – т.е. создать его клон/копию/дубликат.

Дело в том, что Java-машина не знает, какие объекты можно клонировать, а какие нет. Файлы, например, клонировать нельзя. Как и поток System.in.

Поэтому вопрос о полноценном клонировании был отдан на откуп разработчикам классов. Тут все было сделано по аналогии с методом equals. Даже есть свой аналог hashCode – это интерфейс Cloneable.

Интерфейс Cloneable – это так называемый интерфейс-маркер, который не содержит никаких методов. Он используется, чтобы маркировать (помечать) некоторые классы.

Если разработчик класса считает, что объекты класса можно клонировать, он помечает класс этим интерфейсом (наследует класс от Cloneable).

Если разработчика не устраивает стандартная реализация метода clone, он должен написать свою, которая будет создавать дубликат объекта правильным образом.

При вызове метода clone(), Java проверяет, был ли у объекта интерфейс Cloneable. Если да — клонирует объект методом clone(), если нет — выкидывает исключение CloneNotSupportedException.

Если ты хочешь воспользоваться «клонированием по умолчанию», которое реализовано в классе Object, тебе нужно:

а) Добавить интерфейс Cloneable своему классу

б) Переопределить метод clone и вызвать в нем базовую реализацию

[к оглавлению](#Garbage-Collection)

## 18. Расскажите о Stack, Heap и Metaspace

https://job4j.ru/profile/exercise/58/task-view/1012

![image](https://github.com/artemaverin/summary/assets/97846877/ddb854d9-1fce-4f84-bb55-9ba9d3936734)

Стек (stack) и куча (heap) - это основные области памяти в Java. При вызове методов, создании объектов или объявлении переменных виртуальная машина Java выделяет память в одной из этих областей памяти под эти операции. 

Стек хранит значения примитивных типов, которые создаются в методах, и ссылки на объекты в heap, на которые ссылаются методы. А в heap хранятся сами объекты, под которые динамически выделяется память во время выполнения программы. Скорость обращения к стеку выше, чем скорость обращения к heap.  Более подробно heap мы рассмотрим в следующем уроке.

Область памяти стек по-другому называется стек вызовов. Когда в программе вызывается метод, JVM выделяет память в стеке для вызова этого метода. В этой памяти будут храниться значения примитивных типов и ссылки на объекты в куче. Стек организован по принципу LIFO - Last In First Out (Последним пришел, первым вышел). То есть принцип работы как у стопки тарелок. Чтобы вытащить нижнюю тарелку, нужно по одной снимать тарелки сверху. Вместо тарелок в стеке хранится цепочка вызовов методов. При вызове каждого метода, содержащего примитивные типы или ссылки на объекты, в стеке выделяется память, которая хранит эти переменные и ссылки этого метода. Данные, хранящиеся в этой области памяти, имеют область видимости, которая ограничена телом метода, под который данная часть памяти выделена. Когда в программе выполняется какой-либо метод, компилятор может получить доступ к переменным только этого метода. (К статическим переменным доступ есть из любого места программы). При выполнении цепочки методов в момент передачи управления вызываемому методу программа запоминает состояние выполнения текущего метода, создает новую область памяти в стеке под вызываемый метод, создает там переменные и ссылки вызываемого метода, и передаёт ему управление. Если в вызываемом методе придется вызывать еще один метод, то эта цепочка действий повторяется. 

Из-за малого количества данных, которое хранится в стеке, этот раздел имеет очень небольшой размер, поэтому если произойдет вызов очень большого количества методов, то стек переполнится и выбросит исключение java.lang.StackOverflowError. Куча же обладает очень большой памятью относительно стека (ограничена только технической частью компьютера), но тоже может переполниться, в результате чего будет выброшено исключение java.lang.OutOfMemoryError.

Metaspace (с JDK 8)

Это отдельная область памяти, выделенная под хранение статической информации приложения. Например, метаданные загруженных классов. Metaspace автоматически расширяется при заполнении. Эта область так же доступна для сборщика мусора, как и heap (сборщик мусора мы будем проходить в следующем уроке). Сборщик удаляет ненужные классы из памяти, когда область для хранения метаданных заполнена.

До JDK 8 функции Metaspace выполнял PermGen (PermanentGeneration), который был отдельной областью памяти в составе heap. PermGen имел трудности со своевременной очисткой его пространства от неиспользуемых объектов и часто являлся источником утечки памяти, поэтому в JDK 8 был заменен на улучшенный аналог - Metaspace.

- ----------------------

PermGen. MetaSpace.
Зона ответственности PermGen — хранение объектов типа Class. До Java 8 он имел фиксированный размер, который можно было изменить через настройки JVM.

Основная проблема PermGen — он не расширяем динамически. Поэтому в Java 8 (и последующих версиях) он был заменен на MetaSpace. Основное отличие как раз в том, что MetaSpace расширяется автоматически, по мере необходимости. В настройках JVM можно ограничить его максимальный размер.

Очистка мусора происходит при полном заполнении (у PermGen) или перед динамическим расширением (у MetaSpace).



Heap (куча)
Самая большая область памяти в Java. Именно в ней хранятся объекты, создаваемые в программе. И именно на эту область памяти направлен, в первую очередь, сборщик мусора (GC) — его задачей является удаление объектов, на которые в программе не осталось активных ссылок. Размер хипа (сленговое название от англ. heap) также можно указать в настройках JVM.

Хип делится, в свою очередь, на несколько частей, актуальность такого разделения мы разберем в рамках знакомства с Garbage Collector.

Куча разбита на несколько разделов. 

Первый из них — New (он же Young) Generation. Он делится на два пространства:

Eden Space – сюда помещаются все созданные объекты. Когда eden space заполняется, GC запускает быструю сборку мусора, затрагивающую только эту область. Объекты, которые не были удалены, помещаются в Survivor Space;
Survivor Space – сюда помещаются объекты из eden space, пережившие быструю сборку мусора. Survivor Space, в свою очередь, делится на S0 и S1. Подробнее об этом поговорим в теме GC.
Кроме New Generation существует, неожиданно, и Old Generation. Здесь скапливаются объекты, которые пережили несколько сборок мусора (напомню, мусор — объекты, на которые не осталось ссылок). Если Old Generation оказывается полностью заполненным, сборщик мусора начинает достаточно дорогой процесс полной сборки мусора, которая затрагивает все области кучи. Если даже после этого память в куче не освободилась — возникает знакомый нам по теме исключений OutOfMemoryError. Как правило, Old Generation занимает 2/3 памяти heap-а.

Для тех, кто знаком со структурами данных и не только: объекты в хипе хранятся в структуре «полное бинарное дерево». Эта информация не имеет практического применения, но позволяет избавиться от картинки, которую мозг рисует для слова «куча».

Кроме озвученных разделов, в heap существует отдельная область памяти для пула строк (String pool). С ним мы познакомимся подробнее в одном из ближайших уроков. Вкратце, он нужен для оптимизации работы со строками, обеспечивая переиспользуемость строковых литералов. Иными словами, именно он позволяет не создавать новый объект строки, если строка с таким значением уже существует, а использовать старый. Это возможно благодаря тому, что String — immutable.

До Java 7 пул строк находился в PermGen, что приводило к проблемам со сборкой мусора, ведь строка, в целом, менее долгоживущий объект, чем объекты Class. Поэтому в дальнейшем String Pool был перенесен в Heap.

Последней областью памяти с хипе, с которой мы познакомимся, будет Method Area. Method Area – это область кучи, которая создается при старте JVM. Она выделяется для классов, методов, интерфейсов, иными словами, хранит кодовую базу приложения в скомпилированном виде.



Stack(Стек) и то, что рядом
Прежде чем начнем знакомство со стеком, нужно отметить, что PermGen/MetaSpace и Heap — одни на приложение. А вот стеков в приложении может быть много — по одному на каждый поток (thread). При знакомстве с многопоточностью станет немного понятнее, в чем принципиальная разница.

Итак, stack — область памяти, которая создается для каждого потока, в ней хранятся значения примитивов и ссылки на объекты. Как только метод завершает работу, стек освобождается для следующего метода. Размер стека можно настроить в JVM.

Стек использует (кто бы мог подумать) структуру данных стек. Она (структура данных) работает по принципу LIFO — last in, first out (последним вошел — первым вышел). Подробнее с этой структурой данных, как и рядом других, мы познакомимся позже. Переполнение памяти в стеке приведет к ошибке StackOverflowError.

Кроме стека, есть еще 2 области памяти, которые также создаются для каждого потока. Не страшно, если вы не запомните это в полном объеме, просто держите в голове, что они есть. Сейчас нам эта информация необходима, чтобы лучше понимать, откуда берутся данные, которые загружает в себя стек.

Стек Native Method — стек нативных методов — используется для методов, помеченных ключевым словом native. Мы не можем работать с ними так же, как с обычными методами, поскольку не имеем доступа к их переменным — нативные методы реализованы на языках, отличных от Java. Соответственно, необходим механизм, который будет обеспечивать их вызов и обработку. Именно для этого и нужен стек нативных методов.

Program Counter Register (pcRegister) — в один момент времени один конкретный поток может выполнять лишь одну инструкцию (метод, оператор). pcRegister хранит адрес этой инструкции в памяти. Переменные (примитивы, ссылки на объекты) этой инструкции будут храниться в стеке. 

Если метод, выполняемый в данный момент времени, нативный — pcRegister будет пустым, адрес этого метода будет храниться в стеке нативных методов.

[к оглавлению](#Garbage-Collection)

## 19. Что такое ClassLoader? Перечислите основные реализации ClassLoader

https://job4j.ru/profile/exercise/196/task-view/1053

https://habr.com/ru/articles/103830/

https://habr.com/ru/companies/otus/articles/468193/

JVM читает команды в виде байт-кода из class-файлов (или других ресурсов) и передаёт их процессору в виде инструкций. Скомпилированный байт-код загружает в JVM загрузчик классов. 

Загрузка классов - это динамические поиск и загрузка классов или интерфейсов в рантайме.

**Виды загрузчиков.**

Вернемся к загрузке класса. Как уже говорилось в начале урока, загрузчик классов загружает в JVM скомпилированный байт-код из class-файлов (или других ресурсов).


В Java есть 3 штатных загрузчика. Каждый из них загружает классы из определённого места. Далее перечислены загрузчики, которые были до Java 9:

-  Bootstrap class loader - базовый загрузчик, загружает базовые классы из архива rt.jar. В данном архиве находятся все ресурсы, необходимые для работы программ в Java - все классы из Core Java API. Данный загрузчик реализован в самой JVM и обратная связь с исполняющей средой у него отсутствует.

- Extension class loader - загрузчик расширений, загружает классы расширений из директории jre/lib/ext. 

- System class loader - системный загрузчик классов, загружает классы из переменной окружения CLASSPATH. Является стандартным загрузчиком классов в приложении (Он же Application class loader).

- Обособленно можно отметить ещё одну реализацию ClassLoader - UrlClassLoader. Данный загрузчик позволяет загружать классы и ресурсы по URL-ссылке.


Обновления, которые произошли в загрузчиках классов в Java 9:

- Extension class loader преобразован в Platform class loader. Extension class loader применялся только для загрузки дополнений к jdk и использовался мало. Начиная с Java 9 Platform class loader выполняет те же функции, что и Extension class loader, но ему добавли некоторые не очень важные функции, которые раньше выполнял Bootstrap class loader, тем самым отбалансировав нагрузку на загрузчики.

- Application class loader являлся экземпляром UrlClassLoader. Начиная с Java 9 Application class loader создаётся в виде экземпляра некоего внутреннего класса.

Если приложение не использует знания, описанные в этих изменениях, то на пользователя эти изменения никак не повлияют.

[к оглавлению](#Garbage-Collection)

## 20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?

Модель делегирования нагрузки представлена в виде иерархии. Загрузчики классов составляют иерархию, где корнем является базовый загрузчик Bootstrap, далее идет его наследник - загрузчик расширений Extension (Platform с Java 9), далее наследник Extension/Platform - системный загрузчик System (Application). Каждый загрузчик хранит информацию о своём предке (у базового загрузчика предка нет, он корневой).  

Представим эту иерархию на схеме, чтобы лучше понять как она устроена:

![image](https://github.com/artemaverin/summary/assets/97846877/32ff3878-ac9f-4cd6-a473-d2586dedd3c2)


[к оглавлению](#Garbage-Collection)

## 21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?

Узнать с помощью какого загрузчика был загружен класс можно с помощью метода getClassLoader().

```java
package ru.job4j;

public class Loader {

    public static void main(String[] args) throws ClassNotFoundException {
        Class loader = Loader.class;
        System.out.println("Класс переменной loader: " + loader);
        System.out.println("Загрузчик класса переменной loader:  " + loader.getClassLoader());
    }

}
```
![image](https://github.com/artemaverin/summary/assets/97846877/4bc46f20-8ffa-470a-be26-965115a0e320)

AppClassLoader здесь - это реализация абстрактного класса ClassLoader. *AppClassLoader является системным загрузчиком классов. Все или практически все классы, которые вы пишете в приложениях, будут загружены именно им. 

Реализацией загрузчика расширений является *ExtClassLoader (или Platform class loader с Java 9)

А вот реализация базового загрузчика содержится в самой JVM, поэтому мы не можем её получить. При попытке получения загрузчика класса, который был загружен базовым загрузчиком, мы получим null:

```java
Class string = String.class;
System.out.println("Класс переменной loader: " + string);
System.out.println("Загрузчик класса переменной string:  " + string.getClassLoader());
```
![image](https://github.com/artemaverin/summary/assets/97846877/47e47f73-21c2-499e-8fa4-db1d7b520f22)

Базовым загрузчиком загружаются все базовые классы java.*.

Все загрузчики являются наследниками абстрактного класса ClassLoader, кроме базового, так как он реализован внутри JVM. Тем самым получается, что фактическую загрузку классов производит не сам ClassLoader, а его классы-реализации, о которых мы говорили выше. Также возможно создать пользовательский загрузчик классов, унаследовав его от абстрактного класса ClassLoader. 

Также подсистема загрузчика классов подразумевает не только загрузку классов, но и поиск ресурса, откуда будет загружаться байт-код, а также выполняет этапы загрузки классов, о которых было рассказано выше.

Схема подсистемы загрузчиков классов:

![image](https://github.com/artemaverin/summary/assets/97846877/68cac5ac-0e1e-4cde-847b-d6a93a9f89d2)


[к оглавлению](#Garbage-Collection)

## 22. Расскажите алгоритм поиска и загрузки класса в JVM.

https://job4j.ru/profile/exercise/196/task-view/1053

**Этапы загрузки классов.**

Прежде, чем мы перейдем к рассмотрению самих загрузчиков классов, вкратце пройдёмся по этапам, которые происходят при загрузке байт-кода в JVM. Для корректной работы загруженного в JVM кода процесс загрузки проходит 3 этапа:

1) Загрузка байт-кода из class-файлов. Байт-код также может быть загружен, например, из сети или взят из другого ресурса. Также он может быть сгенерирован самим приложением.

На этом этапе выполняются следующие действия:

- Поиск запрошенного класса среди ранее загруженных классов

- Получение и проверка байт-кода запрошенного класса

- Создание экземпляра класса запрошенного класса 

- Загрузка классов-родителей. Запрошенный класс не будет считаться загруженным, если еще не загружены его классы-родители или интерфейсы.

2) Линковка (связывание)

Этот этап имеет 3 подэтапа:

- Верификация (Verification) - проверяет байт-код на корректность импортируемого типа.

- Подготовка (Preparation) - выделяется память по статические переменные. На этом подэтапе все переменные инициализируются либо значением по умолчанию, либо явно заданными значениями.

- Разрешение (Resolution) - здесь происходит преобразование полей, методов и символьных ссылок типов в прямые ссылки. Разрешение - это процесс динамического определения значений из символических ссылок в пуле констант рантайма. 

3) Инициализация 

Инициализация класса или интерфейса происходит путем выполнения метода их инициализации. То есть вызывается код, инициализирующий переменные класса корректными стартовыми значениями.

Процесс загрузки классов в JVM должен отвечать следующим требованиям:

- Загрузка класса должна быть закончена до линковки.

- Сначала выполняется верификация, а только потом инициализация.

- Если на каком-либо этапе возникли ошибки ссылок, то разрешение этих проблем будет происходить только в рантайме. Сделано это из-за того, что в JVM может быть реализована не только ленивая загрузка классов, при которой загрузка классов, хранящихся в ссылочных полях, производится только при непосредственном обращении к этим полям, но и активная загрузка, при которой данные во всех символических ссылках загружаются сразу (все символические ссылки превращаются в прямые). По умолчанию разрешение происходит уже после окончания загрузки класса, как было показано в плане выше.

Стандартный системный загрузчик работает таким образом: при ленивой загрузке сначала загружается только класс, в котором находится метод main(), далее при обращении из кода метода main() к других классам, происходит их загрузка, и так далее до конца кода программы. Классы загружаются только при обращении к ним из какой-либо части кода. В этом суть ленивой загрузки по умолчанию.  

Схема подсистемы загрузчиков классов:

![image](https://github.com/artemaverin/summary/assets/97846877/908b26db-264c-4c46-84bb-2cb9e735fb54)

Алгоритм загрузки класса.

Попытка загрузки класса производится начиная с самого нижнего уровня иерархии к самому верхнему. Точнее будет сказать, что поиск начинается с текущего загрузчика. Текущий загрузчик - это загрузчик, который загружал класс, откуда происходит вызов следующего класса. Как уже говорилось ранее, скорее всего текущим будет загрузчик System / Application.

Пользовательские загрузчики в этой иерархии мы рассматривать не будем. На схеме они показаны для наглядности их расположения.

Непосредственная попытка загрузки класса происходит таким образом: у каждого загрузчика есть список классов, который он уже загружал (кэш). Сначала производится проверка, есть ли в кэше загрузчика System / Application (в текущем) требуемый класс. Если его там нет, задача делегируется родителю текущего загрузчика, то есть загрузчику Extension / Platform. Если в нём тоже нет, то задача делегируется дальше родителю текущего загрузчика - в загрузчик Bootstrap. Если в кэше какого-либо из этих загрузчиков есть запрашиваемый класс (класс уже был загружен ранее), то возвращается объект Class данного класса, и поиск завершается. Если ни у одного из этих загрузчиков в кэше нет запрашиваемого класса (то есть этот класс еще не загружался), то начинается попытка загрузки запрашиваемого класса в обратном порядке от корневого до текущего. Сначала загрузчик Bootstrap пытается загрузить запрашиваемый класс. Если в нём его нет, то этот класс пытается загрузить загрузчик Extension / Platform, далее System / Application, и если ни один из загрузчиков не загрузил запрашиваемый класс, то выбрасывается исключение ClassNotFoundException. Если же класс удалось загрузить какому-либо из загрузчиков, то на этом работа по загрузке этого класса прекращается.

Данный алгоритм отображён на этой схеме:

![image](https://github.com/artemaverin/summary/assets/97846877/ad3f9046-d0c0-4a7a-9477-ee56fb09a0b4)

Попытка загрузки = поиск класса среди "своих классов" и классов в области видимости.

**Принципы загрузки классов.**

В разобранном выше алгоритме применяются следующие правила:

- Делегирование

Как говорилось ранее, у каждого загрузчика есть список классов, который он уже загружал (кэш). Данный список называется областью видимости загрузчика. В область видимости попадают и классы, загруженные его предками. Применяется подход передачи полномочий по загрузке класса сначала своему родителю, а если он не может загрузить класс, тогда уже класс пытается загрузить его наследник (сначала поиск по кэшу снизу вверх, потом попытка загрузки класса сверху вниз). Данный подход обеспечивает загрузку класса загрузчиком, максимально близким к базовому, то есть с максимальной областью видимости. 

- Видимость

Область видимости загрузчика ограничена только классами, которые были загружены им или его родителями. Загрузчик не владеет данными о классах, которые загружали его наследники.

- Уникальность

Класс должен быть загружен только один раз. Модель делегирования полномочий обеспечивает соблюдение этого правила, так как даёт гарантию, что класс, загруженный загрузчиком-родителем, не будет еще раз загружаться его загрузчиком-наследником.

**ClassNotFoundException и NoClassDefFoundError.**

При работе загрузчиков классов может возникнуть 2 типа ошибок - исключение ClassNotFoundException и ошибка NoClassDefFoundError.

- ClassNotFoundException - это исключение, чаще всего возникающее при динамической загрузке класса при попытке создания класса через строковую переменную (Например, из настроек JDBC с помощью Class.forName()), а также если класс не найден при попытке загрузить его загрузчиком с помощью метода loadClass().

- NoClassDefFoundError - это ошибка, которая возникает в случае, когда класс был скомпилирован, но при выполнении программы он был не найден (Например, если в комплекте поставки программы отсутствуют файлы или библиотеки, с которыми она работает).

[к оглавлению](#Garbage-Collection)

## Вопросы

У процессора может быть несколько ядер. Верно ли логически данное утверждение: "Сам процесс сборки может быть ускорен з**а счет использования нескольких процессоров**, если они присутствуют физически." Используется несколько процессоров или ядер?

## Источники:

**Сравнение языков программирования** 

https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F

**Описание распределения памяти в JVM, принципы работы и виды GC** 

HotSpot Virtual Machine Garbage Collection Tuning Guide https://docs.oracle.com/en/java/javase/12/gctuning/index.html

"Сборщик мусора Garbage Collection" http://java-online.ru/garbage-collection.xhtml

"Дюк, вынеси мусор! — Часть 1" https://habr.com/ru/post/269621/

"How Garbage Collection works in Java" https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html

"Краткий конспект реализации Garbage Collector в Java" https://ziginsider.github.io/Garbage_Collector_Java/

"Секреты сборки мусора в Java" http://profyclub.ru/docs/305

"Сборщик мусора G1 в Java 9" https://urvanov.ru/2018/03/25/%d1%81%d0%b1%d0%be%d1%80%d1%89%d0%b8%d0%ba-%d0%bc%d1%83%d1%81%d0%be%d1%80%d0%b0-g1-%d0%b2-java-9/

**Типы ссылок в Java** 

Избавляемся от мусора в Java - https://habr.com/ru/companies/otus/articles/553996/

"Ссылка (Java)" http://cyclowiki.org/wiki/%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B0_(Java)#targetText=%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8%20%D0%B2%20Java%20%E2%80%94%20%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8%20%D0%BD%D0%B0,%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20%D0%BF%D0%BE%20%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E).

"Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Java" https://javarevisited.blogspot.com/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html

"Types of References in Java" https://www.geeksforgeeks.org/types-references-java/

"Мягкие ссылки на страже доступной памяти или как экономить память правильно" https://habr.com/ru/post/169883/

"Weak, Soft, and Phantom References in Java (and Why They Matter)" https://dzone.com/articles/weak-soft-and-phantom-references-in-java-and-why-they-matter

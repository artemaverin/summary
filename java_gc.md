## Garbage Collection

[1. Чем Java отличается от C++?](#1-Чем-Java-отличается-от-C)

[2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-Что-такое-ссылки)

[9. Какие типы ссылок вы знаете?](#9-Какие-типы-ссылок-вы-знаете)

[10. Чем они отличаются?](#10-Чем-они-отличаются)

## 1. Чем Java отличается от C++?

автоматическая сборка мусора отличает Java от языков более низкого уровня, в частности С/С++.

В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов new и delete).

В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. (освобождает память в куче, занятой неиспользуемыми объектами)

Т.е. в отличие от С++ нет явной необходимости уничтожать объект.

[к оглавлению](#Garbage-Collection)

## 2. Что такое менеджер памяти?

Менеджер памяти — часть компьютерной программы (как прикладной, так и операционной системы), обрабатывающая запросы на выделение и освобождение оперативной памяти или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

В Java, “Менеджер памяти” - это часть среды исполнения Java (JVM), которая отвечает за управление памятью, выделяя ее для объектов, которые создает и использует ваша Java-программа.

Когда вы создаете новый объект в Java, менеджер памяти выделяет память для его хранения. Когда объект больше не используется, менеджер памяти освобождает эту память обратно, чтобы она могла быть использована для других целей.

Важно понимать, что менеджер памяти управляет только памятью для объектов. Он не имеет ничего общего с оперативной памятью или памятью компьютера, на котором выполняется программа. Вместо этого, менеджер памяти работает внутри виртуальной машины Java (JVM) и управляет памятью в рамках этой виртуальной машины.

[к оглавлению](#Garbage-Collection)

## 3. Какой механизм используется в Java для управления памятью?

**v1**

В Java используется несколько механизмов для управления памятью. `Один из них - это сборка мусора (Garbage Collection)`. Сборка мусора - это процесс, во время которого менеджер памяти ищет все объекты, которые больше не используются программой, и удаляет их из памяти.

Кроме того, Java также использует технику под названием “аллокатор памяти” для управления памятью на более низком уровне. Алокатор памяти отвечает за выделение и освобождение памяти для объектов на протяжении всего времени выполнения программы.

`GC смотрит на достижимость объекта по ссылке. Это значит, что если мы не можем получить к нему доступ из программы, т.е. у нас нет ссылки на него, то он помечается как мусор и будет удален при следующей сборке мусора.`

**v2**

Распределение памяти в java реализует технология Java HotSpot от Oracle. 
Она обеспечивает динамическое выделение памяти для объектов и сборщиков мусора.

Память процесса делится на non-heap (до JDK 8 stack) и heap (куча):

В предыдущих выпусках Java Hotspot VM метаданные класса выделялись в Permanent Generation.
Начиная с JDK 8, permanent generation было удалено, а метаданные класса размещены в собственной памяти. 
Объем собственной памяти, которую можно использовать для метаданных класса, по умолчанию не ограничен. 

+ Stack (структура non-heap до JDK 8)
    + Permanent Generation — содержит необходимые для управления программой метаданные классов, 
    в том числе метаданные о созданных объектах, методах и т.п.
    + Code Cache — используемая JVM память при включенной JIT-компиляции 
    (в этой области памяти кешируется скомпилированный платформенно-зависимый код)     
 
+ Heap - куча (тут и работает GC)
    + New (Yang) Generation - хранит короткоживущие объекты.
        + Eden Space — сюда аллоцируются среднестатистические объекты*. Если нет места запускается малая сборка мусора (minor GC). 
        + Survivor Space — точнее их два, S1 и S2, и они меняются ролями. 
        Хранятся перемещенные из Eden Space объекты, признанные живыми во время сборки мусора (без разницы малой или полной). 
        Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
    + Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется, 
    выполняется полная сборка мусора (full GC).

Алгоритм GC исходит из того предположения, что большинство java-объектов живут недолго. 
Быстро становятся мусором. От них необходимо довольно оперативно избавляться. Что и происходит в New Generation. 
Там сбор мусора гораздо чаще, чем в Old Generation, где хранятся долгоживущие объекты. 
После создания объект попадает в New Generation и имеет шанс попасть в Old Generation по прошествии нескольких циклов GC.

*объекты-акселераты, размер которых настолько велик, что создавать их в Eden, 
а потом таскать за собой по Survivor’ам слишком накладно, размещаются сразу в Tenured Generation.

[к оглавлению](#Garbage-Collection)

## 4. Опишите процесс работы сборщика мусора

Прежде чем удалить объект, нужно знать, где он находится. Давайте рассмотрим структуру памяти в Java. Все объекты хранятся в куче (heap). Куча делится на поколения (generation). Есть всего два поколения: молодое (young) и старое (old). Young generation состоит из eden и survivor space.

![image](https://github.com/artemaverin/summary/assets/97846877/2e67f82c-1f51-43dc-9cf3-2cf2569ef139)

# Сборка мусора

Сборка мусора происходит, когда заполнена вся область памяти. Память делится на два поколения, поэтому есть два типа сборки мусора: _minor GC_ и _major GC_. Первый происходит, когда переполняется young generation, второй, когда переполняется область из old generation.

Теперь поговорим какие стадии проходят объекты до сборки мусора.

1. Объект рождается. Во время исполнения JVM видит, что стоит оператор new. Происходит выделение памяти под объект и возврат ссылки, которая будет ссылаться на занятый участок памяти. Все объекты рождаются в eden

![image](https://github.com/artemaverin/summary/assets/97846877/a2cdacdf-071a-4fc0-837e-14323d34eb34)

2. Этап 1 выполняет до тех пор, пока не будет заполнен eden

![image](https://github.com/artemaverin/summary/assets/97846877/75718acc-1717-46fc-8d0d-b2da743c8e6a)

Когда eden заполнен происходит minor GC:

3. Объекты, у которых уже нет ссылки удаляются

![image](https://github.com/artemaverin/summary/assets/97846877/b38f1d9b-81d0-4124-a379-a7d3f4f4cd3d)

4. Объекты, у которых есть ссылки попадают в survivor space из eden. Причем survivor space делиться на две части. Между этими частями происходит перемещения объектов. В один момент времени одна из частей пуста, чтоб мочь вместить объекты пришедшие из eden.

![image](https://github.com/artemaverin/summary/assets/97846877/6fae5c49-d684-4279-a060-5945ed94a4de)

5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age). Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется «взрослением» (aging).

![image](https://github.com/artemaverin/summary/assets/97846877/fc80edb6-89a3-4755-aa06-9f68828592da)

6. Объекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением» promotion.

![image](https://github.com/artemaverin/summary/assets/97846877/21013d1a-0778-47b3-a9ca-a3a6a1fe1aab)

Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для очищения young generation.

7. Когда old generation заполняется производиться major GC

8. Этапы 1-7 происходят на протяжении работы программы

[к оглавлению](#Garbage-Collection)

## 5. Какие алгоритмы сборщика вы знаете?

https://job4j.ru/profile/exercise/59/task-view/371

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

- Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .

- Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.

- Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

![image](https://github.com/artemaverin/summary/assets/97846877/5d492fb8-9075-4468-a597-8587bb96425c)

**Характеристики сборщиков мусора**

Сборщики мусора различаются относительно характеристик какими они обладают. Рассмотрим эти характеристики.

**Виды сборок мусора.**

После того как сборщик мусора определил, что нужно удалить объекты, он может пользоваться следующими сборками: Compacting, Non-compacting and Copying.

- _Compacting (Compact с англ. уплотнить):_

Собирает "живые" объекты в одном месте и очищает оставшуюся часть памяти, где находятся объекты, которые нужно уничтожить.

Преимущество такого подхода - легко можно выделять память для новых объектов.

Недостаток - требуется время на компоновку объектов в одном месте.

- _Non-compacting._

Удаляет объекты по месту. Т.е. он понимает, что данную часть памяти занимает объект, который нужно удалить, и чистит эту часть памяти.

Преимущество: не нужно производить лишние действия, нужно просто удалить объекты.

Недостаток: при создании объекта нужно находить для него подходящее место, что приводит к фрагментации памяти (это когда большая часть вашей памяти выделена в большом количестве несмежных блоков, оставляя приличный процент вашей общей памяти нераспределенной, но при этом непригодной для большинства типичных сценариев использования памяти), то есть много свободных мест памяти между занятыми ячейками, но из-за малых ее размеров, ее практически ничем не занять, и эта память простаивает.

- _Copying._

Копирует "живые" объекты в отдельную часть памяти, очистив старую часть, где они были (С этим типом вы встречались в прошлом задании).

Преимущество: нет препятствий выделению памяти.

Недостаток: требуется время на копирование.

**v2**

Имеется два подхода к очистке памяти, которые в совокупности определяют принцип функционирования Garbage Collection.

1. *Copying collectors* - в чистом виде в HotSpot VM не используется.

    Область памяти делится на две части: в одной части размещаются объекты, а вторая часть остается чистой. 
    На время очистки мусора приложение останавливает работу и запускается `GC`, который находит в первой области 
    объекты со ссылками и переносит их во вторую (чистую) область. После этого, первая область очищается от оставшихся 
    там объектов без ссылок, и области меняются местами.

    Достоинство данного подхода - плотное заполнение памяти. 
    
    Недостаток - необходимость остановки приложения и размеры двух частей памяти должны быть одинаковыми на случай, 
    когда все объекты остаются «живыми».

2. *Mark-and-sweep* - также в чистом виде в HotSpot VM не используется.

    Все объекты размещаются в одном сегменте памяти. Сборка мусора также приостанавливает приложение, и GC проходит 
    по дереву объектов, помечая занятые ими области памяти, как «живые». После этого, все не помеченные участки памяти 
    сохраняются в «free list», в которой будут, после завершения сборки мусора, размещаться новые объекты.
    
    Недостатки - необходимость приостановки приложения. 
    Кроме этого, время сборки мусора, как и время приостановки приложения, зависит от размера памяти. 
    Память становится «решетчатой», и, если не применить «уплотнение», то память будет использоваться неэффективно.

[к оглавлению](#Garbage-Collection)

## 6. Чем отличаются сборщики мусора?

**v1**

1. Serial GC.

Это самый простой вид сборщика. Он является Serial, Stop The World, Copying, т.е. выполняет сборку мусора в одном потоке, вызывается событие Stop The World и используется Copying сборку мусора. Подходит для простых клиентских приложений, к примеру проигрывателя музыки.

Плюс: минимальные требования к среде. Минус: медленный.

2. Parallel GC

Это усовершенствованная версия сборщика GC. Он является Parallel, Stop The World, Copying, т.е. его единственное отличие в том, что он выполняет сборку мусора в нескольких потоках. Подходит для более сложных клиентских приложений, где нет серьезных требований к скорости сборки, но ее наличие было бы неплохим преимуществом. К примеру, несложное приложение для работы с графикой.

Плюс: пошустрее, чем Serial GC. Минус: недостаточно быстрый, по сравнению с CMS, требует наличие нескольких ядер.

3. CMS (Concurrent Mark Sweep)

Это улучшенная версия Parallel GC. Он является Parallel, Concurrent, Copying. Лучше прошлого он тем, что используется параллелизм, т.е. часть heap чиститься наряду с работой приложения. Подходит для клиентских приложений, где длительные паузы не допустимы, например, настольное приложения для торговли на бирже.

Убран с JDK 14.

Плюс: небольшие паузу на сборку мусора. Минус: более высокие системные требования.

4. G1

Мощный сборщик сборщик мусора, усовершенствованная версия CMS. Он является Parallel, Concurrent, Copying. Его особенностью является высокая пропускная способность. Следовательно сборка мусора выполняется редко. Данный сборщик мусора используется для серверных приложений требующих быстрого отклика и не терпящих долгих пауз на сборку мусора.

Плюс: скорость. Минус: нужен большой heap (> 4gb)

5. ZGC

Данный сборщик появился недавно. Он является Parallel, Concurrent, Copying. Причем он использует параллелизм на полную мощь. Тем самым для очистки вовсе не требует остановки приложения, в отличие от G1, где паузы хоть и маленькие но присутствуют. Используется для приложений где допустимы лишь паузы < 10ms

Плюс: нет паузы. Минус: требует сверх большой heap в несколько терабайтов для эффективной работы

Доступен только с JDK 11.

- ---------------

**v2**

![image](https://github.com/artemaverin/summary/assets/97846877/f89b6bde-6855-4fe0-823b-7f7016b59299)

- -------------

**v3**

**Serial (последовательный)** — самый простой вариант для приложений, 
которым не требуется большой размер кучи для работы (Oracle указывает условную границу 100 МБ), 
которые не очень чувствительны к коротким остановкам и им для работы доступно только одно ядро процессора.
Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

**+** Непритязательность по части ресурсов компьютера. Т.к. всю работу он выполняет последовательно в одном потоке, никаких заметных оверхедов и негативных побочных эффектов у него нет.

**-** Долгие паузы на сборку мусора при заметных объемах данных. 

**-** Все настройки Serial GC крутятся вокруг размеров различных регионов кучи, т.е. для тонкой настройки 
требуется вручную что-то изучать, настраивать, экспериментировать и т.д. 

**Parallel (параллельный)** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в 
некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для большинства приложений. 
У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

**+** в сравнении с Serial GC есть возможность автоматической подстройки под требуемые параметры производительности 
и меньшие паузы на время сборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.

**-** Определенная фрагментация памяти, но вряд ли она будет существенной для большинства приложений, 
т.к. сборщиком используется относительно небольшое количество потоков.

**Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора 
параллельно с основными потоками приложения. Более требователен к ресурсам процессора.
Подходит для работы в приложениях с относительно большими объемами долгоживущих данных,
для приложений, имеющих доступ к нескольким ядрам процессора и чувствительных к паузам STW.

**+** по сравнению с рассмотренными ранее Serial/Parallel GC ориентирован на минимизацию времени простоя, 
что является критическим фактором для многих приложений. 
Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.

**-** не уплотняет объекты в старшем поколении, что приводит к фрагментации области Tenured. 
Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению 
(конкретно — старшему поколению) больше памяти, чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).

**-** долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. 
Хотя они не частые, и при наличии достаточного объема памяти сборщику CMS удается их полностью избегать.

**Garbage-First (G1)** — создан для замены CMS, но не является явным продолжением линейки Serial/Parallel/CMS. 
Мспользуется в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных 
(размер кучи от 4 ГБ и выше), для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет 
уменьшения пропускной способности.

**+** G1 более точно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, 
чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. 

**+** В отличие от CMS, например, он не фрагментирует память.

**-** Тратит ресурсы процессора, которые использует для выполнения достаточно большой части своей работы параллельно с основной программой. 
В результате страдает пропускная способность приложения. 
Целевое значением пропускной способности по умолчанию для G1 равно 90%, для Parallel GC составляет 99%. 
Это не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует учитывать.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_6.1.png)
 
«Монолитный» означает то, что всё поколение должно быть очищено за проход.

«В большинстве случаев одновременный» — mostly concurrent, одновременный имеется в виду фоновый, «работающий вместе с потоками приложения».

**Z Garbage Collector (ZGC)** - это масштабируемый сборщик мусора с малой задержкой. 
ZGC выполняет всю дорогостоящую работу одновременно, не останавливая выполнение потоков приложения.

ZGC предназначен для приложений, которые требуют малой задержки (паузы менее 10 мс) и/или используют очень большую кучу 
(мульти-терабайты). Включается с помощью опции `-XX:+UseZGC`.

ZGC доступен в качестве экспериментальной функции, начиная с JDK 11.

Подробнее здесь https://habr.com/ru/post/269621/

[к оглавлению](#Garbage-Collection)

## 7. Расскажите про утилиты для анализа памяти?

встроенные в JDK утилиты: jps, jmap, jstat, jconsole, visualvm до java 9.

внешние: VisualVM c java 9 и утилита от NetBeans - YourKit Java Profiler.

jconsole, visualvm и yourkit profiler предоставляют удобный визуальный интерфейс.

**jps** - выводит pid-ы процессов, которые использует VM

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.1.png)

 
**jmap** - выводит информацию о состоянии памяти виртуальной машины
	
`jmap -heap 14152` или `jhsdb jmap --heap --pid 14152`
	
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.2.png)
 
**jstat** - аналогично jmap

**jstack** - показывает какие процессы запущены в  виртуальной машине (нет инфы о памяти)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.3.png)
 
...

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.4.png) 

**jconsole**
 
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.5.png) 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.6.png)

**VisualVM** (с плагином VisualGC)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.7.png) 

**YourKit Profiler** - универсальный расширенный профилировщик, используется не только для анализа памяти, 
но и ,например, для поиска узких мест в коде (повторения и тп)

[к оглавлению](#Garbage-Collection)

## 8. Что такое ссылки?

Перед сборкой мусора сборщик мусора маркирует объекты. В зависимости от этого он решает какие нужно удалить, а какие нет. На принятие решения об удалении влияет тип ссылки объекта.

Ссылки в Java — это механизм, позволяющий работать с объектами в памяти компьютера. Ссылки используются для обращения к объектам и вызова их методов. В Java все объекты создаются в динамической памяти, и для работы с ними используются ссылки.

Ссылки в Java работают следующим образом: при создании объекта в памяти выделяется блок памяти определенного размера, который содержит данные объекта. Затем создается ссылка на этот блок памяти. Ссылка может указывать на объект определенного типа или интерфейса.
- -----------------------

Ссылки в Java — это указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, 
в которой хранится объект. Кроме того, ссылка может быть инициализирована как `null` — нулевая ссылка, не указывающая 
ни на какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом 
контексте также может быть использована ссылка `this`, указывающая на текущий объект, и ссылка `super`, 
указывающая на текущий объект суперкласса.

Абстрактный класс `java.lang.ref.Reference` предоставляет базу для ссылочных классов. В нём определены следующие методы:

+ `get` — метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
+ `clear` — очищает ссылку.
+ `isEnqueued` и `enqueue`, отвечающие за взаимодействие ссылки и объекта `ReferenceQueue`.

[к оглавлению](#Garbage-Collection)

## 9. Какие типы ссылок вы знаете?

https://job4j.ru/profile/exercise/61/task-view/375

https://habr.com/ru/articles/169883/

https://www.youtube.com/watch?v=5HC8qVHQPi8

В Java существует четыре типа ссылок, различающихся по способу сбора мусора и 
предоставляющие пользователю возможность более гибко работать с памятью:
                                                                            
+ **Сильные ссылки (Strong References)** - стандартные ссылки, создаются каждый раз, когда аллоцируем место в памяти через 
оператор new. Если на объект есть хоть одна жесткая ссылка, то данный объект не будет утилизирован при сборке мусора, что может привести к утечке памяти, что в свою очередь может привести к ошибке OutOfMemoryException - ситуации когда программе не хватает выделенной памяти.

```java
Counter counter = new Counter(); // strong reference
```

+ **Мягкие ссылки (Soft References)** - создаются с помощью вызова `new SoftReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new SoftReference(T obj)`. Если на объект есть только мягкая ссылка, то будет выполнена попытка утилизации данного 
объекта при сборке мусора в случае, если приложению не хватает памяти.т.е. они могут пережить более одной сборки мусора.

Данный тип ссылок подходит для реализации кэша - такой структуры данных, при которой часть данных запоминается, а потом часто переиспользуется.

Например, можно запоминать данные из файлов или тяжелых запросов.

При нехватке памяти JVM может удалить объекты по этим ссылкам, если на них нет сильных ссылок.

Есть контракт для данного типа ссылок: GC гарантировано удалит из кучи все объекты, доступные только по soft-ссылке, перед тем, как бросит OutOfMemoryError

```java
Counter prime = new Counter();  // prime holds a strong reference - line 2
SoftReference<Counter> soft = new SoftReference<Counter>(prime) ; //soft reference variable has SoftReference to Counter Object created at line 2

prime = null;  // now Counter object is eligible for garbage collection but only be collected when JVM absolutely needs memory
```

Корректным использованием безопасных ссылок является сначала получение сильной ссылки на данные, а потом работа с сильной ссылкой.

Это гарантирует, что в интервалах получения сильной ссылки из безопасной GC не затрет объект. Это касается не только локальных переменных, но и возвращаемых значений и аргументов.

+ **Слабые ссылки (WeakReferences)** - создаются с помощью вызова `new WeakReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new WeakReference<T>(T obj)`.Объекты, на которые ссылаются слабые ссылки, удаляются сразу, если на них нет сильных или безопасных ссылок.

```java
Counter counter = new Counter(); // strong reference - line 1
WeakReference<Counter> weakCounter = new WeakReference<Counter>(counter); //weak reference
counter = null; // now Counter object is eligible for garbage collection
```

Данный тип ссылок служит для реализации структур, для которых у одного значения типа может быть только один объект, например пул строк, и объекты чаще всего используется всего один раз, т.е. сохранили-получили-забыли.

+**ReferenceQueue** - Все типы ссылок, за исключением сильных, в Java являются наследниками класса Reference. Все его наследники всегда попадают в ReferenceQueue, это может происходить явно (мы можем задать свою очередь) или неявно (когда мы не задаем). В нее попадают ссылки тех объектов, которые уже помечены на удаление.

+ **Фантомные ссылки (PhantomReferences)** - создаются с помощью вызова `new PhantomReference<T>(T obj, ReferenceQueue<T> queue)`.
Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок. 
Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора. 
Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка или данная 
фантомная ссылка не очищена с помощью вызова метода `clear()`. Так же стоит заметить, что метод `get()` фантомной ссылки 
всегда возвращает `null`.

```java
DigitalCounter digit = new DigitalCounter(); // digit reference variable has strong reference - line 3
PhantomReference<DigitalCounter> phantom = new PhantomReference<DigitalCounter>(digit); // phantom reference to object created at line 3

digit = null;
```

[к оглавлению](#Garbage-Collection)

## 10. Чем они отличаются?

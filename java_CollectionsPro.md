## Collections Pro

#### part 1. [Collections Lite](CollectionsLite.md#collections-lite)

[1. Что такое генерики?](#1-Что-такое-генерики)

[2. Что такое wild cards?](#2-Что-такое-wild-cards)

[3. Что такое bounded wild cards?](#3-Что-такое-bounded-wild-cards)

[4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)

[5. Где хранится информация про Generics?](#5-Где-хранится-информация-про-Generics)

[6. Как можно получить тип Generics?](#6-Как-можно-получить-тип-Generics)

[7. Что такое итератор?](#7-Что-такое-итератор)

[8. Что такое коллекции?](#8-Что-такое-коллекции)

[9. Назовите базовые интерфейсы коллекций?](#9-Назовите-базовые-интерфейсы-коллекций)

[10. Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-List)

[11. Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-Set)

[12. Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-Map)

[13. Отличие ArrayList от LinkedList?](#13-Отличие-ArrayList-от-LinkedList)

[14. Отличие Set от List?](#14-Отличие-Set-от-List)

[15. Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-Object-hashCode-и-equals)

[14. Расскажите про реализации Map?](#14-Расскажите-про-реализации-Map)

[15. Расскажите, что такое коллизии в Map? Как с ними бороться?](#15-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)

[16. Расскажите, что такое анализ алгоритма?](#16-Расскажите,-что-такое-анализ-алгоритма)

[17. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#17-Какая-временная-сложность-алгоритмов-добавления,-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)

[18. Расскажите реализации данных очередей и стеков?](#18-Расскажите-реализации-данных-очередей-и-стеков)

[19. Расскажите про реализации деревьев?](#19-Расскажите-про-реализации-деревьев)

[20. Что такое loadFactor?](#20-Что-такое-loadFactor)

[21. Пример какова сложность поиска значения по ключу?](#21-Пример-какова-сложность-поиска-значения-по-ключу)

[22. Расскажите правило для переопределения метода hashCode?](#22-Расскажите-правило-для-переопределения-метода-hashCode)

[23. Приведите пример переопределения hashCode?](#23-Приведите-пример-переопределения-hashCode)

[24. Как вычисляется hash функция от объекта в HashMap?](#24-Как-вычисляется-hash-функция-от-объекта-в-HashMap)

[25. Правила проверки при переопределении метода equals?](#25-Правила-проверки-при-переопределении-метода-equals)

[26. Как устроена HashMap?](#26-Как-устроена-HashMap?)

[27. Какое начальное количество корзин в HashMap?](#27-Какое-начальное-количество-корзин-в-HashMap)

[28. Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?](#28-Какая-оценка-временной-сложности-выборки-элемента-из-HashMap-Гарантирует-ли-HashMap-указанную-сложность-выборки-элемента)

[29. Роль equals и hashCode в HashMap?](#29-Роль-equals-и-hashCode-в-HashMap)

[30. Как и когда происходит увеличение количества корзин в HashMap?](#30-Как-и-когда-происходит-увеличение-количества-корзин-в-HashMap)

[31. Как работает HashMap?](#31-Как-работает-HashMap)

[32. Что такое хеш таблицы?](#32-Что-такое-хеш-таблицы)

[33. Что такое красно-черное дерево?](#33-Что-такое-красно-черное-дерево)

[34. Удаление элемента из дерева?](#34-Удаление-элемента-из-дерева)

[35. Какие существуют алгоритмы обхода дерева?](#35-Какие-существуют-алгоритмы-обхода-дерева)

## 1. Что такое генерики?

**Ответ1**

Обобщенное программирование - это подход к описанию данных и алгоритмов, позволяющий использовать их с разными типами
данных без изменения их описания.

**Обобщения** - это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, где тип данных 
указан в виде параметра. 

Дженерики позволяют типам (классам и интерфейсам) быть параметрами при определении классов, интерфейсов и методов.
Параметры типа предоставляют возможность повторно использовать один и тот же код с разными входами наподобие формальных 
параметров в объявлениях методов. Разница в том, что входные данные для формальных параметров являются значениями, а
для дженериков - типами данных. Переменная типа может быть любым не примитивным типом.

В Java дженерики добавили для реализации обобщенных коллекций, безопасных с точки зрения типов.
Ошибка компиляции - это лучше, чем исключение `ClassCastException` в связи с неправильным приведением типов во время выполнения.
После компиляции какая-либо информация о дженериках стирается. Это называется "Стирание типов".
Также дженерики делают исходный код программы более удобочитаемым.

Свойства дженериков: строгая типизация, единая реализация, отсутствие информации о типе.

В `Java Collections Framework`используются обобщенные типы, например, класс типа `LinkedList<E>` - обобщенный тип. 
Параметр `<E>` предсталяет тип элементов, которые будут храниться в коллекции.

`LinkedList<String>`, `LinkedList<Integer>` - это параметризованные типы, а `String`, `Integer` - реальные типы аргументов.

наглядно из Effective Java:

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/pro_1.png)

**Ответ2**

Дженерики (generics) в языке программирования Java — это сущности, которые могут хранить в себе данные только определенного типа. Например, список элементов, в котором могут быть одни числа. Но не только: дженерик — обобщенный термин для разных структур.

Дженерик-сущности еще иногда называют параметризованными, общими или обобщенными. Такая сущность создается со специальным параметром. Параметр позволяет указать, с каким типом данных она будет работать. Отсюда и название.

В разных источниках можно услышать про «тип-дженерик», «класс-дженерик» или «метод-дженерик». Это нормально, ведь обобщение и параметризация касаются всех этих сущностей, а generics — общий термин.

**Для чего нужны дженерики**
С дженериками работают программисты на Java. Без этой возможности писать код, который работает только с определенным видом данных, было сложнее. Существовало два способа, и оба неоптимальные:

- указывать проверку типа в коде. Например, получать данные — и сразу проверять, а если они не те, выдавать ошибку. Это помогло бы отсеять ненужные элементы. Но если бы класс понадобилось сделать более гибким, например, создать его вариацию для другого типа, его пришлось бы переписывать или копировать. Не получилось бы просто передать другой специальный параметр, чтобы тот же класс смог работать еще с каким-то типом;
- полагаться на разработчиков. Например, оставлять в коде комментарий «Этот класс работает только с числами». Слишком велик риск, что кто-то не заметит комментарий и передаст в объект класса не те данные. И хорошо, если ошибка будет заметна сразу, а не уже на этапе тестирования.
Поэтому появились дженерики: они решают эту проблему, делают написание кода проще, а защиту от ошибок надежнее.

**Как работают дженерики**
Чтобы вернее понять принцип работы, нужно представлять, как устроены сущности в Java. Есть классы — это как бы «чертежи» будущих сущностей, описывающие, что они делают. И есть объекты — экземпляры классов, непосредственно существующие и работающие. Класс — как схема машины, объект — как машина.

Когда разработчик создает дженерик-класс, он приписывает к нему параметр в треугольных скобках — метку. К примеру, так:

*class myClass< T >;*

Теперь при создании объекта этого класса нужно будет указать на месте T название типа, с которым будет работать объект. Например, myClass< Integer> <название объекта> для целых чисел или myClass< String> <название объекта> для строк. Сам класс остается универсальным, то есть общим. А вот каждый его объект специфичен для своего типа.

С помощью дженериков можно создать один класс, а потом на основе него — несколько объектов этого класса для разных типов. Не понадобится дублировать код и усложнять программу. Поэтому дженерики лучше и удобнее, чем проверка типа прямо в коде — тогда для каждого типа данных понадобился бы свой класс.


Generics в данном случае это запись, заключенная в скобки <>, т.е. < String>. Это означает, что в коллекцию можно будет добавлять только элементы, которые являются экземплярами класса String. При попытке добавить экземпляр другого класса - мы получим ошибку компиляции.
	
Существует такое понятие, связанное с generics, как необработанные типы (в литературе, интернете еще можно встретить такое название как "сырые типы"). Обозначаются они также как и generics в скобках <>, в которых проставляются заглавные латинские символы, зарезервированные специально для этих целей символы - полный список можно найти по ссылке:

Для того чтобы создать класс общего типа достаточно в его объявлении в <> указать перечень общих типов, которые будут использоваться для реализации класса (типов может быть несколько):

```java
public class GenericsClass<K, V> {}
```

Подобным же образом generics может использоваться и с интерфейсами.

Рассмотрим очень важное понятие, как стирание типов. Во время процесса компилятором выполняется стирание типов, которое заключается в том, что все параметры типа компилятор заменяет каждый своей первой привязкой, если параметр типа ограничен, или Object, если параметр типа не ограничен.

Использование generics имеет несколько ограничений:

1. Невозможно создать массив параметра типа - такая запись допустима:

`T[] array;`

однако следующая запись:

`new T[100];`

вызовет ошибку компиляции, поскольку такая запись недопустима.

2. Невозможно создать массив Generic-классов - например, вот такая запись допустима:

`new ArrayList<List<Integer>>();`

т.е. мы можем создать список, каждый элемент в котором также является списком, а вот такая запись:

`List<Integer>[] lists = new List<Integer>[10];`

недопустима.

![image](https://github.com/artemaverin/summary/assets/97846877/cd352bd5-f502-4ebd-aaa3-6e7347ed7fe0)
	
https://job4j.ru/profile/exercise/39/task-view/276
	
[к оглавлению](#Collections-Pro)

## 2. Что такое wild cards?

Существует 2 типа дженериков:

+ **<Т> Обычные дженерики (параметризованные типы)** - представляет возможность указать в классе или методе 
неопределенный тип или несколько типов, дать ему имя, котрое в дальнейшем можно использовать в рамках класса или метода, 
как эквивалентное оригинальному типу. 

    Может быть использован с ключевым словом `extends`, ограничен этим классом и его наследниками. 
Так же можно использовать & и/или | указать несколько классов и/или интерфейсов. 
Поддерживает рекурсивное расширение типов.

`public static class NumberContainer<T extends Number & Comparable> {`

+ **<?> Wildcard (подстановочные типы или маски)** - используются в сигнатуре методов, но для параметризации класса - нет! 
Может быть использован в сочитании ключевыми словами `extends` и `super`. Делятся на три типа:
    
    + Upper Bounded Wildcards `<? extends Number>`
    
    + Unbounded Wildcards `<?>`
    
    + Lower Bounded Wildcards `<? super Integer>` 
    
Для выбора типа используют принцип PECS (`Producer Extends` `Consumer Super`)
+ `extends` - когда надо только получать данные из объекта. Метод передает данные в аргумент.
+ `super` - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента.
+ не использовать `wildcard`, когда требуется и получать и вставлять данные в структуру. 

в Java есть и специальный символ для обозначения неизвестного типа — «?». Его принято называть wildcard, дословно — «дикая карта».

Wildcards удобно использовать для объявления переменных и параметров методов совместно с классами из Java Collection Framework — здесь собраны инструменты Java для работы с коллекциями.

[к оглавлению](#Collections-Pro)

## 3. Что такое bounded wild cards?

bounded wild cards - это первый из нескольких типов wildcard — “extends” (другое название — Upper Bounded Wildcards).

upper bounding — ограничение сверху. За вопросительным знаком следует слово extends и название типа. В такой дженерик можно передавать названный тип и его потомков;

```java
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;
```
Это ковариантность. List< Integer> — подтип List< ? extends Number>

> Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке. Например, если Кошка — это подтип Животные, то Множество<Кошки> — это подтип Множество<Животные>.Следовательно, с учетом принципа подстановки можно выполнить такое присваивание: `Множество<Животные>  = Множество<Кошки>`

## 4. Что такое unbounded wild cards?

unbounded wild cards - “super” (другое название — Lower Bounded Wildcards).

lower bounding — ограничение снизу. Ситуация наоборот: за вопросительным знаком слово super и тип, а подставлять можно элементы этого типа и его предков.

```java
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;
```
Это контравариантность. List< Number> является подтипом List< ? super Integer>.

>Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах. Например, если Кошка — это подтип Животные, то Множество<Животные> — это подтип Множество<Кошки>. Следовательно,  с учетом принципа подстановки можно выполнить такое присваивание: `Множество<Кошки> = Множество<Животные>`

## 5. Где хранится информация про Generics?

Только в исходном коде до момента компиляции.

в информации о классе, который явно определяет значение параметра в его generic-родителе.

```java
public class FloatList extends ArrayList<Float>{}
```

https://habr.com/ru/articles/66593/

[к оглавлению](#Collections-Pro)

## 6. Как можно получить тип Generics?

```java
.getGenericSuperclass()
Class<T> t = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
```

Существует только одна ситуация, когда универсальный тип доступен во время выполнения - это когда универсальный тип является частью сигнатуры класса подобным образом:

```java
package ru.job4j.generics;

import java.util.ArrayList;

public class FloatList extends ArrayList<Float> {
   
}
```

теперь мы можем узнать что класс ArrayList (а, соответственно, и класс FloatList) был параметризован классом Float следующим образом:

```java
public static void main(String[] args) {
    ArrayList<Float> listOfNumbers = new FloatList();
    
    Class actual = listOfNumbers.getClass();
    ParameterizedType type = (ParameterizedType) actual.getGenericSuperclass();
    System.out.println(type);
    Class parameter = (Class) type.getActualTypeArguments()[0];
    System.out.println(parameter);
}
```

[к оглавлению](#Collections-Pro)

## 7. Что такое итератор?

Это шаблон проектирования для прохода по всем элементам множества
Основные методы:
+ `hasNext()` - существует ли следующий элемент.
+ `next()` - возвращает сам элемет.

В стандартной библиотеке java существует 2 интерфейса это `Iterable` и `Iterator`. 
+ `Iterable` - вынуждает релизовать метод возвращающий итератор.
+ `Iterator` - вернуть объект итератора.
- -------------------------------------

`Iterable` (какое) - итерируемое. То по чему можно итерироваться. Имплементируется классом, по которому нужно будет итерироваться.

`Iterator` (кто/что) - инструмент итерирования по коллекции. Итератор это отдельный класс, как правило вложенный в итерируемый класс, который задает логику итерации по итерируемому. И, естественно, имплементирует интерфейс Iterator .

java.lang.Iterable< E> — интерфейс стандартной библиотеки Java. По объекту класса, реализующего этот интерфейс, можно "проитерироваться" — перечислить несколько элементов типа E, используя foreach. Интерфейс Iterable содержит один метод iterator(), возвращающий объект типа Itaretor< E>.

java.util.Iterator< E> — интерфейс, описывающий свойства "итератора". В некотором смысле можно считать, что итератор — это текущее состояние прохода по элементам того, по чему мы итерируемся. Т.е. если в качестве объекта, по которому мы итерируемся, выступает, например, массив, то итератор может хранить индекс, на котором мы сейчас находимся.

Содержит два метода:

E next() — вернуть значение следующего элемента и сдвинуть итератор "вперед"

boolean hasNext() — вернуть true, если пройдены еще не все элементы, и false в противном случае

Collection< E> является подинтерфейсом Iterable< E> (т е по любой Collection можно проитерироваться, перебрав все элементы).

[к оглавлению](#Collections-Pro)

## 8. Что такое коллекции?

Это хранилища объектов с динамическим размером, и разным временем на разные операции: поиск, вставка, удаление.

Это хранилища, поддержиающие различные способы накопения и упорядочивания объектов с целью обеспечения возможностей эффективного доступа к ним. Это классы, объекты которых реализуют различные способы хранения данных.

Коллекции = оптимизированные структуры данных, которые описывают легкие способы работы с данными.

Java Collection Framework – это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам пользоваться большим количеством структур для хранения набора данных.

[к оглавлению](#Collections-Pro)

## 9. Назовите базовые интерфейсы коллекций?

+ **`Collection`** - коллекция содержит набор объектов (элементов). 
Здесь определены основные методы для манипуляции с данными, 
такие как вставка (`add`, `addAll`), удаление (`remove`, `removeAll`, `lear`), поиск (`contains`). 

+ **`Map** - описывает коллекцию, состоящую из пар "ключ — значение". У каждого ключа только одно значение.

- ---------------------------

**Collection** – этот интерфейс определен в JDK с версии 1.2 и описывает основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (к примеру size(), isEmpty(), add(E e) и т.д.). Интерфейс несколько был доработан с появлением generic в версии 1.5. В версии Java 8 было добавлено несколько новых методов для работы с лямбдами и Stream (например, stream(), parallelStream() и т.д.)

**Map** – этот интерфейс также находится в составе JDK с версии 1.2 и предоставляет программисту базовые методы для работы с данными вида «ключ-значение». По аналогии с Collection этот интерфейс был дополнен generic в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые часто реализовывались в логике приложения (getOrDefault(), putIFAbsent()).

+ **Set** - Множество. (Здесь могут храниться только уникальные значения, нет дубликатов)
+ **Queue (Deque)** - Очередь. FIFO (Первый вошел, первый вышел). реализуется LinkedList'ом
+ **List** - Упорядоченное хранение данных. (В какой последовательности данные положили, в такой они и хранятся)
+ **Map** - (от Collection он не наследуется) Значения хранятся как пара - ключ-значение. и по ключу получаем значение.
у мапы нету итератора

![imageTaskSource (1)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https:%2F%2Fblog.kakaocdn.net%2Fdn%2FlkxJ0%2FbtqPRAqajRU%2FZC2AOKKkiwQkBkYskMsNVk%2Fimg.png)


[к оглавлению](#Collections-Pro)

## 10. Расскажите реализации интерфейса List?

List - Упорядоченное хранение данных. (В какой последовательности данные положили, в такой они и хранятся)

+ **`ArrayList`** - на массиве с несинхронизированными методами.

+ **`Vector`** - на массиве с синхронизированными методами.

+ **`Stack`** - на массиве есть синхронизированные методы но не все.

+ **`LinkedList`** - двусвязный список.

![](https://habrastorage.org/r/w1560/files/187/da1/649/187da164972c4519b6affbc4a2c6fda1.png)

В такой структуре в определенной последовательности хранятся элементы одного типа. Очень важная особенность данной структуры – мы всегда можем пронумеровать элементы списка, т.е. проводя аналогию с массивом – у каждого элемента есть свой индекс.

Реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).

**`Vector`** — реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но как и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется достижения потокобезопасности. Потому как в Vector, в отличии от других реализаций List, все операции с данными являются синхронизированными. В качестве альтернативы часто применяется аналог — ArrayList.

**`Stack`** — данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления push()). После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque.

**`ArrayList`** — как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции. Подробный анализ и описание можно почитать в этом хабратопике.

некоторые выводы по ArrayList:

- быстрый доступ к элементам по индексу (O(1));

- доступ к элементам по значению за линейное время (O(n));

- реализации вставки и удаления элементов из "середины" списка - достаточно медленные и тяжелые;

- допускается хранение любых значений, в том числе и null (при этом null элементы и пустые ячейки разные вещи);

- размер списка это количество элементов в нем, а не размер внутреннего массива

**`LinkedList`** — ещё одна реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь. Для этого в ней реализованы соответствующие методы. На Хабре также есть статья с подробным анализом и описанием этой коллекции.

некоторые выводы по реализации LinkedList:

1. Позволяет хранить любые данные, в том числе null и дубликаты.

2. Обеспечивает быстрое (O(1)) добавление и удаление первого и последнего элемента. Также быстро выполняются операции вставки и удаления элементов в середину списка(выносим за скобки поиск позиции элемента, который осуществляется за линейное время).

3. Поиск элемента по значению и индексу осуществляется за линейное время (O(n)).

**методы интерфейса:** 

- `boolean add(E e)` – добавляет элемент e в конец списка.
- `void add(int index, E element)` – добавляет указанный элемент (element) в указанную позицию(index) в списке. При этом сдвигает элемент, который находится в этой позиции(если есть), и все последующие элементы вправо.
- `boolean addAll(Collection<? extends E> c)` – добавляет все элементы из переданной коллекции в конец списка в том порядке, в котором они возвращаются итератором переданной коллекции.
- `boolean addAll(int index, Collection<? extends E> c)` – добавляет все элементы из коллекции c в список в указанную позицию(index). При этом сдвигает элемент, который находится в этой позиции, и все последующие элементы вправо. Добавляемые элементы будут расставлены в том порядке, в котором они возвращены итератором переданной коллекции.
- `List<E> of(E ... elements)` - метод возвращает список, в которые помещены список элементов elements типа E.
- `E get(int index)` – метод возвращает элемент, который находится в позиции index в этом списке. Метод может кинуть исключение класса IndexOutOfBoundsException, если будет выполнено условие index < 0 || index > size().
- `E set(int index, E element)`– заменяет элемент позиция которого равна index на элемент который мы передаем в метод (element). При этом метод возвращает старое значение элемента с индексом index.
- `default void replaceAll(UnaryOperator<E> operator)` – заменяет каждый элемент в списке результатом применения оператора (operator) к каждому элементу.
- `E remove(int index)` – удаляет элемент из списка по индексу index, при этом метод возвращает удаленный элемент.
- `boolean remove(E e)` – удаляет элемент е типа E из коллекции при его ПЕРВОМ вхождении в список, если он есть в коллекции. Метод remove(E e) реализован с помощью цикла for(), подразумевает под собой первоначальный поиск удаляемого элемента и только потом он удаляется. Соответственно, использование этого метода внутри цикла, который перебирает список, не рекомендуется, поскольку мы будем проходить по списку дважды.
- `boolean removeAll(Collection<?> col)` – метод удаляет из списка все элементы, которые содержатся в коллекции col, если в результате работы метода исходный список изменился - метод возвращает true.
- `boolean retainAll(Collection<?> col)` – метод также удаляет элементы из списка, за исключением тех, которые находятся в коллекции col, если в результате работы метода исходный список изменился - метод возвращает true.
- `default boolean removeIf(Predicate<? super E> filter)` – метод удаляет все элементы из коллекции, которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения). Если в результате работы метода список изменился - метод возвращает true.
- `boolean contains*(E element)` – метод возвращает true, если список содержит переданный в метод элемент element.
- `int indexOf*(E element)` – метод возвращает индекс элемента element при его первом вхождении в список. Если элемент не найден - метод возвращает -1.
- `int lastIndexOf*(E element)` - метод возвращает индекс элемента element при его последнем вхождении в список. Если элемент не найден - метод возвращает -1.
- `int size()` - метод возвращает целочисленное значение, и говорит нам о том, сколько элементов находится в списке.
- `List<E> subList(int fromIndex, int toIndex)`- метод возвращает список, который содержит все элементы исходного списка начиная с индекса fromIndex(включительно) и до toIndex(значение исключается). При этом, если выполняется условие fromIndex == toIndex,- метод вернет пустой список.
- `default void sort(Comparator<? super E> comp)` – метод осуществляет сортировку списка в соответствии с компаратором comp, который мы передаем в метод.

[к оглавлению](#Collections-Pro)

## 11. Расскажите реализации интерфейса Set?

**`Set`** - набор/множество, не может содержать дубликаты.

+ **`HashSet`** - основан на `HashMap`.

+ **`LinkedHashSet`** - расширяет `HashSet`, позволяет получать элементы в порядке их добавления, но требует больше памяти.

+ **`TreeSet`** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию `hashCode()`'ов. 
Можно управлять порядком при помощи компаратора.

![](https://habrastorage.org/r/w1560/files/aca/208/428/aca20842816a48628772bd23d2bb0f24.png)

Представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество».

Интерфейс Set< E> имеет три реализации: HashSet, LinkedHashSet и TreeSet.

**1. HashSet.**

Это коллекция, которая не позволяет хранить одинаковые объекты(как и любой Set). HashSet инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. При этом ключами в таблице будут значения которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - "заглушки" в виде экземпляров класса Object.

Хэш-таблица хранит информацию, используя механизм хеширования, в котором содержимое ключа используется для определения уникального значения - хеш-код. Хеш-код используется в качестве индекса, с которым ассоциируются данные, которые доступны по ключу. Преобразование ключа в хеш-код и обратно выполняется автоматически - об этом будет рассказано позже при рассмотрении HashMap. Хеширование выгодно тем, что оно обеспечивает константное время выполнения методов contains(), add(), remove().

Для того, чтобы использовать HashSet для хранения объектов, описанных классами собственной реализации, необходимо переопределить методы hashcode() и equals(), иначе два логически одинаковых объекта будут считать разными.

Класс HashSet не гарантирует упорядоченности элементов, поскольку процесс хеширования не позволяет сделать в итоге отсортированный набор данных.

Для создания объекта HashSet в классе определены 4 конструктора:

HashSet() - создается пустое множество - при этом инкапсулированный объект HashMap имеет по умолчанию начальную емкость 16 элементов и коэффициент загрузки 0.75.

HashSet(int initialCapacity) - создается пустое множество - при этом объект HashMap, который используется внутри будет иметь начальную емкость, переданную в конструктор, и коэффициент загрузки по умолчанию - 0.75.

HashSet(int initialCapacity, float loadFactor) - создается пустое множество - при этом объект HashMap, который используется внутри будет иметь начальную емкость и коэффициент загрузки, которые передаются в конструктор.

HashSet(Collection< ? extends E> c) - будет создано множество, в которое будет помещены элементы передаваемой коллекции.

**2. LinkedHashSet**

Класс LinkedHashSet расширяет класс HashSet, при этом он не добавляет никаких новых методов. Но в отличие от HashSet, LinkedHashSet поддерживает связанный список элементов множества в том порядке, в котором они были добавлены в множество. Это значит, что когда будет выполняться перебор элементов, которые помещены в объект класса LinkedHashSet, с применением итератора - элементы будут извлечены в том порядке, в каком они были добавлены (HashSet, к сожалению, такого не гарантирует).

Чтобы создать объект класса LinkedHashSet можно использовать аналогичные конструкторы, что и у HashSet.

**3. TreeSet**

Класс TreeSet представляет собой структуру данных в виде дерева, в котором все объекты хранятся в отсортированном по возрастанию порядке. TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно черное дерево для хранения элементов.

Создать объект класса TreeSet можно с помощью следующих конструкторов:

TreeSet() - создается новое пустое дерево, в котором элементы будут отсортированы в соответствии с естественным порядком его элементов(по возрастанию).

TreeSet(Collection< ? extends E> c) - создается древовидное множество, которое будет содержать элементы из передаваемой коллекции, элементы будут отсортированы в соответствии с естественным порядком его элементов(по возрастанию).

TreeSet(Comparator< ? super E> comparator) - создается новое пустое дерево, в котором элементы будут отсортированы в соответствии с передаваемым в конструктор компаратором.


Hashset - резервируют значительно больше памяти, чем нужно для хранения их элементов, поэтому их имеет смысл использовать: для множеств среднего размера (100-10000 элементов),чтобы получить более быстрые вычисления, например для хранения и работы с клиентскими заказами

LinkedHashSet можно использовать когда производительность менее критична, но порядок вставки элементов должен быть сохранен, возможно как пример множество хранящие исторические данные реквизитов компании

TreeSet - уступает в производительности предыдущим, но позволяет сортировать элементы в естественном и заданном порядке, например множество данных банковских счетов с различными полями для возможной сортировки (наименование, банковский номер, клиент и тд)

**методы интерфейса Set:**

- `boolean add(E e)` – добавляет элемент в множество и при этом возвращает true только в том случае, если такого элемента еще нет в наборе данных. Если уже такой элемент имеется в коллекции - метод вернет false и набор данных при этом не изменится. Равенство объектов определяется по методу equals()
- `boolean addAll(Collection<? extends E> c)` - добавляет все элементы из переданной коллекции в множество, если они еще не присутствуют в данном множестве. Если передаваемая коллекция также является множеством, то применение данного метода является эффективным способом объединения двух множеств.
- `Set<E> of(E ... elements)` - метод возвращает множество, в которое помещены список элементов elements типа E. 
- `boolean remove(E e)` - удаляет указанный элемент из множества, если он присутствует в нем. Метод возвращает true, если в результате вызова метода набор данных изменился, т.е. если в результате он был удален.
- `boolean removeAll(Collection<?> c)` - удаляет из множества все элементы, которые содержатся в переданной в метод коллекции. Метод возвращает true, если в результате работы метода исходное множество изменилось.
- `boolean retainAll(Collection<?> c)` - в результате работы метода во множестве сохраняются только те элементы, которые содержатся в передаваемой в метод коллекции. Если в результате работы метода исходное множество было изменено - метод вернет true.
- `default boolean removeIf(Predicate<? super E> filter)` - метод удаляет все элементы из коллекции, которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения). Если в результате работы метода множество изменилось - метод возвращает true.
- `boolean contains(E e)` – метод возвращает true, если множество содержит переданный в метод элемент e. Сравнение объектов выполняется с помощью метода equals()
- `default Stream<E> stream()` - метод возвращает последовательный поток Stream, источником которой является наше множество. 
-  `int size()` - метод возвращает целочисленное значение, и говорит нам о том, сколько элементов содержит наше множество.

Единственным способом получения элементов из набора данных является использование итератора - для этого определен следующий метод:

`Iterator<E> iterator()` – метод возвращает итератор по элементам во множестве. При этом элементы возвращаются в произвольном порядке (если только в качестве реализации интерфейса Set не используется тип коллекции, которая гарантирует определенный порядок).

[к оглавлению](#Collections-Pro)

## 12. Расскажите реализации интерфейса Map?

+ **`HashMap`** - не синхронизированная хэш-таблица (быстрая).

+ **`LinkedHashMap`** - упорядоченная хэш-таблица с порядком итерирования в порядке добавления.

+ **`TreeMap`** - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе.

![](https://habrastorage.org/r/w1560/files/40a/eca/09a/40aeca09ac1c4cc7bdbd475a3c12fd95.png)

`Hashtable` — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.

`HashMap` — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n).

`LinkedHashMap` — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция.

`TreeMap` — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.

`WeakHashMap` — реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок.


+ **`HashMap`** - основан на хэш-таблицах. Ключи и значения могут быть любых типов, в том числе и `null`. 
Данная реализация не дает гарантий относительно порядка элементов

+ **`LinkedHashMap`** - расширяет класс **`HashMap`**. 
Он создает связный список элементов в карте, расположенных в том порядке, в котором они вставлялись.

+ **`TreeMap`** - Он создает коллекцию, которая для хранения элементов применяет дерево. 
Объекты сохраняются в отсортированном порядке по возрастанию. 
Время доступа и извлечения элементов достаточно мало, что делает класс `TreeMap` отличным выбором для хранения 
больших объемов отсортированной информации

[к оглавлению](#Collections-Pro)

## 13. Отличие ArrayList от LinkedList?

**Ответ 1**

**`ArrayList` - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**`LinkedList` - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же ArrayList предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

- ---------------------------------------------------------------------------------

**Ответ 2**

в основе реализации этого класса лежит массив. Но при этом ArrayList позволяет справиться с самой важной проблемой массивов – неизменяемость размера массива. Это значит, что ArrayList может менять свой размер во время исполнения программы и при этом нет строгого требования указывать размерность при создании объекта ArrayList. 


`некоторые выводы по ArrayList:`

- быстрый доступ к элементам по индексу (O(1));

- доступ к элементам по значению за линейное время (O(n));

- реализации вставки и удаления элементов из "середины" списка - достаточно медленные и тяжелые;

- допускается хранение любых значений, в том числе и null (при этом null элементы и пустые ячейки разные вещи);

- размер списка это количество элементов в нем, а не размер внутреннего массива


`некоторые выводы по реализации LinkedList:`

1. Позволяет хранить любые данные, в том числе null и дубликаты.

2. Обеспечивает быстрое (O(1)) добавление и удаление первого и последнего элемента. Также быстро выполняются операции вставки и удаления элементов в середину списка(выносим за скобки поиск позиции элемента, который осуществляется за линейное время).

3. Поиск элемента по значению и индексу осуществляется за линейное время (O(n)).


Рассмотрим разницу на 3 методах: добавление, добавление по индексу, удаление

Add()

**ArrayList**

1. 
```java
public boolean add(E e) {
    modCount++;
    add(e, elementData, size);
    return true;
}
```

2. если кол-во эл-ов коллекции(s == size) равно размеру массива, то происходит расширение. В методе grow() происходит "тяжелая" операция по перекопированию значений из старого массива в новый. `return elementData = Arrays.copyOf(elementData, newCapacity);`
 --> `System.arraycopy(original, 0, copy, 0,Math.min(original.length, newLength));`
   
```java
private void add(E e, Object[] elementData, int s) {
    if (s == elementData.length)
        elementData = grow();
    elementData[s] = e;
    size = s + 1;
}
```

3. 



https://habr.com/ru/articles/337558/

https://job4j.ru/profile/exercise/4/task-view/809

https://job4j.ru/profile/exercise/4/task/810/356795

[к оглавлению](#Collections-Pro)

## 14. Отличие Set от List?

+ **`Set`** - множество, не хранит дубликаты.

**Set** - представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество».

+ **`List`** - список, может содержать дубли.

Реализации интерфейса **List** представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).

[к оглавлению](#Collections-Pro)

## 13. Расскажите про методы Object hashCode и equals?

Метод `hashCode()` используется для числового представления объекта, метод `equals()` для сравнения двух объектов.
При переопределении метода `equals()` всегда переопределяют `hashCode()`.
Если метод `equals()` возвращает `true`, то `hashCode()` всегда равны, но не наоборот, потому что 
возможны коллизии, когда для разных объектов будет одинаковый `hashCode()`. *"Множество объектов мощнее множества хеш-кодов."* 
Множество возможных хеш-кодов ограничено диапазоном примитивного типа `int` `2^32`, а множество объектов ничем не ограничено. 
    
**Метод `equals()` переопределяется так:** 
1. Не равны ли ссылки.
2. Не равен `null`.
3. Проверяем что объекты от одного класса.
4. Не равны ли `hashCode`.
5. Не равны состояния полей.
    
**Метод `hashCode()` переопределяется так:**
1. Простое нечетное число (31 популярно).
2. Умножаем результат на другое простое нечетное число (популярно 17).
прибавляем хэш-код поля, которое относится к бизнес логике.
3. Повторяем пункт 2 пока не кончатся поля которые относятся к бизнес-логике.

https://javarush.com/groups/posts/2496-podrobnihy-razbor-klassa-hashmap

https://job4j.ru/profile/exercise/42/task-view/289

[к оглавлению](#Collections-Pro)

## 14. Расскажите про реализации Map?



[к оглавлению](#Collections-Pro)

## 15. Расскажите, что такое коллизии в Map Как с ними бороться?

**Хеширование** — преобразование массива входных данных произвольной длины в (выходную) битовую строку установленной длины, 
выполняемое по определенному алгоритму. Функция, воплощающая этот алгоритм и выполняющая преобразование, 
называется хеш-функцией. Хеш-код - это результат вычисления хеш-функции. 

Коллизия - это ситуация, когда не эквивалентные элементы имеют одинаковые хеш-коды. Возникает оттого, что количество 
значений хеш-функций меньше (ограничены диапазоном значений типа `int 2^32`), чем вариантов исходных данных. 
Вероятность возникновения коллизий оценивает качество хеш-функций.

В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине 
превышает определенное значение, данная корзина переходит от использования связного списка к использованию 
сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок. 
Т.е. при использовании данных типа `int` или `double` имеет смысл переходить к дереву поиска, а при использовании 
каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс. 
Такой подход позволяет улучшить производительность с `O(n)` до `O(log(n))`. 
Данный способ используется в таких коллекциях как `HashMap`, `LinkedHashMap` и `ConcurrentHashMap`.

По простому:

**Коллизия** - это когда для двух объектов вычисляется одинаковый хеш-код.
 
Решение: проверить методом `equals()`, что ссылки на объекты не равны. 
Для хэш-таблицы в ту же ячейку добавляется еще один объект, за счет того что каждая ячейка - это связанный список.

[к оглавлению](#Collections-Pro)

## 16. Расскажите что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма. 
Эффективность алгоритма оценивается его временной сложностью.

Временная сложность алгоритма – это функция, позволяющая определить, 
как быстро увеличивается время работы алгоритма с увеличением объёма данных.

Наиболее часто встречающиеся классы сложности:
+ `O(1)` – константная сложность (т.е. константное время);
+ `О(n)` – линейная сложность;
+ `О(nа)` – полиномиальная сложность;
+ `О(log(n))` – логарифмическая сложность;
+ `O(n*log(n))` – квазилинейная сложность;
+ `O(2n)` – экспоненциальная сложность;
+ `O(n!)` – факториальная сложность.

[к оглавлению](#Collections-Pro)

## 17. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций С чем связаны отличия?

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/pro_2.png)

+ **`ArrayList`:** индекс - `O(1)`, поиск `O(n)`, вставка `O(n)`, удаление `O(n)`.

+ **`LinkedList`:** индекс - `O(n)`, поиск `O(n)`, вставка `O(1)`, удаление `O(1)`.

+ **Деревья** для всех операций - `O(log(n))`.

+ **Хэш таблицы** для всех операций - `O(1)`, если не считать коллизии.

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Pro)

## 18. Расскажите реализации данных очередей и стеков?

+ **`Queue` (FIFO)** - одностороняя очередь, элементы можно получить в том порядке в котором добавляли.

+ **`Dequeue`** - двусторонняя очередь, можно вставлять/получать элементы из начала и конца. 

+ **`Stack` (LIFO)** - стек, можно получить только последний элемент.

```
Queue<Integer> myQ = new LinkedList<Integer>();
```

[к оглавлению](#Collections-Pro)

## 19. Расскажите про реализации деревьев?

+ **`TreeMap`** - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в конструкторе. 
Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты дерева от числа узлов.

+ **`TreeSet`** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию хеш-кодов. 
Можно управлять порядком при помощи компаратора.

[к оглавлению](#Collections-Pro)

## 20. Что такое loadFactor?

**loadFactor** - это коэффициент загрузки, равен соотношению `(размер коллекции / колличество элементов)`. 
При достижении порогового значения размер коллекции увеличивается.

Например, в хеш-таблице поле, которое показывает на сколько заполнен массив, на котором эта таблица основана. 
Если на 3/4, то создается новый массив с большим размером и данные перераспределяются. 

[к оглавлению](#Collections-Pro)

## 21. Пример какова сложность поиска значения по ключу?

**Пример:** разработчик создал класс
```java
class User {
    private int age;
    private String name;
    private String email;

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    User user = (User) o;
    return age == user.age &&
    Objects.equals(name, user.name) &&
    Objects.equals(email, user.email);
}

@Override
public int hashCode() {
    return 1;
}
```
и затем создал 60 разных объектов которые использовал в качестве ключа в мапе
какова сложность поиска значения по ключу в таком случае и почему
java >= 1.8

**Ответ:**
Хеш-код у нас константа - худший вариант, т.е. все объекты находятся в одном бакете и хеш-таблица превращается в связный 
список со сложностью поиска `О(n)`. Т.к. версия java >= 1.8 то, когда количество элементов в бакете достигает 
определенной величины (`TREEIFY_THRESHOLD = 8`), вместо связанного списка используется сбалансированное дерево. 
Соответственно у нас `n=60 > 8`.

Поэтому в данном случае временная сложность поиска по ключу составит `О(log(n))`.

[к оглавлению](#Collections-Pro)

## 22. Расскажите правило для переопределения метода hashCode?

Необходимо перекрывать `hashCode` каждый раз, когда выполняется перекрытие `equals`, иначе программа может работать неправильно. 
Метод `hashCode` должен подчиняться общему контракту, определенному в `Object`, и выполнять разумную работу по назначению 
неравным экземплярам разных значений хеш-кодов. 

Главным условием при перекрытии метода `hashCode`: равные объекты должны давать одинаковый хеш-код. 
Два различных экземпляра с точки зрения метода `equals` могут быть логически эквивалентными, 
однако для метода `hashCode` класса `Object` оказаться всего лишь двумя объектами, не имеющими между собой ничего общего.

1. Объявить переменную типа `int` с именем `result` и инициализировать ее хеш-кодом с (identity hash code) 
для первого значащего поля объекта.

2. Для каждого из остальных значащих полей нужно:

    а. Вычислить хеш-код с типа `int` для такого поля.

    б. Объединить хеш-код с, вычисленный в п. 2, а, с `result` следующим образом: `result = 31 * result + с;`

3. Вернуть `result`.

Примечание: Производные поля можно из вычисления хеш-кода исключить, т.е. можно игнорировать любое поле, 
значение которого может быть вычислено из полей, включаемых в вычисления. Необходимо исключить любые поля, 
которые не используются в сравнении методом `equals`, иначе есть риск нарушить второе положение контракта `hashCode`. 
Умножение в п. 2б делает результат зависящим от порядка полей и дает гораздо лучшую хеш-функцию, 
если класс имеет несколько аналогичных полей. 
Значение 31 выбрано потому, что оно является нечетным простым числом, это традиционная практика, 
кроме того повышает производительность (умножение можно заменить сдвигом и вычитанием).

[к оглавлению](#Collections-Pro)

## 23. Приведите пример переопределения hashCode?

Например, переопределим `hashCode` для класса PhoneNumber:
```java
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;
    public PhoneNumber(int areaCode, int prefix, int lineNum) {
         this . areaCode = rangeCheck (areaCode, 999, ’’area code”);
         this.prefix = rangeCheck (pref ix, 999, ’’prefix’’);
         this.lineNum = rangeCheck(lineNum, 9999, "line num”);}

   // Типичный метод hashCode
   @Override public int hashCode() {
        int result = Short.hashCode(areaCode);
        result = 31* result + Short.hashCode(prefix);
        result = 31 * result + Short.hashCode(lineNum);
        return result;}

   // Однострочный метод hashCode с посредственной производительностью. Этот стиль хеш-функции рекомендуется использовать только в ситуациях, когда производительность не является критической.
   @Override public int hashCode() {
       return Objects.hash(lineNum, prefix, areaCode);}

   // Метод hashCode с отложенной инициализацией и кешированием хеш-кода. Если класс является неизменяемым, а стоимость вычисления хеш-функции имеет значение, вы можете подумать о хранении хеш-кода в самом объекте вместо того, чтобы вычислять его заново каждый раз, когда в нем появится необходимость.
   private int hashCode; // Автоматически инициализируется значением 0
  @Override public int hashCode() {
      int result = hashCode;
      if (result == 0) {
         result = Short.hashCode(areaCode);
         result =31* result + Short.hashCode(prefix) ;
         result =31* result + Short.hashCode(lineNum);
         hashCode = result;}
      return result;}

}
```

Контракт `hashCode` из спецификации `Object`:

+ Во время выполнения приложения при многократном вызове для одного и того же объекта метод `hashCode` 
должен всегда возвращать одно и то же целое число при условии, что никакая информация, 
используемая при сравнении этого объекта с другими методом equals, не изменилась. 
Однако не требуется, чтобы это же значение оставалось тем же при другом выполнении приложения.

+ Если два объекта равны согласно результату работы `equals(Object)`, то при вызове для каждого из них метода 
`hashCode` должны получиться одинаковые целочисленные значения.

+ Если метод `equals(Object)` утверждает, что два объекта не равны один другому, это не означает, что метод `hashCode` 
возвратит для них разные числа. Однако программист должен понимать, что генерация разных чисел для неравных 
объектов может повысить производительность хеш-таблиц.

[к оглавлению](#Collections-Pro)

## 24. Как вычисляется hash функция от объекта в HashMap?

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
в методе `hash()` cначала вычисляется промежуточное значение `h`, 
оно равно хеш-функции от ключа (для `HashMap` в базовой реализации `Object.hashCode()`), 
затем вычисляется значение, равное нулевому побитовому сдвигу числа `h` вправо на 16 бит с заполнением нулями 
(`>>>` все биты числа сдвигаются вправо на 16 позиций, освободившиеся биты заполняются нулями), 
и для вычисленных выше значений выполняется операция `XOR` (^ побитовое логическое или).

В методе коллекции, при поиске бакета/корзины/индекса хеш-код ключа делится с остатком (`%`) на размер хеш-таблицы 
(по умолчанию `n=16`) и результатом будет число в диапазоне от `0` до `n`, 
т.е. номер ячейки в массиве, куда помещается объект с нашим ключом. 
А т.к. для `HashMap` размер хеш-таблицы равен степени 2, то вместо `%n` (остатка от деления) 
используется более быстрый `&(n-1)` (побитовое И).

Т.е. вместо `index = hash % (n - 1)` используется `index = (n - 1) & hash`

Примечание: побитовый сдвиг `>>>` и операция `XOR` выполняются для того, 
чтобы старшие биты первоначального хеш-кода `h` в дальнейшем участвовали в `(n - 1) & hash` даже при небольшом кол-ве бакетов. 
Этим обеспечивают не само по себе наилучшее распределение в хеш-таблице, а страхуются от неудачной функции `hashcode()`.

**Итого:** Через `%` или `&` вычисляется "внешний" `hash` (находим бакет/корзину/индекс в массиве),
 через `>>>` "внутренний", который отвечает за усложение хеш-кода, подключая к формированию старшие биты.

[к оглавлению](#Collections-Pro)

## 25. Правила проверки при переопределении метода equals?

**1.** Используйте оператор `==` для проверки того, что аргумент является ссылкой на данный объект. 
Если это так, возвращайте `true`. Это просто оптимизация производительности, 
которая может иметь смысл при потенциально дорогостоящем сравнении.

**2.** Используйте оператор `instanceof` для проверки того, что аргумент имеет корректный тип. 
Если это не так, возвращайте `false`. Обычно корректный тип — это тип класса, которому принадлежит данный метод. 
В некоторых случаях это может быть некоторый интерфейс, реализованный этим классом. Если класс реализует интерфейс, 
который уточняет контракт метода `equals`, то в качестве типа указывайте этот интерфейс: 
это позволит выполнять сравнение классов, реализующих этот интерфейс. 
Подобным свойством обладают интерфейсы коллекций, таких как `Set`, `List`, `Мар` и `Map. Entry`.

**3.** Приводите аргумент к корректному типу. Поскольку эта операция следует за проверкой instanceof, она гарантированно успешна.

**4.** Для каждого “важного” поля класса убедитесь, что значение этого поля в аргументе соответствует полю данного объекта. Если все тесты успешны, возвращайте true; в противном случае возвращайте false. Если в п. 2 тип определен как интерфейс, вы должны получить доступ к полям аргумента через методы интерфейса; если тип представляет собой класс, вы можете обращаться к его полям непосредственно, в зависимости от их доступности.

Пример Класс с типичным методом `equals`:
```java
public final class PhoneNumber {
   private final short areaCode, prefix, lineNum;
   public PhoneNumber(int areaCode, int prefix, int lineNum) {
      this . areaCode = rangeCheck (areaCode, 999, ’’area code”);
      this.prefix = rangeCheck (pref ix, 999, ’’prefix’’);
      this.lineNum = rangeCheck(lineNum, 9999, "line num”);}
   private static short rangeCheck(int val, int max, String arg) {
      if (val < 0 || val > max)
         throw new IllegalArgumentException (arg 4- ": "4- val);
         return (short) val;

   @Override public boolean equals(Object о) {
      if (о == this) //1
         return true;
      if (! (o instanceof PhoneNumber)) //2
         return false;

//здесь насколько понял, мы нарушаем принцип подстановки Лисков и используем следующее

      if (о == null || o.getClass() != getClass ())
         return false;


      PhoneNumber pn = (PhoneNumber)o; //3
      return pn.lineNum == lineNum && pn.prefix == prefix && pn.areaCode == areaCode; //4
      }
... 
}
```
метод `equals` имеет смысл перекрывать, когда для класса определено понятие логической эквивалентности 
(logical equality), которая не совпадает с тождественностью объектов, а в суперклассе метод equals не перекрыт. 
В общем случае это происходит с классами значений (напр. `Integer` или `String`). 
Перекрывая метод `equals`, нужно соблюдать его общий контракт.

Метод `equals` реализует отношение эквивалентности, которое обладает следующими свойствами:

+ Рефлексивность: для любой ненулевой ссылки на значение `х` выражение `х.equals(х)` должно возвращать `true`.

+ Симметричность: для любых ненулевых ссылок на значения `х` и `у` выражение `х.equals(у)` должно возвращать `true` 
тогда и только тогда, когда `у.equals(х)` возвращает `true`.

+ Транзитивность: для любых ненулевых ссылок на значения `х`, `у` и `z`, если `х.equals(у)` возвращает `true` 
и `у.equals(z)` возвращает `true`, `х.equals(z)` должно возвращать `true`.

+ Непротиворечивость: для любых ненулевых ссылок на значения `х` и `у` многократные вызовы `х.equals(у)` должны либо 
постоянно возвращать `true`, либо постоянно возвращать `false` при условии, что никакая информация, 
используемая в сравнениях `equals`, не изменяется.

+ Для любой ненулевой ссылки на значение `х` выражение `х.equals(null)` должно возвращать `false`.

[к оглавлению](#Collections-Pro)

## 26. Как устроена HashMap?

**`HashMap`** состоит из «корзин» `bucket`. С технической точки зрения бакеты — это элементы массива, которые хранят ссылки 
на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется 
номер корзины (номер ячейки массива), в которую попадет новый элемент. 

Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, 
то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, 
от которого и ставится ссылка на вновь добавленный элемент. 

Если в списке был найден элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется 
за константное время. Вроде все здорово, с одной оговоркой, хеш-функция должна равномерно распределять элементы 
по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже `lg т`, 
а в среднем случае как раз константное время.

[к оглавлению](#Collections-Pro)

## 27. Какое начальное количество корзин в HashMap?

По умолчанию в `HashMap` 16 корзин. Отвечая, стоит заметить, что можно используя конструкторы с параметрами: 
через параметр `capacity` задавать свое начальное количество корзин

[к оглавлению](#Collections-Pro)

## 28. Какая оценка временной сложности выборки элемента из HashMap Гарантирует ли HashMap указанную сложность выборки элемента?

Если вы возьмете хеш-функцию, которая постоянно будет возвращать одно и то же значение, то `HashMap` превратится 
в связный список, с низкой производительностью.
 
Если вы будете использовать хеш-функцию с равномерным распределением, в предельном случае гарантироваться будет только 
временная сложность `lg n`. Так что, ответ на вторую часть вопроса — нет, не гарантируется.

[к оглавлению](#Collections-Pro)

## 29. Роль equals и hashCode в HashMap?

`hashCode` позволяет определить корзину для поиска элемента, а `equals` используется для сравнения ключей элементов 
в списке внутри корзины и искомого ключа.

[к оглавлению](#Collections-Pro)

## 30. Как и когда происходит увеличение количества корзин в HashMap?

Помимо `capacity` в `HashMap` есть еще параметр `loadFactor`, на основании которого, вычисляется предельное количество 
занятых корзин (`capacity*loadFactor`). По умолчанию `loadFactor = 0,75`. По достижению предельного значения, 
число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение» с учетом нового 
числа корзин.

[к оглавлению](#Collections-Pro)

## 31. Как работает HashMap?

HashMap has an inner class **Entry**:
```java
static class Entry<K ,V> implements Map.Entry<K, V> {
	final K key;
	V value;
	Entry<K ,V> next;
	final int hash;
}
```
**How HashMap.put() methods works:**

transient Entry[] table;		
1. First of all, the key object is checked for null. If the key is null, the value is stored in table[0] position. 
Because hashcode for null is always 0. 
2. Then on next step, a hash value is calculated using the key’s hash code by calling its hashCode() method. 
This hash value is used to calculate the index in the array for storing Entry object. 
JDK designers well assumed that there might be some poorly written hashCode() functions that can return very high or low hash code value.
To solve this issue, they introduced another hash() function and passed the object’s hash code to this hash() function 
to bring hash value in the range of array index size.
3. Now indexFor(hash, table.length) function is called to calculate exact index position for storing the Entry object.

**How collisions are resolved:**

as we know that two unequal objects can have the same hash code value, 
how two different objects will be stored in same array location called bucket.
The answer is LinkedList. If you remember, Entry class had an attribute "next". 
This attribute always points to the next object in the chain. This is exactly the behavior of LinkedList.

1. So, in case of collision, Entry objects are stored in linked list form. 
When an Entry object needs to be stored in particular index, HashMap checks whether there is already an entry?? 
If there is no entry already present, the entry object is stored in this location. 
If there is already an object sitting on calculated index, its next attribute is checked. 
If it is null, and current entry object becomes next node in linkedlist. 
If next variable is not null, procedure is followed until next is evaluated as null.

2. What if we add the another value object with same key as entered before. 
Logically, it should replace the old value. How it is done? Well, after determining the index position of Entry object, 
while iterating over linkedist on calculated index, HashMap calls equals method on key object for each entry object.

All these entry objects in linkedlist will have similar hashcode but equals() method will test for true equality. 
If key.equals(k) will be true then both keys are treated as same key object. 
This will cause the replacing of value object inside entry object only.

How HashMap.get() methods works:
```java
public V get(Object key) {
    if (key == null)
    return getForNullKey();
    int hash = hash(key.hashCode());
    for (Entry<K , V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {
		Object k;
		if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
			return e.value;
		}
		return null;
	}
}
```

[к оглавлению](#Collections-Pro)

## 32. Что такое хеш таблицы?

Хеш-таблицей называется структура данных, обеспечивающая очень быструю вставку и поиск. 
У хеш-таблиц также имеются свои недостатки. Они реализуются на базе массивов, а массивы трудно расширить после создания. 
У некоторых разновидностей хеш-таблиц быстродействие катастрофически падает при заполнении таблицы, 
поэтому программист должен довольно точно представлять, сколько элементов данных будет храниться в таблице 
(или приготовиться к периодическому перемещению данных в другую хеш-таблицу большего 
размера — процесс занимает довольно много времени).

Кроме того, при работе с хеш-таблицами не существует удобного способа перебора элементов в определенном 
порядке (скажем, от меньших к большим). Если вам необходима такая возможность, поищите другую структуру данных.

[к оглавлению](#Collections-Pro)

## 33. Что такое красно-черное дерево?

Красно-черные деревья относятся к сбалансированным бинарным деревьям поиска.
Как бинарное дерево, красно-черное обладает свойствами:

1) Оба поддерева являются бинарными деревьями поиска.

2) **Для каждого узла с ключом K выполняется критерий упорядочения:
ключи всех левых потомков <= K < ключи всех правых потомков**
(в других определениях дубликаты должны располагаться с правой стороны либо вообще отсутствовать). 
Это неравенство должно быть истинным для всех потомков узла, а не только его дочерних узлов.

Свойства красно-черных деревьев:
1) Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета).
2) Корень окрашен в черный цвет.
3) Листья(так называемые null-узлы) окрашены в черный цвет.
4) Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные 
дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные.
5) Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).

Красно-черные деревья: коротко и ясно https://habr.com/ru/post/330644/

[к оглавлению](#Collections-Pro)

## 34. Удаление элемента из дерева?

Если у удаляемого элемента нет потомков или один потомок, то удаленить просто. 
Если у удаляемого элемента есть два потомка, то удаляемый узел надо заменить на приемника. 
Т.к. используется сложный алгоритм для поиска приемника, то часто вместо удаления используют флаг `isDeleted`. 
В остальных методах проверяют значение этого флага.

[к оглавлению](#Collections-Pro)

## 35. Какие существуют алгоритмы обхода дерева?

В зависимости от траекторий выделяют два типа обхода:
+ горизонтальный (в ширину)
+ вертикальный (в глубину).

 **Горизонтальный** обход подразумевает обход дерева по уровням (level-ordered) – вначале обрабатываются все узлы 
текущего уровня, после чего осуществляется переход на нижний уровень.

```java
static void contLevelOrder(Node top) {
    Queue<Node> queue=new LinkedList<> ();
        do {
            top.treatment();
            if (top.left!=null) queue.add(top.left);
            if (top.right!=null) queue.add(top.right);
            if (!queue.isEmpty()) top=queue.poll();
    } while (!queue.isEmpty());
}
```
    
**Вертикальный** бывает 3 видов:
+ прямой (preorder)
    1. Посещение узла.
    2. Вызов самого себя для обхода левого поддерева узла.
    3. Вызов самого себя для обхода правого поддерева узла

+ симметричный (inorder). При симметричном обходе двоичного дерева все узлы перебираются в порядке возрастания ключей.
Простейший способ обхода основан на использовании рекурсии. 
Метод должен выполнить только три операции:
    1. Вызов самого себя для обхода левого поддерева узла.
    2. Посещение узла.
    3. Вызов самого себя для обхода правого поддерева узла. 
```java
private void inOrder(node localRoot) {
     if(localRoot != null) {
          inOrder(localRoot.leftChild);
          console.log(node.value);
          inOrder(localRoot.rightChild);
     }
}        
```

+ обратный (postorder)
    1. Вызов самого себя для обхода левого поддерева узла.
    2. Вызов самого себя для обхода правого поддерева узла.
    3. Посещение узла.

[к оглавлению](#Collections-Pro)

## Источники:

**Generics** 

https://docs.oracle.com/javase/tutorial/java/generics/why.html

Пришел, увидел, обобщил: погружаемся в Java Generics 
https://habr.com/ru/company/sberbank/blog/416413/

Generics в Java 1.5
http://rsdn.org/article/java/genericsinjava.xml#EQNAC

Дженерики (Generics) в java 
https://www.fandroid.info/dzheneriki-generics-v-java/

Использование generic wildcards для повышения удобства Java API 
https://habr.com/ru/post/207360/

Примеры https://o7planning.org/ru/10403/java-generics-tutorial

Александр Маторин — Неочевидные Дженерики https://www.youtube.com/watch?v=_0c9Fd9FacU

Введение в Java. Generics. Wildcards | Технострим https://www.youtube.com/watch?v=FRmgcBxJvb4

Advanced Java - Generics https://www.youtube.com/playlist?list=PL6jg6AGdCNaX1yIJpX4sgALBTmTVc_uOJ

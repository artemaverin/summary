## Collections Light

+ [Что такое “коллекция”](#Что-такое-коллекция)
+ [Перечислите основные методы из интерфейса java.util.Collection.](#Перечислите-основные-методы-из-интерфейса-Collection)
+ [Назовите преимущества использования коллекций](#Назовите-преимущества-использования-коллекций)
+ [Какие данные могут хранить коллекции?](#Какие-данные-могут-хранить-коллекции)
+ [Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.](#Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций-List-Set-Map)
+ [Назовите основные реализации List, Set, Map](#Назовите-основные-реализации-List-Set-Map)
+ [В чём отличие ArrayList от LinkedList?](#В-чём-отличие-ArrayList-от-LinkedList)
+ [В чём отличие HashSet от TreeSet?](#В-чём-отличие-HashSet-от-TreeSet)
+ [В чём отличие Set от Map?](#В-чём-отличие-Set-от-Map)
+ [Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#Как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию)
+ [Чем отличается Comparable от Comparator?](#Чем-отличается-Comparable-от-Comparator)
+ [Что такое сортировка по принципу Natural Order?](#Что-такое-сортировка-по-принципу-Natural-Order)
+ [Что такое equals и hashcode?](#Что-такое-equals-и-hashcode)
+ [Какие есть способы перебора всех элементов List?](#Какие-есть-способы-перебора-всех-элементов-List)
+ [Расскажите о методах Map](#Расскажите-о-методах-Map)
+ [Расскажите, какие классы реализовывают интерфейс Map?](#Расскажите-какие-классы-реализовывают-интерфейс-Map)
+ [Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#Расскажите-о-методах-keySet-и-entrySet-Что-такое-Entry)
+ [Что будет если вызвать метод map.put несколько раз с одинаковым ключом?](#Что-будет-если-вызвать-метод-put-несколько-раз-с-одинаковым-ключом)
+ [Как реализован цикл foreach?](#Как-реализован-цикл-foreach)
+ [В чем разница между Iterator и ListIterator?](#В-чем-разница-между-Iterator-и-ListIterator)
+ [Как происходит удаление элементов из ArrayList?](#Как-происходит-удаление-элементов-из-ArrayList)
+ [Как происходит удаление элементов из LinkedList?](#Как-происходит-удаление-элементов-из-LinkedList)
+ [Что такое автоупаковка и распаковка? Зачем они нужны?](#Что-такое-автоупаковка-и-распаковка-Зачем-они-нужны)
+ [В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)
+ [Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток](#Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)
+ [Что такое очередь? Расскажите принцип работы и для чего она используется.](#Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется)
+ [Расскажите про интерфейсы Queue, Deque и их иерархию.](#Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию)
+ [В чем отличие метода poll() от remove()?](#В-чем-отличие-метода-poll()-от-remove-())
+ [В чем отличие метода element() от peek()?](#В-чем-отличие-метода-element()-от-peek-())
+ [В чем отличие метода element() от poll()?](#В-чем-отличие-метода-element()-от-poll-())
+ [Перечислите наиболее часто используемые реализации интерфейса Queue.](#Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue)
+ [Что такое ограниченные и неограниченные очереди?](#Что-такое-ограниченные-и-неограниченные-очереди)
+ [Что такой односторонние и двусторонние очереди?](#Что-такой-односторонние-и-двусторонние-очереди)
+ [В чём отличие Deque от Queue?](#В-чём-отличие-Deque-от-Queue)
+ [В чём отличие методов removeLast() и pollLast()?](#В-чём-отличие-методов-removeLast-и-pollLast)
+ [Назовите самую распространенную реализацию Deque](#Назовите-самую-распространенную-реализацию-Deque)

## Что такое “коллекция”.
Это хранилища, поддержиающие различные способы накопения и упорядочивания объектов
с целью обеспечения возможностей эффективного доступа к ним.
Это классы, объекты которых реализуют различные способы хранения данных.

Коллекции = оптимизированные структуры данных, которые описывают легкие способы работы с данными.

**Java Collection Framework** – это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам пользоваться большим количеством структур для хранения набора данных.

[к оглавлению](#collections-light)

## Перечислите основные методы из интерфейса Collection

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (CRUD – сокращение от слов create, read, update and delete). На уровне Collection не существует способа обновить запись в коллекции, поэтому рассмотрим остальные возможности – добавить, прочитать и удалить. 

**1. Методы для добавления элементов:**

**boolean add(E e)** – метод добавляет элемент в коллекцию и возвращает true если добавление выполнено успешно.

**boolean addAll(Collection < ? extends E> c)** – метод добавляет все элементы переданной в метод коллекции в коллекцию, у которой был вызван этот метод. Метод возвращает true если коллекция, у которой был вызван метод, изменилась.

**2. Чтение элементов из коллекции.**

Единственный способ, который определен на уровне Collection для чтения элементов из коллекции – это использовать итератор, на основе которого работает улучшенный цикл for или цикл for-each.

Iterator< E > iterator() – метод возвращает объект Iterator, который позволяет проходить по элементам нашей коллекции.

**3. Удаление элементов.**

boolean remove(Object o) – метод удаляет объект, который мы передали в метод, и возвращает true, если удаление успешно, т.е. коллекция изменилась.

boolean removeAll(Collection< ?> c) – метод удаляет все элементы из коллекции, у которой был вызван этот метод, и которые также содержатся в переданной в метод коллекции. Таким образом после вызова этого метода в коллекции не будет тех элементов, которые содержатся в переданной в метод коллекции.

boolean retainAll(Collection< ?> c) – метод, который позволяет сохранить в коллекции только те элементы, которые содержатся в коллекции, которая была передана в метод. Таким образом в результате в коллекции останутся только те элементы, которые представлены в обоих коллекциях.

**4. Вспомогательные методы.**

Обсудим вспомогательные методы, которые находят свое частое использование.

int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

Для того чтобы проверить есть какой-либо элемент в коллекции можно использовать метод contains()

boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

Чтобы очистить содержимое коллекции можно использовать метод:

void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

Коллекцию можно преобразовать в массив, для этого можно использовать следующий метод:

Object[] toArray() – метод возвращает массив, который содержит все элементы, содержащиеся в коллекции у которой был вызван этот метод.

[к оглавлению](#collections-light)

## Назовите преимущества использования коллекций.
+ отсутствует необходимость следить за размерами коллекции (в отличае от массива)
+ в коллекциях реализовано много методов по добавлению, удалению, сортировке, которые позволяют сократить
+ количество кода и требуют меньше усилий для реалезации
+ если правильно подобрать коллекцию то можно увеличить производительность программы.

 оптимизированные структуры данных, которые описывают легкие способы работы с данными и при правильном выборе коллекции мы можем ускорить работу нашего приложения.

[к оглавлению](#collections-light)

## Какие данные могут хранить коллекции?
Любые ссылочные типы данных.

[к оглавлению](#collections-light)

## Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map

**Collection** – этот интерфейс определен в JDK с версии 1.2 и описывает основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (к примеру size(), isEmpty(), add(E e) и т.д.). Интерфейс несколько был доработан с появлением generic в версии 1.5. В версии Java 8 было добавлено несколько новых методов для работы с лямбдами и Stream (например, stream(), parallelStream() и т.д.)

**Map** – этот интерфейс также находится в составе JDK с версии 1.2 и предоставляет программисту базовые методы для работы с данными вида «ключ-значение». По аналогии с Collection этот интерфейс был дополнен generic в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые часто реализовывались в логике приложения (getOrDefault(), putIFAbsent()).

+ **Set** - Множество. (Здесь могут храниться только уникальные значения, нет дубликатов)
+ **Queue (Deque)** - Очередь. FIFO (Первый вошел, первый вышел). реализуется LinkedList'ом
+ **List** - Упорядоченное хранение данных. (В какой последовательности данные положили, в такой они и хранятся)
+ **Map** - (от Collection он не наследуется) Значения хранятся как пара - ключ-значение. и по ключу получаем значение.
у мапы нету итератора

![imageTaskSource (1)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https:%2F%2Fblog.kakaocdn.net%2Fdn%2FlkxJ0%2FbtqPRAqajRU%2FZC2AOKKkiwQkBkYskMsNVk%2Fimg.png)

[к оглавлению](#collections-light)

## Назовите основные реализации List, Set, Map.
+ **List**: ArrayList, LinkedList
+ **Set**: HashSet, LinkedHashSat, TreeSet
+ **Map**: HashMap, LinkedHashMap, TreeMap

[к оглавлению](#collections-light)

## В чём отличие ArrayList от LinkedList?

**Ответ 1**

**ArrayList** реализован на массивах. (используют если чаще читаются элементы, чем добавляются)
Хранит свои элементы в массиве.
+ \+ осуществляется быстрый поиск элементов.
+ \+ меньше расхходует памятина хранение элементов
+ \- увеличение ArrayList'a происходит медленно.
+ \- при вставке элемента (или удалении) в середину или в начало, приходится переписывать все элементы.

**LinkedList** является представителем двунаправленного списка. (цепочка) 
(используется если элементы чаще добавляются чем читаются)
Хранит свои элементы в обектах у которых есть ссылки на предыдущий и следующий элементы.
+ \+ быстрая вставка и удаление в середину списка (переписать next и prev и всё)
+ \- долгий поиск в середине (нужно перебрать все элементы)

в среднем, сложности одинаковые. Но я бы не стал рекомендовать использовать LinkedList,
за исключением ситуации когда, преобладает удаление или вставка в начало или конец списка.

**Ответ 2**
ArrayList - это список на основе массива. LinkedList - связанный список на основе элементов и связи между ними. В качестве LinkedList лучше всего подходит представление вагонов поезда сцепленных последовательно.

ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того в ArrayList нет дополнительных расходов на хранение связки между элементами. Минусы в скорости вставки/удаления элементов находящихся не в конце списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.

LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за константное время. Операции доступа по индексу производятся перебором с начала или конца (смотря что ближе) до нужного элемента. Дополнительные затраты на хранение связки между элементами.
Одним словом - если часто вставляете/удаляете - выбирайте в пользу LinkedList, в противном случае ArrayList

[к оглавлению](#collections-light)

## В чём отличие HashSet от TreeSet?
+ **HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи HashMap, Порядок добавления элементов вычисляется с помощью хэш-кода;).
+ **TreeSet** хранит данные в отсортированном виде (бинарное дерево).

https://javarush.com/groups/posts/2147-hashset-v-java


[к оглавлению](#collections-light)

## В чём отличие Set от Map?
сет это список ключей от мапы.

в карте может обратиться через ключе *get(Object key)* , в множестве вывод только через итератор 

![image](https://github.com/artemaverin/summary/assets/97846877/e33f4d49-9547-40d3-b9e7-da9d6e4bab28)


[к оглавлению](#collections-light)

## Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
Порядок задается либо естественным следованием элементов (natural order), 
либо объектом, реализующим интерфейс сравнения `Comparator`.

Можно отсортировать с помощью интерфейса `Comparable` или интерфейса `Comparator`:
 
+ Если объекты коллекции поддерживают интерфейс `Comparable`, то через `Collections.sort(collection)`; 

+ Если нет, то у Collection вызвать метод `sort()` и передать ему `Comparator` в качестве аргумента `collection.sort(new MyComparator())`.
Либо использовать метод `Collections.sort(collection, new MyComparator())`.

Comparable - реализуется внутри класса. По сути, определяет обычный/естественный порядок сравнения объектов.

Comparator - реализуется вне класса. Можно реализовать различные варианты сортировки, основанные на сравнении различных полей.

[к оглавлению](#collections-light)

## Чем отличается Comparable от Comparator?
**Comparable** - используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
Т.е. интерфейс `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей 
реализации (по правилам разработчика). 
`Collections.sort(collection);`

**Comparator** - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
Т.е. интерфейс `Comparator` позволяет создавать объекты, которые будут управлять процессом сравнения: 
1. при сортировках в методах `Collections.sort(collection, new MyComparator())`, `Arrays.sort(array, new MyComparator())` 
или `collection.sort(new MyComparator())`
2. при управлении порядком в отсортированных множествах `TreeSet` или отсортированных картах `TreeMap`,
 например `new TreeSet<T> (new MyComparator())`.

**Разница:**

+ `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации 
и, если нет доступа к исходникам, ее невозможно изменить. 

+ `Comparator` позволает определить логику сравнения объектов определенного ссылочного типа вне реализации 
этого типа и эту логику можно в любой момент подменить.

*`Comparable` используется для `natural ordering`, а `Comparator` для `total ordering`.*

**Примеры:**

http://java-online.ru/blog-comparator.xhtml

https://netjs.blogspot.com/2015/10/difference-between-comparable-and-comparator-java.html

https://www.programcreek.com/2011/12/examples-to-demonstrate-comparable-vs-comparator-in-java/

[к оглавлению](#collections-light)

## Что такое сортировка по принципу Natural Order?
Некоторые классы из коробки реализуют естественный порядок для сортировки.
+ Это строки - лексикографический (по алфавиту),
+ числа - числовой, знаковый или без (больше меньше),
+ дата - хронологичский (по датам),
+ файл - лексикографический по имени пути
+ boolean - false < true

Остальные классы нужно руками делать Comparable или Comparator.

[к оглавлению](#collections-light)

## Что такое equals и hashcode?
Методы, необходимые для определения равенства объектов. 

`hashcode` возвращает число, являющееся уникальным идентификатором объекта. 
Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
 
`equals` сравнивает объекты по значению их полей. 

Главные правила для любых реализаций этих двух методов, которые нужно обязательно соблюдать, запомнить как аксиому:

1). Если x.equals(y) == true, то обязательно hashcode(x) == hashcode(y)

2) Если hashcode(x) == hashcode(y), то не обязательно x.equals(y) == true

Сперва производится сравнение по хешу, чтобы понять, совпадают ли объекты, а только после подключается equals , чтобы определить, совпадают ли значения полей объекта.

Объекты всех коллекций в названии которых есть *Hash...* должны иметь `hashcode` и `equals`.
[к оглавлению](#collections-light)

## Какие есть способы перебора всех элементов List?
Есть список стран, его нужно перебрать
```java
List<String> countries = Arrays.asList("Russia", "Panama", "Australia");
```
+ **циклы** `for`, `while`, `foreach`

```java
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
```

```java
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
```

```java
for (String country : countries) {
    System.out.println(country);
}    
```

+ **итераторы** `Iterator`, `ListIterator`
```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

```java
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}    
```
Если вызвать метод `next()` итератора, указывающего на последний элемент в коллекции, 
то возникнет исключение `NoSuchElementException`. Следует это помнить и использовать метод `hasNext()` перед вызовом `next()`.

+ **функция `forEach()`** 
    
    + **`Iterable.forEach()`** можно использовать для итерации по элементам списка начиная с Java 8. 
Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
    ```java
    countries.forEach(System.out::println);
    ```
    
    + **`Stream.forEach()`** Мы также можем преобразовать коллекцию значений в поток и получить доступ 
    к таким операциям, как `forEach()`, `map()`, или `filter()`.
    ```java
    countries.stream().forEach(
        (c) -> System.out.println(c)
    );
    ```
    
https://www.codeflow.site/ru/article/java-iterate-list    

[к оглавлению](#collections-lite)

## Расскажите о методах Map

CRUD
+ V put(K k, V v): помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null
+ V get(Object k): возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null
+ Set< K> keySet(): возвращает набор всех ключей отображения
+ Set<Map.Entry<K, V>> entrySet(): возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
+ V remove(Object k): удаляет объект с ключом k

Некоторый другие:
+ void clear(): очищает коллекцию
+ boolean containsKey(Object k): возвращает true, если коллекция содержит ключ k
+ boolean containsValue(Object v): возвращает true, если коллекция содержит значение v
+ boolean isEmpty: возвращает true, если коллекция пуста
+ V putIfAbsent(K k, V v): помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.
+ void putAll(Map< ? extends K, ? extends V> map): добавляет в коллекцию все объекты из отображения map
+ int size(): возвращает количество элементов коллекции
	
https://job4j.ru/profile/exercise/29/task-view/220

https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html

[к оглавлению](#collections-lite)

## Расскажите, какие классы реализовывают интерфейс Map?

Map является интерфейсом, и в стандартном jdk содержит основные реализации: Hashmap, LinkedHashMap, Hashtable, TreeMap. Самая используемая реализация — Hashmap

**разница между HashMap, TreeMap, и Hashtable**

Как упоминалось ранее, существуют 3 основные реализации интерфейса Map. У каждой из них есть свои особенности:
- Порядок элементов. HashMap и Hashtable не гарантируют, что элементы будут храниться в порядке добавления. Кроме того, они не гарантируют, что порядок элементов не будет меняться со временем. В свою очередь, TreeMap гарантирует хранение элементов в порядке добавления или же в соответствии с заданным компаратором.

- Допустимые значения. HashMap позволяет иметь ключ и значение null, HashTable — нет. TreeMap может использовать значения null только если это позволяет компаратор. Без использования компаратора (при хранении пар в порядке добавления) значение null не допускается.

- Синхронизация. Только HashTable синхронизирована, остальные — нет. Если к мапе не будут обращаться разные потоки, рекомендуется использовать HashMap вместо HashTable.

![image](https://github.com/artemaverin/summary/assets/97846877/9af409e4-f42c-44f2-b8d4-e90f8ec44871)

**HashMap**
Реализация основана на хэш-таблицах, реализует интерфейс Map. Ключи и значения могут быть любых типов, в том числе и null.
Данная реализация не дает гарантий относительно порядка элементов.

**LinkedHashMap**
Реализация расширяет класс HashMap.
Класс создает связный список элементов в карте, расположенных в том порядке, в котором они вставлялись. Это позволяет организовать перебор карты в порядке вставки.
То есть,когда происходит итерация по коллекционному представлению объекта класса LinkedHashMap, элементы будут возвращаться в том порядке, в котором они вставлялись.
Также можно создать объект класса LinkedHashMap, возвращающий свои элементы в том порядке, в котором к ним в последний раз осуществлялся доступ.

**TreeMap**
Красно-черное дерево реализующее интерфейс NavigableMap.
Коллекция сортируется по естественному упорядочиванию (natural ordering) ее ключей или используя интерфейс Comparator который задается при создании коллекции.
Эта имплементация гарантирует время доступа log(n) для следующих методов: containsKey, get, put, и remove

**WeakHashMap**
Основан на хэш-таблицах, реализует интерфейс Map с так называемыми слабыми ключами (weak keys). Пара в данной коллекции автоматически будет удалена когда ссылка на ключ больше нигде не используется. Другими словами, нахождение объекта представленного ключем в данной коллекции не блокирует сборщик мусора от зачистки. После того как ключ будет зачищен вся пара будет удалена из коллекции.

![](https://www.freetimelearning.com/java/uploadingimages/map-interface.png)

[к оглавлению](#collections-light)

## Расскажите о методах keySet и entrySet? Что такое Entry?

keySet() возвращает коллекцию java.util.Set состоящую только из ключей.

entrySet()  вернет коллекцию java.util.Set состоящую из объекта Map.Entry, которая сразу содержит и ключ и значение.

Если перебирать все пары карт с помощью keySet(), то производительность keySet() ниже по сравнению с entrySet(), так как для каждого ключа мы должны получить доступ к его соответствующему значению с помощью функции get().

Map.Entry – это интерфейс, который позволяет нам получить доступ к записям в словаре. Объявлен внутри java.util.Map

Поведение стандартное: можно получить ключ или значение пары, либо установить значение пары (метод setValue). При этом обратите внимание, что setValue, в отличии от канонических setter-ов, возвращает старое замененное значение.

![image](https://github.com/artemaverin/summary/assets/97846877/8e4373df-d6b0-4560-8c05-dd0093464ebd)

[к оглавлению](#collections-light)

## Что будет если вызвать метод put несколько раз с одинаковым ключом?

Если в Map уже есть такой key, то ячейка value будет заменена на новое значение.

## Как реализован цикл foreach?
Через iterator (Если коллекция экстендится от iterable, то мы можем перебирать элементы этой коллекции форичем)

```java
for (Iterator<E> i = someIterable.iterator(); i.hasNext();) {
    String item = i.next();
    System.out.println(item);
}
```

[к оглавлению](#collections-light)

## В чем разница между Iterator и ListIterator?
`ListIterator` расширяет `Iterator`, отличия следующие:

```Iterator``` а также ```ListIterator``` два важных интерфейса Java Collection Framework, где ```ListIterator``` расширяет ```Iterator``` интерфейс и предоставляет дополнительные возможности по сравнению с итератором. В этом посте представлен обзор различий между ```Iterator``` а также ```ListIterator ```интерфейс на Java:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`. `ListIterator` может быть использован только для перебора элементов коллекции `List`

+ Основное различие между `Iterator` а также `ListIteratorv` заключается в том, как они пересекают Коллекцию. С ```Iterator```, мы можем двигаться только вперед, используя его hasNext() а также next() метод в то время как с `ListIterator` мы можем перемещаться по списку в любом направлении. `ListIterator` обеспечивает hasNext() а также next() метод движения в прямом направлении и hasPrevious() а также previous() метод движения в обратном направлении.

+ The `ListIterator` позволяет нам изменять список во время итерации, используя его set() метод. Это невозможно с помощью итератора.

+ С использованием `Iterator` мы не можем получить текущую позицию итератора в списке. С другой стороны, `ListIterator` может возвращать индекс следующего или предыдущего элемента при обходе списка, используя его nextIndex() а также previousIndex(), соответственно.

+ Мы можем получить следующий элемент в списке, обходя его с помощью итератора, используя его next() метод. С ```ListIterator``` является двунаправленным, мы можем получить как предыдущий, так и следующий элементы в любой момент времени, используя его previous() а также next() метод соответственно.

+ При обходе списка с помощью ```ListIterator```, мы можем добавить новый элемент в любой момент времени, используя его add() метод. Этот метод недоступен в ```Iterator``` учебный класс.

+ Общие методы в ```Iterator``` а также ```ListIterator``` интерфейс: hasNext(), next() а также remove(). Новые методы, включенные в ```ListIterator``` интерфейс: previous()

[к оглавлению](#collections-light)

## Как происходит удаление элементов из ArrayList?
Перекидывание элемента в конец массива путем смещения всех последующих элементов, а затем уменьшение поля size на 1.

Находится заданный элемент. 
Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение `size` уменьшается на 1.

Непосредственно под капотом: 
```java
System.arraycopy(es, i + 1, es, i, newSize - i)
es[size = newSize] = null;
```
**Ответ 2**

При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево 
и реальный размер массива (его емкость, capacity) не изменяется никак.

[к оглавлению](#collections-light)

## Как происходит удаление элементов из LinkedList?
просиходит перелинковка : Замена ссылок prev и next у соседних элементов. 

[к оглавлению](#collections-light)

## Что такое автоупаковка и распаковка? Зачем они нужны?
	
**Автоупаковка(Autoboxing)**

Это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку всякий раз, когда требуется объект данного типа. 

Autoboxing происходит:
1. При присвоении значения примитивного типа переменной соответствующего класса-обёртки.
```java
Integer b = 2;
/// под капотом
b = Integer.valueOf(2);
```

2. При передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.
```java
public static void num(Integer x) {
    System.out.println("Значение типа Integer: " + x);
}
```

[к оглавлению](#collections-light)

**Автораспаковка(Unboxing)**

Это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException.

Unboxing происходит:
1. При присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
```java
Integer m = 3;
int n = m;
/// под капотом
int n = m.intValue();
```
2. В выражениях(типа +, -, * , /, % и т.д), в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
```java
Integer k = 5;
Integer l = 6;
System.out.println(k * l);
```
3. При передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

Распаковка и упаковка касается только единичных элементов. Например, нельзя упаковать/распаковать таким образом массив int в лист Integer или распаковать лист в массив.

https://habr.com/ru/articles/329498/

[к оглавлению](#collections-light)

## В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?

Классы-обёртки неизменяемые, поэтому при каждой автоупаковке (за исключением значений из пула Integer от -128 до 127 включительно) создается новый объект, что может привести к неразумному расходу памяти.

Следующий код будет приводить в постоянному пересозданию новых объектов и чрезмерному расходу памяти:
```java
Integer sum = 0;
for (int i = 128; i < 300; i++) {
    sum += i;
}
System.out.println(sum);
```

Автоупаковка и распаковка очень часто происходит при работе с коллекциями, так как они не могут хранить примитивные типы данных. Например:
```java
List<Integer> list = new ArrayList<>();
 for (int i = 0; i < 10; i++) {
     list.add(i);
 }
```

[к оглавлению](#collections-light)

## Опишите недостатки и преимущества в использовании примитивных типов и классов оберток

Важно понимать разницу между значением примитивного типа и этим же значением в обёртке:

- При работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит дополнительное время.
- Примитивные типы занимают меньше места в памяти.
- Если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя, понадобится упаковка.
- Обёртки - это такие же классы со своими методами, как и любые остальные, которые мы рассматривали. Поэтому работа со значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. (Например, для Integer это parseInt(), valueOf(), compareTo() и т.д.)

[к оглавлению](#collections-light)

## Что такое очередь? Расскажите принцип работы и для чего она используется

Структура данных, которая в программировании называется очередью, представляет из себя хранилище однотипных элементов, в котором первым будет извлекаться тот элемент, который был туда и вставлен первым. Такой способ организации хранения данных называется FIFO, по первым буквам фразы, описывающей этот способ хранения – First-In-First-Out).

Очередь работает по тому же принципу, как и любая очередь в реальной жизни – например очередь за билетами в кино (человек, который первым встал в очередь первым дойдет до кассы и купит билет). Следовательно, тот, кто станет в очередь последним – и купит билет последним.

Очередь – очень удобный инструмент, который используется для моделирования реальных ситуаций ожидания клиентов в банке, вылета самолетов или передачи данных по Интернету.

[к оглавлению](#collections-light)

## Расскажите про интерфейсы Queue, Deque и их иерархию

***Интерфейс Queue*** является прямым наследником Collection, а тот интерфейс в свою очередь наследует интерфейс Iterable. Следовательно, помимо тех методов, которые определены в Queue, в нем также доступны все методы вышестоящих интерфейсов, которые мы рассматривали ранее.

Рассмотрим методы этого интерфейса, а потом попробуем их использовать на практике.

1. метод add() – добавляет элемент в конец очереди (за исключением PriorityQueue, там элемент добавляется согласно своему приоритету)
2. Методы remove() и poll() – методы позволяют удалить верхний (первый) элемент из очереди.
3. Метод offer() – предпринимает попытку вставки элемента в конец очереди.
4. Методы peek() и element() – позволяют вернуть элемент из очереди без его удаления

Итого:

1. Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO.
2. В Java интерфейс Queue поддерживает все методы интерфейса Collection, включая вставку, удаление и т.д.
3. LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.
4. Очереди, доступные в пакете java.util, являются неограниченными очередями.
5. Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.

***Интерфейс Deque***

Этот интерфейс также является очередью, но ее отличительной особенностью то, что эта очередь является двухсторонней, т.е. она поддерживает удаление и добавление элементов с обоих концов очереди. Таким образом, в отличие от Queue, здесь также можно организовать способ хранения элементов по принципу LIFO (сокращение по первой букве от описания этого принципа на английском языке Last In First Out – последний пришел, первый вышел). Такую структуру данных в программировании называют стеком. Пример аналогии из жизни – стопка тетрадей на проверку у учителя, учитель проверяет их по порядку и та тетрадь, которая была положена в эту стопку первой будет проверена последней.

выводы:

1. В очередь Deque элементы можно добавлять, удалять и извлекать с обоих ее сторон. Она следует как принципу FIFO, так и при правильной организации можно получить поведение по принципу LIFO.
2. В Java интерфейс Deque поддерживает все методы интерфейса Queue, Collection, включая вставку, удаление и т.д.
3. Необходимо быть предельно аккуратными при использовании методов, которые при своей работе генерируют непроверяемое исключение. Предпочитайте использовать методы poll(), pollFirst(), pollLast, peekFirst(), peekLast(), peek().
4. Наиболее часто используемой реализацией интерфейса Deque является LinkedList.

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200903183026/Queue-Deque-PriorityQueue-In-Java.png)

[к оглавлению](#collections-light)

## В чем отличие метода poll() от remove()?

Методы remove() и poll() – методы позволяют удалить верхний (первый) элемент из очереди.

Разница в работе этих двух методов раскрывается при работе с пустой очередью
```java
public static void main(String[] args) {
    Queue<String> queue = new LinkedList<>();
    String temp = queue.poll();
    System.out.println(temp);
}
```
метод просто возвращает null, когда наша очередь пустая.

Однако если мы запустим следующий код:

```java
public static void main(String[] args) {
    Queue<String> queue = new LinkedList<>();
    queue.remove();
}
```
Генерируется исключение NoSuchElementException.

В этом и есть разница между этими методами, поэтому если нас не устраивает поведение генерации непроверяемого исключения при пустой очереди, то используем метод poll(), иначе метод remove().

[к оглавлению](#collections-light)

## В чем отличие метода element() от peek()?

Методы peek() и element() – методы вернут первый элемент из очереди, без удаления этого элемента из очереди.

Тут такая же ситуация как и с методами remove() и poll(). В данном случае если метод element() вызывать на пустой очереди, то будет сгенерировано исключение NoSuchElementException. Если заменить на вызов метода peek(), то в консоль будет выведен null.

## В чем отличие метода element() от poll()?

element() - возвращает первый элемент без удаления, при пустой очереди генерирует исключение NoSuchElementException

poll() - возвращает первый элемент и удаляет его, при пустой очереди возвращает null

## Перечислите наиболее часто используемые реализации интерфейса Queue

LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.

## Что такое ограниченные и неограниченные очереди?

Ограниченные очереди-это очереди, которые ограничены емкостью, что означает, что нам нужно указать максимальный размер очереди на момент создания. Например, ArrayBlockingQueue.
Неограниченные очереди-это очереди, которые НЕ ограничены емкостью, что означает, что мы не должны указывать размер очереди.

- Очереди, доступные в пакете java.util, являются неограниченными очередями.
- Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.

## Что такой односторонние и двусторонние очереди?

Односторонняя очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO. Queue

В двусторонней очереди Deque элементы можно добавлять, удалять и извлекать с обоих ее сторон. Она следует как принципу FIFO, так и при правильной организации можно получить поведение по принципу LIFO.

## В чём отличие Deque от Queue?

Deque ("дек", Double Ended Queue) - это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO.

Queue - это очередь, обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди.

## В чём отличие методов removeLast и pollLast?

removeLast() и pollLast() – методы позволяют удалить последний элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

## Назовите самую распространенную реализацию Deque

Наиболее часто используемой реализацией интерфейса Deque является LinkedList.

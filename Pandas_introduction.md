# Оглавление

1. [Series](#series)
2. [Индексы, сложение, проверка на NaN](#индексы-сложение-проверка-на-nan)

### Series
Numpy хорошо работает с числовыми данными - для этого он и создавался. Но на практике таблицы содержат не только числа, но и текст. 
Поэтому пришлось создавать другие контейнеры данных, которые хорошо будут работать с другими типами.\
Series (серия или по простому ряд значений) - контейнер в библиотеке Pandas, который создан для хранения одномерного массива данных. В нее нельзя погрузить матрицу или трехмерный массив. 
Серия может унести только одномерный массив. Именно серия будет хранить содержимое наших столбцов и строк поэтому давайте посмотрим на нее подробнее.\
Серия состоит из двух очень важных компонентов:

1) хранилище наших значений (именно эти значения мы видим в столбце/строке)

2) хранилище индексов. Индексы могут быть как числовые так и строковые.
3) Обращаясь к серии через индекс мы просим серию вернуть из хранилища значений элемент, который связан с индексом. Очень похоже на словарь!

Индексы и значения жестко связаны между собой.

***Словари*** - это одна из стандартных структур данных python, которая позволяет хранить key: valueпары и предлагает некоторые встроенные методы для управления вашими данными, которые вы можете прочитать в документации (вот хорошее резюме, чтобы ускорить процесс чтения).\
***Серии*** Pandas представляют собой одномерные ndarrays с метками осей, которые позволяют хранить array-like, dict, or scalarзначения и являются одной из встроенных структур данных numpy (научной вычислительной библиотеки python).
Если вы прочитаете документацию, вы заметите, что они содержат огромное количество методов и атрибутов, по большей части совершенно отличных от методов и атрибутов словаря python

Если вам нужно сохранить только несколько key:value пар, лучшим и более элегантным решением является использование словаря по умолчанию. Если вам нужно выполнить некоторые сложные манипуляции с сохраненными данными, рассмотрите возможность использования серии pandas
```python
s1= pd.Series([3, 5, -3, 0])
print(s1)
Вывод:
0    3
1    5
2   -3
3    0
dtype: int64

# массив значений можно вытащить с помощью атрибута values
print(s1.values)
[ 3  5 -3  0]
```

Если при создании серии индексы явно не задаются, то серия автоматически создает их для себя.Можно задать свои индексы, для этого в конструктор серии передаются значения, которые надо хранить в серии и индексы для них.
```python
s1= pd.Series([3, 5, -3, 0], index=['a', 'b', 'c', 'd'])
print(s1)
Вывод:
a    3
b    5
c   -3
d    0
dtype: int64
```
Для доступа к элементу серии в скобках указывается индекс, который связан с этим элементом. Если индекс числовой, то в квадратных скобках нужно указать число: s[1]. Если индексы строковые, то в кавычках: s["c"] (можно одинарные, можно двойные).

Создавать серию можно как на основе списка, так и на основе numpy массива - результат будет одинаковый)

Для получения доступа к нескольким элементам серии передайте список индексов: s[['a', 'b', 'c']]

### Индексы, сложение, проверка на NaN

1) При фильтрации серии индексы остаются, а не пересоздаются.

2) Арифметические операции не распространяются на индексы

```python
s1= pd.Series([3, 5, -3, 0], index=['a', 'b', 'c', 'd'])
print(s1[s1 > 1])
Вывод:
a    3
b    5
dtype: int64
----------------
print(s1*10)
a    30
b    50
c   -30
d     0
dtype: int64
```
Серию можно создавать не только на основе списка. Еще один распространённый сценарий это создание серии из словаря. В этом случае ключи словаря перейдут в индексы серии.
```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d)
print(s1)
Вывод:
Moscow    230
London    456
Tokyo     404
dtype: int64
```
Серию можно создать следующим образом
```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d,index=['London', 'Paris', 'Moscow'])
print(s1)
Вывод:
London    456.0
Paris       NaN
Moscow    230.0
dtype: float64
```

Если вы создаёте серию на основе словаря и указали индекс, которого не существует в словаре, то pandas добавит в серию такой индекс, но значение будет равно NaN (пропуск)\
Если вы создаете серию на основе словаря и не передали все индексы, то никакой ошибки не будет. Пандас добавит в серию только те значения, которые вы указали в индексе

s1.isnull().any()   <- вернет только одно значение, которое будет отвечать на главный вопрос: а есть ли в серии пропуски? 

s1.notnull().all() <- ответит на вопрос: а все ли значения в серии заполнены?

#### Сложение серий
Важно запомнить, что при сложении серий:\
1) не обязательно чтобы они были одинаковой длины\
2) сложение будет происходить по индексам\
3) если в одной из серий есть индекс, которого нет в другой серии, то индекс добавляется в результирующую серию, но значение присваивается NaN

```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d,index=['London', 'Paris', 'Moscow'])
s2 = pd.Series(d)
print(s1)
Вывод:
London    456.0
Paris       NaN
Moscow    230.0
dtype: float64
print("===============")
print(s2)
Вывод:
Moscow    230
London    456
Tokyo     404
dtype: int64
print("===============")
print(s1 + s2)
Вывод:
London    912.0
Moscow    460.0
Paris       NaN
Tokyo       NaN
dtype: float64
```

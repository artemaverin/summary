# Оглавление

1. [Series](#series)
2. [Индексы, сложение, проверка на NaN](#индексы-сложение-проверка-на-nan)
3. [DataFrame](#DataFrame)

### Series
Numpy хорошо работает с числовыми данными - для этого он и создавался. Но на практике таблицы содержат не только числа, но и текст. 
Поэтому пришлось создавать другие контейнеры данных, которые хорошо будут работать с другими типами.\
Series (серия или по простому ряд значений) - контейнер в библиотеке Pandas, который создан для хранения одномерного массива данных. В нее нельзя погрузить матрицу или трехмерный массив. 
Серия может унести только одномерный массив. Именно серия будет хранить содержимое наших столбцов и строк поэтому давайте посмотрим на нее подробнее.\
Серия состоит из двух очень важных компонентов:

1) хранилище наших значений (именно эти значения мы видим в столбце/строке)

2) хранилище индексов. Индексы могут быть как числовые так и строковые.
3) Обращаясь к серии через индекс мы просим серию вернуть из хранилища значений элемент, который связан с индексом. Очень похоже на словарь!

Индексы и значения жестко связаны между собой.

***Словари*** - это одна из стандартных структур данных python, которая позволяет хранить key: valueпары и предлагает некоторые встроенные методы для управления вашими данными, которые вы можете прочитать в документации (вот хорошее резюме, чтобы ускорить процесс чтения).\
***Серии*** Pandas представляют собой одномерные ndarrays с метками осей, которые позволяют хранить array-like, dict, or scalarзначения и являются одной из встроенных структур данных numpy (научной вычислительной библиотеки python).
Если вы прочитаете документацию, вы заметите, что они содержат огромное количество методов и атрибутов, по большей части совершенно отличных от методов и атрибутов словаря python

Если вам нужно сохранить только несколько key:value пар, лучшим и более элегантным решением является использование словаря по умолчанию. Если вам нужно выполнить некоторые сложные манипуляции с сохраненными данными, рассмотрите возможность использования серии pandas
```python
s1= pd.Series([3, 5, -3, 0])
print(s1)
Вывод:
0    3
1    5
2   -3
3    0
dtype: int64

# массив значений можно вытащить с помощью атрибута values
print(s1.values)
[ 3  5 -3  0]
```

Если при создании серии индексы явно не задаются, то серия автоматически создает их для себя.Можно задать свои индексы, для этого в конструктор серии передаются значения, которые надо хранить в серии и индексы для них.
```python
s1= pd.Series([3, 5, -3, 0], index=['a', 'b', 'c', 'd'])
print(s1)
Вывод:
a    3
b    5
c   -3
d    0
dtype: int64
```
Для доступа к элементу серии в скобках указывается индекс, который связан с этим элементом. Если индекс числовой, то в квадратных скобках нужно указать число: s[1]. Если индексы строковые, то в кавычках: s["c"] (можно одинарные, можно двойные).

Создавать серию можно как на основе списка, так и на основе numpy массива - результат будет одинаковый)

Для получения доступа к нескольким элементам серии передайте список индексов: s[['a', 'b', 'c']]

**Важное замечание по серии**
Серия хоть и похожа на питоновский словарь, имеет все же значительное отличие - у серии индексы не уникальные! Они могут повторяться.
```python
m1 = pd.Series([6, 5, 4], index=['a', 'b', 'a'])
print(m1)
Вывод:
a    6
b    5
a    4
dtype: int64
print(m1['a'])
Вывод:
a    6
a    4
dtype: int64
```

### Индексы, сложение, проверка на NaN

1) При фильтрации серии индексы остаются, а не пересоздаются.

2) Арифметические операции не распространяются на индексы

```python
s1= pd.Series([3, 5, -3, 0], index=['a', 'b', 'c', 'd'])
print(s1[s1 > 1])
Вывод:
a    3
b    5
dtype: int64
----------------
print(s1*10)
a    30
b    50
c   -30
d     0
dtype: int64
```
Серию можно создавать не только на основе списка. Еще один распространённый сценарий это создание серии из словаря. В этом случае ключи словаря перейдут в индексы серии.
```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d)
print(s1)
Вывод:
Moscow    230
London    456
Tokyo     404
dtype: int64
```
Серию можно создать следующим образом
```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d,index=['London', 'Paris', 'Moscow'])
print(s1)
Вывод:
London    456.0
Paris       NaN
Moscow    230.0
dtype: float64
```

Если вы создаёте серию на основе словаря и указали индекс, которого не существует в словаре, то pandas добавит в серию такой индекс, но значение будет равно NaN (пропуск)\
Если вы создаете серию на основе словаря и не передали все индексы, то никакой ошибки не будет. Пандас добавит в серию только те значения, которые вы указали в индексе

s1.isnull().any()   <- вернет только одно значение, которое будет отвечать на главный вопрос: а есть ли в серии пропуски? 

s1.notnull().all() <- ответит на вопрос: а все ли значения в серии заполнены?

#### Сложение серий
Важно запомнить, что при сложении серий:\
1) не обязательно чтобы они были одинаковой длины\
2) сложение будет происходить по индексам\
3) если в одной из серий есть индекс, которого нет в другой серии, то индекс добавляется в результирующую серию, но значение присваивается NaN

```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d,index=['London', 'Paris', 'Moscow'])
s2 = pd.Series(d)
print(s1)
Вывод:
London    456.0
Paris       NaN
Moscow    230.0
dtype: float64
print("===============")
print(s2)
Вывод:
Moscow    230
London    456
Tokyo     404
dtype: int64
print("===============")
print(s1 + s2)
Вывод:
London    912.0
Moscow    460.0
Paris       NaN
Tokyo       NaN
dtype: float64
```
У каждой серии есть своё имя. Задать или прочитать имя можно через свойство name. Имя используется при работе с хранилищем серий - DataFrame (про него смотрите дальше, но сначала тест).

### DataFrame
Для хранения серий разработчики Pandas не стали брать словарь, а решили создать свой контейнер - DataFrame (датафрейм). Чтобы датафрейм легко ориентировался в сериях, их наделили свойством name. 
создание Dataframe:
```python
ser1 = pd.Series(['Ivan', 'Petr', 'Artem'])
ser1.name = 'users'
df = pd.DataFrame(ser1)
print(df)
Вывод:
   users
0   Ivan
1   Petr
2  Artem
```
Датафреймы очень хорошо создаются на основе словаря, который состоит из ключей и значений в качестве вложенных списков. Ключи словаря в датафрейме станут названиями столбцов, а вложенные списки - колонками.
```python
data = { 'city': ['Moscow', 'Moscow', 'Moscow', 'Kazan', 'Kazan', 'Kazan'],
        'year':  [2022,      2021,     2020,     2022,    2021,    2020],
        'visits': [500,      2000,     1500,     100,     230,     200]}
df = pd.DataFrame(data)
print(df)
     city  year  visits
0  Moscow  2022     500
1  Moscow  2021    2000
2  Moscow  2020    1500
3   Kazan  2022     100
4   Kazan  2021     230
5   Kazan  2020     200
```
с помощью функции df.head(n=5) можно задать количество строк (по умолчанию 5)\
если необходимо переставить или убрать столбцы можно нужные столбцы задать при создании DF:
```python
df = pd.DataFrame(data, columns=['visits', 'city', 'year'])
```

При создании датафрейма можно задать свои собственные индексы (как и с серией)
```python
df = pd.DataFrame(data, index=['a', 'b', 'c', 'd', 'e', 'f'])
```

добавление колонки:
df['total_time'] = df['time_per_page'] * df['pages'], где колонки 'time_per_page' и 'pages' уже существовали в таблице а 'total_time' - новая

добавить колонку можно также присвоив серию:
df['balance'] = s1, 'balance' - новая колонка, s1 = серия

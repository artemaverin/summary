# Оглавление

1. [Series](#series)
2. [Индексы, сложение, проверка на NaN](#индексы-сложение-проверка-на-nan)
3. [DataFrame](#dataframe)
4. [Функции reindex, drop и индексация в датафрейме](#функции-reindex-drop-и-индексация-в-датафрейме)
5. [Операторы loc, iloc, at, iat. Сложение нескольких датафреймов](#операторы-loc-iloc-at-iat-сложение-нескольких-датафреймов)
6. [Сложение датафреймов, сортировки, арифметика с пропусками](#сложение-датафреймов-сортировки-арифметика-с-пропусками)
7. [Описательные статистики. Уникальные значения](#описательные-статистики-уникальные-значения)

### Series
Numpy хорошо работает с числовыми данными - для этого он и создавался. Но на практике таблицы содержат не только числа, но и текст. 
Поэтому пришлось создавать другие контейнеры данных, которые хорошо будут работать с другими типами.\
Series (серия или по простому ряд значений) - контейнер в библиотеке Pandas, который создан для хранения одномерного массива данных. В нее нельзя погрузить матрицу или трехмерный массив. 
Серия может унести только одномерный массив. Именно серия будет хранить содержимое наших столбцов и строк поэтому давайте посмотрим на нее подробнее.\
Серия состоит из двух очень важных компонентов:

1) хранилище наших значений (именно эти значения мы видим в столбце/строке)

2) хранилище индексов. Индексы могут быть как числовые так и строковые.
3) Обращаясь к серии через индекс мы просим серию вернуть из хранилища значений элемент, который связан с индексом. Очень похоже на словарь!

Индексы и значения жестко связаны между собой.

***Словари*** - это одна из стандартных структур данных python, которая позволяет хранить key: valueпары и предлагает некоторые встроенные методы для управления вашими данными, которые вы можете прочитать в документации (вот хорошее резюме, чтобы ускорить процесс чтения).\
***Серии*** Pandas представляют собой одномерные ndarrays с метками осей, которые позволяют хранить array-like, dict, or scalarзначения и являются одной из встроенных структур данных numpy (научной вычислительной библиотеки python).
Если вы прочитаете документацию, вы заметите, что они содержат огромное количество методов и атрибутов, по большей части совершенно отличных от методов и атрибутов словаря python

Если вам нужно сохранить только несколько key:value пар, лучшим и более элегантным решением является использование словаря по умолчанию. Если вам нужно выполнить некоторые сложные манипуляции с сохраненными данными, рассмотрите возможность использования серии pandas
```python
s1= pd.Series([3, 5, -3, 0])
print(s1)
Вывод:
0    3
1    5
2   -3
3    0
dtype: int64

# массив значений можно вытащить с помощью атрибута values
print(s1.values)
[ 3  5 -3  0]
```

Если при создании серии индексы явно не задаются, то серия автоматически создает их для себя.Можно задать свои индексы, для этого в конструктор серии передаются значения, которые надо хранить в серии и индексы для них.
```python
s1= pd.Series([3, 5, -3, 0], index=['a', 'b', 'c', 'd'])
print(s1)
Вывод:
a    3
b    5
c   -3
d    0
dtype: int64
```
Для доступа к элементу серии в скобках указывается индекс, который связан с этим элементом. Если индекс числовой, то в квадратных скобках нужно указать число: s[1]. Если индексы строковые, то в кавычках: s["c"] (можно одинарные, можно двойные).

Создавать серию можно как на основе списка, так и на основе numpy массива - результат будет одинаковый)

Для получения доступа к нескольким элементам серии передайте список индексов: s[['a', 'b', 'c']]

**Важное замечание по серии**
Серия хоть и похожа на питоновский словарь, имеет все же значительное отличие - у серии индексы не уникальные! Они могут повторяться.
```python
m1 = pd.Series([6, 5, 4], index=['a', 'b', 'a'])
print(m1)
Вывод:
a    6
b    5
a    4
dtype: int64
print(m1['a'])
Вывод:
a    6
a    4
dtype: int64
```

### Индексы, сложение, проверка на NaN

1) При фильтрации серии индексы остаются, а не пересоздаются.

2) Арифметические операции не распространяются на индексы

```python
s1= pd.Series([3, 5, -3, 0], index=['a', 'b', 'c', 'd'])
print(s1[s1 > 1])
Вывод:
a    3
b    5
dtype: int64
----------------
print(s1*10)
a    30
b    50
c   -30
d     0
dtype: int64
```
Серию можно создавать не только на основе списка. Еще один распространённый сценарий это создание серии из словаря. В этом случае ключи словаря перейдут в индексы серии.
```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d)
print(s1)
Вывод:
Moscow    230
London    456
Tokyo     404
dtype: int64
```
Серию можно создать следующим образом
```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d,index=['London', 'Paris', 'Moscow'])
print(s1)
Вывод:
London    456.0
Paris       NaN
Moscow    230.0
dtype: float64
```

Если вы создаёте серию на основе словаря и указали индекс, которого не существует в словаре, то pandas добавит в серию такой индекс, но значение будет равно NaN (пропуск)\
Если вы создаете серию на основе словаря и не передали все индексы, то никакой ошибки не будет. Пандас добавит в серию только те значения, которые вы указали в индексе

s1.isnull().any()   <- вернет только одно значение, которое будет отвечать на главный вопрос: а есть ли в серии пропуски? 

s1.notnull().all() <- ответит на вопрос: а все ли значения в серии заполнены?

#### Сложение серий
Важно запомнить, что при сложении серий:\
1) не обязательно чтобы они были одинаковой длины\
2) сложение будет происходить по индексам\
3) если в одной из серий есть индекс, которого нет в другой серии, то индекс добавляется в результирующую серию, но значение присваивается NaN

```python
d = {'Moscow': 230, 'London': 456, 'Tokyo': 404}
s1= pd.Series(d,index=['London', 'Paris', 'Moscow'])
s2 = pd.Series(d)
print(s1)
Вывод:
London    456.0
Paris       NaN
Moscow    230.0
dtype: float64
print("===============")
print(s2)
Вывод:
Moscow    230
London    456
Tokyo     404
dtype: int64
print("===============")
print(s1 + s2)
Вывод:
London    912.0
Moscow    460.0
Paris       NaN
Tokyo       NaN
dtype: float64
```
У каждой серии есть своё имя. Задать или прочитать имя можно через свойство name. Имя используется при работе с хранилищем серий - DataFrame (про него смотрите дальше, но сначала тест).

### DataFrame
Для хранения серий разработчики Pandas не стали брать словарь, а решили создать свой контейнер - DataFrame (датафрейм). Чтобы датафрейм легко ориентировался в сериях, их наделили свойством name. 
создание Dataframe:
```python
ser1 = pd.Series(['Ivan', 'Petr', 'Artem'])
ser1.name = 'users'
df = pd.DataFrame(ser1)
print(df)
Вывод:
   users
0   Ivan
1   Petr
2  Artem
```
Датафреймы очень хорошо создаются на основе словаря, который состоит из ключей и значений в качестве вложенных списков. Ключи словаря в датафрейме станут названиями столбцов, а вложенные списки - колонками.
```python
data = { 'city': ['Moscow', 'Moscow', 'Moscow', 'Kazan', 'Kazan', 'Kazan'],
        'year':  [2022,      2021,     2020,     2022,    2021,    2020],
        'visits': [500,      2000,     1500,     100,     230,     200]}
df = pd.DataFrame(data)
print(df)
     city  year  visits
0  Moscow  2022     500
1  Moscow  2021    2000
2  Moscow  2020    1500
3   Kazan  2022     100
4   Kazan  2021     230
5   Kazan  2020     200
```
с помощью функции df.head(n=5) можно задать количество строк (по умолчанию 5)\
если необходимо переставить или убрать столбцы можно нужные столбцы задать при создании DF:
```python
df = pd.DataFrame(data, columns=['visits', 'city', 'year'])
```

При создании датафрейма можно задать свои собственные индексы (как и с серией)
```python
df = pd.DataFrame(data, index=['a', 'b', 'c', 'd', 'e', 'f'])
```

добавление колонки:
```python
df['total_time'] = df['time_per_page'] * df['pages'], где колонки 'time_per_page' и 'pages' уже существовали в таблице а 'total_time' - новая
```
добавить колонку можно также присвоив серию:
```python
df['balance'] = s1, 'balance' - новая колонка, s1 = серия
```
Создайте новую колонку c названием is_correct. Проверьте каждое значение из столбца total_time. Если значение меньше 100, то в колонку is_correct вставьте True, а иначе False.
```python
df['is_correct'] = df['total_time'] < 100
```

Доступ к целой колонке мы можем получить:
- указав название колонки в квадратных скобках: df['название колонки']. Этот способ разрешает вытягивать колонки с пробелами и спец. символами.
- через атрибут(свойство) датафрейма(если наименование столбца через пробел - выпадет ошибка)
```python
df['column_1']
df['user_name']
df['visits']
# 2 способ
df.column_1
df.user_name
df.visits
```
Для того чтобы создать новую колонку в квадратных скобках указываем название новой колонки и передаем либо одно значение либо массив. Если передаёте массив, то помните, что количество элементов должно быть равно количеству строк в датафрейме. Иначе датафрейм не сможет положить к себе одномерный массив (будет ошибка).
```python
data1 = {'user' : ['Ivan', 'Petr', 'Nikolay', 'Andrey'],
            'time_per_page' :  [10, 30 , 15, np.nan],
             'pages' : [7, 9, 12, 3]}
df = pd.DataFrame(data1)
df['words'] = [100, 33, 454, 934]
print(df)
Вывод:
      user  time_per_page  pages  words
0     Ivan           10.0      7    100
1     Petr           30.0      9     33
2  Nikolay           15.0     12    454
3   Andrey            NaN      3    934
```

Также можно добавить и серию. Только индексы должны совпадать, иначе датафрейм ничего не добавит.

помните, что количество элементов должно быть равно количеству строк в датафрейме. Иначе датафрейм не сможет положить к себе одномерный массив (будет ошибка).
```python
data1 = {'user' : ['Ivan', 'Petr', 'Nikolay', 'Andrey'],
            'time_per_page' :  [10, 30 , 15, np.nan],
             'pages' : [7, 9, 12, 3]}
df = pd.DataFrame(data1)
df['words'] = s1
print(df)
Вывод:
      user  time_per_page  pages  words
0     Ivan           10.0      7  130.0
1     Petr           30.0      9    NaN
2  Nikolay           15.0     12   23.0
3   Andrey            NaN      3    NaN
```

атрибут **loc** датафрейма возвращает информацию о строке по индекску
```python
data1 = {'user' : ['Ivan', 'Petr', 'Nikolay', 'Andrey'],
            'time_per_page' :  [10, 30 , 15, np.nan],
             'pages' : [7, 9, 12, 3]}
df = pd.DataFrame(data1)
print(df.loc[1])
Вывод:
Int64Index([3], dtype='int64')
user             Petr
time_per_page    30.0
pages               9
Name: 1, dtype: object
```

отредактировать индекс датафрейма:
```python
d1 = {'user_name': ['Ivan', 'Alex', 'Paul'],
'click': [2, 5, 9]}
df = pd.DataFrame(d1)
print(df)
Вывод:
  user_name  click
0      Ivan      2
1      Alex      5
2      Paul      9
df.index = [0, 'one', 2]
print(df)
Вывод:
    user_name  click
0        Ivan      2
one      Alex      5
2        Paul      9
```

При добавлении серии к датафрейму, нужно быть внимательным с индексами. Если у серии будут индексы, которых нет у датафрейма, то значения из серии просто не добавятся к датафрейму.
```python
s1 = pd.Series([130, 23], index=[0, 6])
Вывод:
0     Ivan           10.0      7  130.0
1     Petr           30.0      9    NaN
2  Nikolay           15.0     12    NaN
3   Andrey            NaN      3    NaN
```

создание колонки с помощью **arange(n)**
```python
df['words'] = np.arange(4)
Вывод:
      user  time_per_page  pages  words
0     Ivan           10.0      7      0
1     Petr           30.0      9      1
2  Nikolay           15.0     12      2
3   Andrey            NaN      3      3
```

Есть несколько способов удалить колонку:
- с помощью **del**:
```java
del df['pages']
```
- если надо удалить несколько столбцов или строк -  **drop** (но тут изменения идут не inplace, создается новый DataFrame)
```python
data = { 'city': ['Moscow', 'Moscow', 'Moscow', 'Kazan', 'Kazan', 'Kazan'],
        'year':  [2022,      2021,     2020,     2022,    2021,    2020],
        'visits': [1,      2,     3,     4,     5,     6]}

df = pd.DataFrame(data)
df['old_visits'] = df.visits
df['old_visits_two'] = df.visits

print(df)
#      city  year  visits  old_visits  old_visits_two
# 0  Moscow  2022       1           1               1
# 1  Moscow  2021       2           2               2
# 2  Moscow  2020       3           3               3
# 3   Kazan  2022       4           4               4
# 4   Kazan  2021       5           5               5
# 5   Kazan  2020       6           6               6

print(df.drop([0, 1, 5]))
#      city  year  visits  old_visits  old_visits_two
# 2  Moscow  2020       3           3               3
# 3   Kazan  2022       4           4               4
# 4   Kazan  2021       5           5               5


print(df.drop(['old_visits', 'old_visits_two'], axis=1))
#      city  year  visits
# 0  Moscow  2022       1
# 1  Moscow  2021       2
# 2  Moscow  2020       3
# 3   Kazan  2022       4
# 4   Kazan  2021       5
# 5   Kazan  2020       6
```

Разработчики Pandas наделили датафрейм возможностью создаваться на основе вложенных словарей. Это означает, что вложенные словари уже содержат индексы строк. Внешние ключи будут отвечать за название колонок, а внутренние ключи за индексы строк:
```pyhon
d = data2= { 'Moscow': {2020: 1500, 2021: 2000, 2022:500},
'Kazan':  {2020: 200, 2021: 230, 2022: 100}}
df = pd.DataFrame(d)
print(df)
Вывод:
      Moscow  Kazan
2020    1500    200
2021    2000    230
2022     500    100
```

свойство транспонирование работает и с датафреймом: **df.T**

перевести название (лейблы) колонок в верхний регистр:
```python
def solution(_df):
    _df.columns = _df.columns.str.upper()
    return _df
```
свойства dataframe аналогичны сериям: df.values, df.columns

#### индексы
На самом деле у датафрейма два индекса: один для навигации по строкам, а второй по навигации по колонкам:

![](https://ucarecdn.com/604dd2a7-e1d7-4701-a687-2c43df4802c4/)

Первый можно получить через свойство index, а второй через свойство .columns. 
Да, свойство называется columns (от англ. колонки), но это тоже индекс. 

Что важно запомнить?:

1)У датафрейма два индекса, первый хранит индексы строк, а второй индексы колонок. Иногда вместо индексов употребляют слово лейбл (от англ label - метка). Если вы где-то услышите: отредактируй лейблы колонок - это значит, что вас просят отредактировать названия колонок.

2)Индексы хранятся в специальном объекте Index, а не на прямую в массиве. Это ограничивает нас в его редактировании. Тут нужен грамотный подход, мы его будем проходить. Но на данном этапе знайте, что просто взять и попросить df.columns[0] = 'Новое имя колонки' не прокатит) 

через объект **Index** можно задать индексы
```python
pd.Index(['A', 'B', 'C'])
``

редактирование индексов/строк:
```python
_df.index = [0, 'one', 2]
```
Вставка колонки через список:\
![](https://ucarecdn.com/e4a4d26a-3964-489d-995a-e861cb74d99a/)\
![](https://ucarecdn.com/47ba1193-72a1-4dc1-9618-d550c30fe6ec/)\
![](https://ucarecdn.com/520985f2-375c-434d-b3c9-30ca42535ed8/)

Какое свойство датафрейма позволяет получить двумерный numpy массив состоящий из значений датафрейма?\
values

Сменить тип индекса
```python
def solution(_df, _s1):
    _s1.index = _s1.index.astype(dtype='int64')
    _df['balance'] = _s1
    return _df
```

Что будет если вы сложите две серии с разными  индексами? Например, у одной серии индексы для строк буквы, а у другой числа.\
Получится новая серия, которая будет включать индексы двух серий

Что будет при добавлении серии к датафрейму, если у серии полностью не совпадают индексы с датафреймом?\
Будет добавлена новая колонка со значениями NaN

### Функции reindex, drop и индексация в датафрейме
если необходимо поменять наименование колонок нужно в атрибут columns передать список со всеми колонками и заменить в нужных на новое
```python
df.columns = ['old_col_1', 'old_col_2', 'new_col_3']
```

название одной колонки можно поменять вот так:
```python
df.rename(columns={'old_name' : 'new_name'}) 
```

#### Переиндексирование df.reindex()

После объявления в структуре данных объект Index нельзя менять. Но с помощью операции переиндексирования это можно решить.

Для того чтобы провести переиндексирование объекта Series библиотека pandas предоставляет функцию reindex(). Она создает новый объект Series со значениями из другого Series, которые теперь переставлены в соответствии с новой последовательностью меток.

Переиндексируем датафррейм по колонкам:
```python
data = { 'city': ['Moscow', 'Moscow', 'Moscow', 'Kazan', 'Kazan', 'Kazan'],
        'year':  [2022,      2021,     2020,     2022,    2021,    2020],
        'visits': [500,      2000,     1500,     100,     230,     200]}
df = pd.DataFrame(data)
df = df.reindex(['city', 'visits'], axis=1)
print(df)
Вывод:
     city  visits
0  Moscow     500
1  Moscow    2000
2  Moscow    1500
3   Kazan     100
4   Kazan     230
5   Kazan     200

# если указать несуществующий индекс, то столбец заполниться Nan
```
* В функции reindex есть необязательный параметр fill_value, в котором можно указать конкретное значение для отсутствующих данных вместо NaN.

Аналогично можно переиндексировать строки

```python
data = { 'city': ['Moscow', 'Moscow', 'Moscow', 'Kazan', 'Kazan', 'Kazan'],
        'year':  [2022,      2021,     2020,     2022,    2021,    2020],
        'visits': [500,      2000,     1500,     100,     230,     200]}
df = pd.DataFrame(data)
df = df.reindex([0, 2, 4])
print(df)
Вывод:
     city  year  visits
0  Moscow  2022     500
2  Moscow  2020    1500
4   Kazan  2021     230

# если указать несуществующий индекс, то столбец заполниться Nan

df = df.reindex([0, 2, 4, 6])
print(df)
Вывод:
     city    year  visits
0  Moscow  2022.0   500.0
2  Moscow  2020.0  1500.0
4   Kazan  2021.0   230.0
6     NaN     NaN     NaN
```

Функция **drop()** удаляет строки/колонки df и возвращает новый df (схожа по результатам с функцией reindexб только передавать нужно те строки/столлбцы, которые нужно удалить)

```python
data = { 'city': ['Moscow', 'Moscow', 'Moscow', 'Kazan', 'Kazan', 'Kazan'],
        'year':  [2022,      2021,     2020,     2022,    2021,    2020],
        'visits': [500,      2000,     1500,     100,     230,     200]}
df = pd.DataFrame(data)
df = df.drop([0, 2, 4], axis=0)
print(df)
Вывод:
     city  year  visits
1  Moscow  2021    2000
3   Kazan  2022     100
5   Kazan  2020     200
```

С помощью параматра inplace=True функции drop(), df пересохраняется в изначальном массиве 

* Ошибку удаления несуществующих элементов в функции drop можно подавить с помощью параметра errors=‘ignore’.
* У df.drop() есть параметры columns=  (туда список со столбцами для удаления) и index= (сюда список со строками для удаления). Тогда axis прописывать НЕ нужно.

Для того чтобы  выбрать строки в серии нужно передать, в массиве необхоимые индексы строк:
```python
s2 = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'])
print(s2[['c', 'b']])
Вывод:
c    30
b    20
dtype: int64
```

Вытягивать нужные строки можно и с помощью маски:
```python
s2 = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'])
print(s2[s2 > 30])
Вывод:
d    40
e    50
dtype: int64
```

срезы(слайсы) у серий можно делать как с помощью значений целочисленный индексов s1[0:3] так и строковые s1['a':'b'], но если строковые индексы будут не в алфавитном порядке результат может быть не таким как ожидался:
```python
s1 = pd.Series([10, 20, 30, 40, 50, 60], index=['c', 'd', 'e', 'a', 'f', 'b'])

s1['a':'b']
Выведет:
a 40
f 50
b 60

s1['a':'c']
Выведет:
Series([], dtype: int64)
```
в результат среза серии можно присвоить какое-либо значение
```python
s1['a':'c'] = 0
```

для того чтобы вытягивать информацию из df , существуют следующие способы:
* df[['col_1', 'col_4']] -передаем список колонок
* df[:2] - срез обрежет по строкам; но отдельный индекс df[0] - выдаст ошибку
* df[True, True, False, True] - маска обрежет по строкам

Возможность использовать маску дает нам фильтр для df:
```python
#есть таблица:
             col_1  col_2  col_3  col_4
Moscow           0      1      2      3
Vladivostok      4      5      6      7
Ufa              8      9     10     11
Kazan           12     13     14     15

mask = df2['col_3'] > 9
print(df2[mask])
Вывод:
       col_1  col_2  col_3  col_4
Ufa        8      9     10     11
Kazan     12     13     14     15
```

маска может формировать на основе всего df, те задействовать все значения df, например:

```python
            col_1  col_2  col_3  col_4
Moscow           0      1      2      3
Vladivostok      4      5      6      7
Ufa              8      9     10     11
Kazan           12     13     14     15

df2[df2 < 10] = 0
print(df2)
Вывод:
             col_1  col_2  col_3  col_4
Moscow           0      0      0      0
Vladivostok      0      0      0      0
Ufa              0      0     10     11
Kazan           12     13     14     15
```
#### Операторы loc, iloc, at, iat. Сложение нескольких датафреймов
Оператор loc используется для вытягивания данных из датафрейма на основе лейблов!\
Обязательно после loc указывать квадратные, а не круглые скобки!
В скобках: слева от запятой лейблы строк, справа от запятой лейблы столбцов.

```python
dt = {'name': ['Ivan', 'Petr', 'Nikolay', 'Sergey', 'Andrey', 'Ilya', 'Igor'],
      'age': [25, 40, 19, 33, 38, 20, 19],
      'clicks': [4, 9, 12, 6, 2, 18, 2],
      'balance': [0, 250, 0, 115, 152, 0, 0],
      'history': [1, 8, 1, 6, 4, 2, 1]
}
df = pd.DataFrame(dt, index=['a', 'b', 'c', 'd', 'e', 'f', 'g'])

print(df.loc[['e', 'a'], ['name', 'balance']])
Вывод:
     name  balance
e  Andrey      152
a    Ivan        0
```

оператор loc также поддерживает условия:

```python
print(df.loc[df['age'] > 30, ['name', 'age']])
Вывод:
     name  age
b    Petr   40
d  Sergey   33
e  Andrey   38
```

Оператор iloc похож на loc, но работает не с лейблами, а с индексами!

```python
dt = {'name': ['Ivan', 'Petr', 'Nikolay', 'Sergey', 'Andrey', 'Ilya', 'Igor'],
      'age': [25, 40, 19, 33, 38, 20, 19],
      'clicks': [4, 9, 12, 6, 2, 18, 2],
      'balance': [0, 250, 0, 115, 152, 0, 0],
      'history': [1, 8, 1, 6, 4, 2, 1]
}
df = pd.DataFrame(dt, index=['a', 'b', 'c', 'd', 'e', 'f', 'g'])

print(df.iloc[[0, 3], [0, 1]])
Вывод:
     name  age
a    Ivan   25
d  Sergey   33
```

Оператор at очень похож на loc, но в at нельзя передавать список лейблов. Тоже самое и с iat. В оператор at/iat списки не передаются в отличии от loc/iloc

```python
print(df.iat[0, 2])
Вывод: 4
print(df.at['a', 'history'])
Вывод: 1
```

Операторы at/iat/loc/iloc могут присваивать значения в df
```python
df.loc[['e', 'a'], ['name', 'balance']] = 111
df.iloc[[0, 3], [0, 1]] = 111
df.iat[0, 2] = 111
df.at['a', 'history'] = 111
```
Сложение датафреймов происходит по двум индексам поэлементно:
```python
df1 = pd.DataFrame(np.arange(9).reshape(3, 3), columns=list('bcd'), index=['Moscow', 'Kazan', 'Vladivostok'])
             b  c  d
Moscow       0  1  2
Kazan        3  4  5
Vladivostok  6  7  8

df2 = pd.DataFrame(np.arange(12).reshape(4, 3), columns=list('bde'), index=['Yakutsk', 'Moscow', 'Kazan', 'Ufa'])
         b   d   e
Yakutsk  0   1   2
Moscow   3   4   5
Kazan    6   7   8
Ufa      9  10  11

print(df1 + df2)
               b   c     d   e
Kazan        9.0 NaN  12.0 NaN
Moscow       3.0 NaN   6.0 NaN
Ufa          NaN NaN   NaN NaN
Vladivostok  NaN NaN   NaN NaN
Yakutsk      NaN NaN   NaN NaN
```

### Сложение датафреймов, сортировки, арифметика с пропусками

Функции ниже ничего не записывают в датафрейм. Они просто пытаются выполнить свою работу и если одно из слагаемых NaN, тогда оно подменяется на значение из параметра fill_value.
Если и и там будет NaN, то тут уже не сработает.

Функции:
- add, radd - сложение
- sub, rsub - вычитание
- div, rdiv - деление
- mul, rmul - умножение
- pow, rpow - возведение в степень

Чем отличается функция с буквой r в начале?

df / 5  - означает, разделить все значения датафрейма на 5. Тоже самое: df.div(5)  (да-да, в функцию можно и число передавать)\
А как например записать наборот?: 5 / df т.е. пятёрку разделить на каждый элемент датафрейма. Вот для этого и нужна функция rdiv:  df.rdiv(5).\
Т.е. функции с буквой r как-бы меняют местами наши элементы.

```python
df1 = pd.DataFrame({'visits':[100,200 ,100]}, index=['Kazan', 'Vladivostok','Moscow'])
             visits
Kazan           100
Vladivostok     200
Moscow          100

df2 = pd.DataFrame({'visits':[200, np.nan, 400]}, index=['Kazan', 'Vladivostok','Moscow'])
             visits
Kazan         200.0
Vladivostok     NaN
Moscow        400.0

print(df1.add(df2, fill_value=0))
             visits
Kazan         300.0
Vladivostok   200.0
Moscow        500.0

#но если в df1 по индексу 'vladivostok' будет nan, то и в сумарном выражении будет nan
поэтому можно воспользоваться функцией fillna():
df1.fillna(0) + df2.fillna(0)

```


ДатаФрейм можно сложить с Серией, сложение будет осуществляться по колонкам
```python
df3 = pd.DataFrame({'a':[100,200,300],
                    'b': [1,2,3]}, index=['Kazan', 'Vladivostok','Moscow'])
               a  b
Kazan        100  1
Vladivostok  200  2
Moscow       300  3

s1 = pd.Series([1,2], index=['a','b'])
a    1
b    2
dtype: int64

print(df3 + s1)
               a  b
Kazan        101  3
Vladivostok  201  4
Moscow       301  5

#нужно помнить что при такой серии:
s1 = pd.Series([1], index=['a'])
# получится так:
                 a   b
Kazan        101.0 NaN
Vladivostok  201.0 NaN
Moscow       301.0 NaN

# еще пример:
s1 = pd.Series([1, 2], index=['a', 'c'])
                 a   b   c
Kazan        101.0 NaN NaN
Vladivostok  201.0 NaN NaN
Moscow       301.0 NaN NaN
```

Примеры выше касались сложения df и series по столбцам, а если нужно по столбцам то у функции add, можно задать ось
```python
df3 = pd.DataFrame({'a':[100,200,300],
                    'b': [1,2,3]}, index=['Kazan', 'Vladivostok','Moscow'])
               a  b
Kazan        100  1
Vladivostok  200  2
Moscow       300  3

s2 = pd.Series([1, 2], index=['Kazan', 'Vladivostok'])
Kazan          1
Vladivostok    2
dtype: int64

print(df3.add(s2, axis=0))
                 a    b
Kazan        101.0  2.0
Moscow         NaN  NaN
Vladivostok  202.0  4.0
```
#### Сортировка:
* Сортировка Серий: где параметр *ascending* - сортировка по возрастанию, параметр inplace - возвращает и сохраняет отсоортированную серию в изначальную серию
- сортировка Серии по индексам s.sort_index(ascending=True, inplace=False)
- сортировка серии по колонкам s.sort_values(ascending=True, inplace=False)
```python
s5 = pd.Series([1,-2,3,-4], index = ['c','a','b','d'])
c    1
a   -2
b    3
d   -4
dtype: int64

s5.sort_index(ascending=False, inplace=True)
d   -4
c    1
b    3
a   -2
dtype: int64
# сортировка по значению

s5.sort_values(inplace=True)
d   -4
a   -2
c    1
b    3
dtype: int64
```
* Сортировка Датафрейма:

- сортировка DF **по индексам** с помощью функции sort_index(axis=0, ascending=False), где через параметры мы выбираем нужную ось и порядок сортировки
```python
df = pd.DataFrame(np.arange(12).reshape(4, 3), columns=list('ebd'), index=['a', 'c', 'd', 'e'])
   e   b   d
a  0   1   2
c  3   4   5
d  6   7   8
e  9  10  11

# сортировка по строкам
df.sort_index(inplace=True)
   e   b   d
a  0   1   2
c  3   4   5
d  6   7   8
e  9  10  11

# сортировка по колонкам
df.sort_index(axis=1, inplace=True)
    b   d  e
a   1   2  0
c   4   5  3
d   7   8  6
e  10  11  9
```
- сортировка DF **по значениям** с помощью функции sort_value(ascending=False, by=, input=False). Через параметр **by** сортировать можно по одному и болле столбцам (list)

```python
df6 = pd.DataFrame(data, columns=['name', 'age', 'clicks', 'balance', 'history'], index=list('abcdefg'))
df6.sort_values(by=['balance', 'history'], inplace=True)
      name  age  clicks  balance  history
g     Igor   19       2       10        1
f     Ilya   20      18       15        2
c  Nikolay   19      12       25        1
a     Ivan   25       4       50        1
d   Sergey   33       6      115        6
e   Andrey   38       2      152        4
b     Petr   40       9      250        8
```
При сортировке по нескольким столбцам можно отдельно задавать направление сортировки для каждого столбца, например, так: df.sort_values(by=['age', 'balance'], ascending=[False, True])\

Для обеих функций сортировки могут применяться следующие интересные параметры:\
**na_position** = {‘first’, ‘last’}, по умолчанию ‘last’ - положение NaN по окончании сортировки - впереди или в конце\
**key** - функция, применяемая к сортируемому полю непосредственно перед сортировкой\
Например, key = lambda x: x.str.upper() - привести сортируемую строку к верхнему регистру\

### Описательные статистики. Уникальные значения
Непосредственно к датафрейму можно применять стандартные агрегатные функции: sum(), min(), max(), mean()\
Для того чтобы задать ось по которой будет производится агрегация нужно указать в параметрах axis=\
```python
df = pd.DataFrame({'visits_2021' : [100, 200, 300, 50, 40],
                   'visits_2020' : [90, 100, np.nan, 10, 80],
                   'visits_2019' : [10, np.nan, 20, 16, 80]}, index=['Moscow', 'Kazan', 'Ufa', 'Yakutsk', 'Novosibirsk'])
             visits_2021  visits_2020  visits_2019
Moscow               100         90.0         10.0
Kazan                200        100.0          NaN
Ufa                  300          NaN         20.0
Yakutsk               50         10.0         16.0
Novosibirsk           40         80.0         80.0

print(df.sum(axis=1))

Moscow         200.0
Kazan          300.0
Ufa            320.0
Yakutsk         76.0
Novosibirsk    200.0
dtype: float64
```

Чтобы включить в расчет nan , в параметрах соотвествующей функции прописываем skipna=False
```python
print(df.sum(axis=1, skipna=False))
Moscow         200.0
Kazan            NaN
Ufa              NaN
Yakutsk         76.0
Novosibirsk    200.0
dtype: float64
```

Если нужно учесть nan в виде нуля можно применить: **df.fillna(0).mean(axis=1, skipna=False)**
```python
print(df)
             visits_2021  visits_2020  visits_2019
Moscow               100         90.0         10.0
Kazan                200        100.0          NaN
Ufa                  300          NaN         20.0
Yakutsk               50         10.0         16.0
Novosibirsk           40         80.0         80.0
print(df.mean(axis=1))
Moscow          66.666667
Kazan          150.000000
Ufa            160.000000
Yakutsk         25.333333
Novosibirsk     66.666667
dtype: float64
print(df.mean(axis=1, skipna=False))
Moscow         66.666667
Kazan                NaN
Ufa                  NaN
Yakutsk        25.333333
Novosibirsk    66.666667
dtype: float64
print(df.fillna(0).mean(axis=1, skipna=False))
Moscow          66.666667
Kazan          100.000000
Ufa            106.666667
Yakutsk         25.333333
Novosibirsk     66.666667
dtype: float64
```

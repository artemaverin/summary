## IO

[1. Что такое поток ввода вывода?](#1-Что-такое-поток-ввода-вывода)

[2. Что такое Java IO?](#2-Что-такое-Java-IO)

[3. Что такое Java NIO?](#3-Что-такое-Java-NIO)

[4. Что такое NIO.2?](#4-Что-такое-NIO-2)

[5. Что такое Scanner?](#5-Что-такое-Scanner)

[6. Как работает Scanner внутри?](#6-Как-работает-Scanner-внутри)

[7. Какие базовые методы существуют в Scanner?](#7-Какие-базовые-методы-существуют-в-Scanner)

[8. Что такое байтовый поток? Как он реализован внутри?](#8-Что-такое-байтовый-поток-Как-он-реализован-внутри)

[9. Что такое символьный поток? Как он реализован внутри?](#9-Что-такое-символьный-поток-Как-он-реализован-внутри)

[10. Что такое буферизированный поток?](#10-Что-такое-буферизированный-поток)

[11. Какие классы обёртки позволяют ускорить чтение/запись за счет использования буфера?](#11-Какие-классы-обёртки-позволяют-ускорить-чтение-запись-за-счет-использования-буфера)

[12. Как осуществлятся ввод и вывод из командной строки?](#12-Как-осуществлятся-ввод-и-вывод-из-командной-строки)

[13. Что такое класс Console? Расскажите его АПИ.](#13-Что-такое-класс-Console-Расскажите-его-АПИ)

[14. Что такое поток данных? Data stream.](#14-Что-такое-поток-данных-Data-stream)

[15. Что такое поток объектов, Object stream.](#15-Что-такое-поток-объектов,-Object-stream)

[16. Что такое Path? Как он реализуется на разных ОС?](#16-Что-такое-Path-Как-он-реализуется-на-разных-ОС)

[17. Как получить список файлов?](#17-Как-получить-список-файлов)

[18. Как проверить что файловая сущность является файлом или папкой?](#18-Как-проверить-что-файловая-сущность-является-файлом-или-папкой)

[19. Как удалить файл?](#19-Как-удалить-файл)

[20. Как переместить файл?](#20-Как-переместить-файл)

[21. Как управлять атрибутами файла?](#21-Как-управлять-атрибутами-файла)

[22. Как создать файл?](#22-Как-создать-файл)

[23. Как создать директорию?](#23-Как-создать-директорию)

[24. Как записать в файл?](#24-Как-записать-в-файл)

[25. Как прочитать данные из файла?](#25-Как-прочитать-данные-из-файла)

[26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?](#26-Для-чего-нужны-классы-PrintStream-и-PrintWriter-В-чем-их-различие)

[27. Что такое потоки байтовых массивов? Как они устроены?](#27-Что-такое-потоки-байтовых-массивов-Как-они-устроены)

[28. Зачем нужен класс RandomAccessFile?](#28-Зачем-нужен-класс-RandomAccessFile)

[29. Данные в каком виде можно считывать байтовыми и символьными потоками?](#29-Данные-в-каком-виде-можно-считывать-байтовыми-и-символьными-потоками)

[30. Что такое сокет?](#30-Что-такое-сокет)

[31. Какие виды сокетов есть в Java? С каким протоколом они работают?](#31-Какие-виды-сокетов-есть-в-Java-С-каким-протоколом-они-работают)

[32. Как отправить через сокет сообщение?](#32-Как-отправить-через-сокет-сообщение)

[33. Что такое логирование?](#33-Что-такое-логирование)

[34. Какие уровни логирования вы знаете?](#34-Какие-уровни-логирования-вы-знаете)

[35. Какая библиотека для логирования используется в курсе? Как ее настроить?](#35-Какая-библиотека-для-логирования-используется-в-курсе-Как-ее-настроить)

[36. Опишите из каких элементов состоит формат JSON](#36-Опишите-из-каких-элементов-состоит-формат-JSON)

[37. Как преобразовать POJO в/из json?](#37-Как-преобразовать-POJO-в-из-json)

[38. Опишите из каких элементов состоит формат XML](#38-Опишите-из-каких-элементов-состоит-формат-XML)

[39. Как преобразовать POJO в/из xml?](#39-Как-преобразовать-POJO-в-из-xml)

[40. Что такое сериализация / десериализация?](#40-Что-такое-сериализация-десериализация)

[41. Что такое регулярные выражения? Зачем они нужны?](#41-Что-такое-регулярные-выражения-Зачем-они-нужны)

[42. Как создать регулярное выражение в Java?](#42-Как-создать-регулярное-выражение-в-Java)

[43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?](#43-Что-такое-метасимволы-Для-чего-они-применяются-в-регулярных-выражениях)

[26. Какие существуют виды потоков ввода/вывода?](#26-Какие-существуют-виды-потоков-ввода/вывода)

[27. Назовите основные предки потоков ввода/вывода.](#27-Назовите-основные-предки-потоков-ввода/вывода)

[28. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?](#28-Что-общего-и-чем-отличаются-следующие-потоки-InputStream-OutputStream-Reader-Writer)

[29. Что вы знаете о RandomAccessFile?](#29-Что-вы-знаете-о-RandomAccessFile)

[30. Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?](#30-Какой-класс-надстройка-позволяет-читать-данные-из-входного-байтового-потока-в-формате-примитивных-типов-данных)

[31. Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?](#31-Какой-класс-надстройка-позволяет-ускорить-чтение/запись-за-счет-использования-буфера)

[32. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?](#32-Какие-классы-позволяют-преобразовать-байтовые-потоки-в-символьные-и-обратно)

[33. Какой символ является разделителем при указании пути к ЭФС?](#33-Какой-символ-является-разделителем-при-указании-пути-к-ЭФС)

[34. Что вы знаете об интерфейсе FilenameFilter?](#34-Что-вы-знаете-об-интерфейсе-FilenameFilter)

[35. Что такое сериализация?](#35-Что-такое-сериализация)

## 1. Что такое поток ввода вывода??

`Поток ввода-вывода - это абстракция для потребления или поставки данных.` Потоки ввода-вывода связаны с физическим устройством через базовую систему ввода-вывода в Java. Благодаря абстракции потоков ввода-вывода все потоки ведут себя одинаково независимо от физического устройства (клавиатуры, консоли, файлов, сети). С помощью одних и тех же классов и методов ввода-вывода можно принимать данные с разнотипных устройств и передавать их также в разнотипные устройства, не задумываясь о реализации. Например, принять данные с клавиатуры и сохранить в файл, либо принять данные из сети и вывести на консоль. Потоки ввода-вывода избавляют нас от необходимости разбираться в отличиях ввода с клавиатуры или из файла, вывода на консоль или в файл и т.д. Таким образом, цель создания IO API - абстрактный доступ к вводу-выводу, чтобы не зависеть от подробностей реализации физических устройств.

Поток ввода - это объект, из которого можно считать данные (input) - чтение.

Поток вывода - это объект, в который можно записать данные (output) - запись.

Потоки ввода-вывода бывают байтовые и символьные. 

IO API (java.io) предназначен для чтения и записи данных в ресурсы, например, файл, сетевое подключение, консоль, буфер.

Зная об устройстве системы ввода-вывода Java, можно визуализировать процесс считывания и записи таким образом:

![imageTaskPreview (1)](https://github.com/artemaverin/summary/assets/97846877/e0e453af-3e02-4ee6-aef6-73e39de80ff5)

Приложение считывает данные из ресурса с помощью подходящей реализации потока ввода, а потом записывает эти данные в хранилище с помощью подходящего потока вывода.

В Java источник и приемник данных описаны через абстрактные классы: InputSream & OutputStream

**Предопределенные потоки ввода-вывода.**

Все приложения Java автоматически импортируют пакет java.lang. Класс System этого пакета содержит свойства исполняющей среды Java. В том числе он содержит три предопределенных потока ввода-вывода: in, out и err. Эти переменные можно использовать в любой части программы.

System.out - ссылается на стандартный поток вывода (консоль). 

System.in - ссылается на стандартный поток ввода (клавиатура). 

System.err - ссылается на стандартный поток вывода ошибок (консоль). 

Переменные out и err содержат внутри объект типа PrintStream, а переменная in содержит внутри объект типа InputStream. 

В курсе мы всегда выводили в консоль сообщения с помощью вызова переменной System.out, содержащей объект PrintStream, у которого вызывался метод println(). Это предопределенный поток вывода для этой цели.

![imageTaskSource (2)](https://github.com/artemaverin/summary/assets/97846877/a2c26044-54bf-478e-9365-aa2b4fe3baf7)


[к оглавлению](#IO)

## 2. Что такое Java IO?

IO API (java.io) предназначен для чтения и записи данных в ресурсы, например, файл, сетевое подключение, консоль, буфер.

IO API – (Input & Output) в первую очередь это Java API, которые облегчают работу с потоками. 
В `java.io` существуют так называемые потоки ввода и вывода (`InputStream` and `OutputStream`).

1. `Потокоориентированный ввод/вывод` подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. Если вы хотите произвести подобные манипуляции, вам придется сначала кэшировать данные в буфере

2. Потоки ввода/вывода (streams) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (tread) вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.

В основном `java.io` предназначен для чтения и записи данных в ресурс:

1) файл;
2) при работе с сетевым подключением;
3) `System.err`, `System.in`, `System.out`;
4) при работе с буфером.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/io_diagram.gif)

Для разных типов данных существуют разные реализации классов

|_| Byte Based| _| Character Based| _ |
| ---| ---| ---| ---| --- |
| _| Input| Output| Input| Output |
| Basic| InputStream| OutputStream| Reader / InputStreamReader| Writer / OutputStreamWriter |
| Arrays| ByteArrayInputStream| ByteArrayOutputStream| CharArrayReader| CharArrayWriter |
| Files| FileInputStream / RandomAccessFile| FileOutputStream / RandomAccessFile| FileReader| FileWriter |
| Pipes| PipedInputStream| PipedOutputStream| PipedReader| PipedWriter |
| Buffering| BufferedInputStream| BufferedOutputStream| BufferedReader| BufferedWriter |
| Filtering| FilterInputStream| FilterOutputStream| FilterReader| FilterWriter |
| Parsing| PushbackInputStream / StreamTokenizer| _| PushbackReader / LineNumberReader| _ |
| Strings| _| _| StringReader| StringWriter |
| Data| DataInputStream| DataOutputStream| _| _ |
| Data - Formatted| _| PrintStream| _| PrintWriter |
| Objects| ObjectInputStream| ObjectOutputStream| _| _ |

**Классы Java IO API**

**Базовые**

+ `InputStream` /` OutputStream` - абстрактный класс, определяющий потоковый байтовый ввод/вывод
+ `Reader` / `Writer` - Символьные потоки имеют два основных абстрактных класса `Reader` и `Writer`, 
управляющие потоками символов `Unicode`.
+ `InputStreamReader` / `OutputStreamWriter` Входной/выдодной поток, транслирующий байты в символы

**Массивы**
+ `ByteArrayInputStream` / `ByteArrayOutputStream` - использует байтовый массив в потоке.
+ `CharArrayReader` / `CharArrayWriter` - читает/пишет из символьного массива.

**Files**
+ `FileInputStream` / `FileOutputStream` - Чтение/Отправка данных в файл на диске. Реализация класса `OutputStream`                                       
+ `RandomAccessFile` / `RandomAccessFile` - Чтение/запись файлов с произвольным доступом. метод `seek()` позволяет 
переместиться к определенной позиции и изменить хранящееся там значение. 
При использовании RandomAccessFile необходимо знать структуру файла. Класс `RandomAccessFile` содержит методы для чтения 
и записи примитивов и строк UTF-8.
`RandomAccessFile` может открываться в режиме чтения ("r") или чтения/записи ("rw"). Также есть режим "rws", когда файл 
открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство.
+ `FileReader` / `FileWriter` `FileWriter` записывает данные в файл. При вводе/выводе практически всегда применяется 
буферизация, поэтому используется `BufferedWriter`.                           
Когда данные входного потока исчерпываются, метод `readLine()` возвращает `null`. Для потока явно вызывается метод `close()`; 
если не вызвать его для всех выходных файловых потоков, в буферах могут остаться данные, и файл получится неполным

**Буферизация**
+ `BufferedInputStream` / `BufferedOutputStream` - буферизируемый поток. Буферы вывода нужно для повышения производительности
+ `BufferedReader` / `BufferedWriter`

Если вы имеете меньшее количество соединений, по которым передаются большие объемы данных, то лучшим выбором станет классический дизайн системы ввода/вывода:

![dfjk](https://habrastorage.org/r/w1560/files/1f1/35b/d83/1f135bd8390444fb83552aa4fb899fbf.png)

[к оглавлению](#IO)

## 3. Что такое Java NIO?

| IO| NIO |
| ---| --- |
| Потокоориентированный| Буфер-ориентированный |
| Блокирующий (синхронный) ввод/вывод| Неблокирующий (асинхронный) ввод/вывод |
| | Селекторы |

- `Буфер-ориентированный` подход, на котором основан Java NIO немного отличается от IO. Данные считываются в буфер для последующей обработки. Вы можете двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных. В то же время, вам необходимо проверять содержит ли буфер необходимый для корректной обработки объем данных. Также необходимо следить, чтобы при чтении данных в буфер вы не уничтожили ещё не обработанные данные, находящиеся в буфере.

- `Неблокирующий режим` Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим.

Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.

Таким образом неблокирующий режим Java NIO позволяет использовать один поток выполнения для решения нескольких задач вместо пустого прожигания времени на ожидание в заблокированном состояний. Наиболее частой практикой является использование сэкономленного времени работы потока выполнения на обслуживание операций ввода/вывода в другом или других каналах.

- `Селекторы` в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода. Вы можете зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.

![image](https://github.com/artemaverin/summary/assets/97846877/a3f11727-a2e2-4cc1-bf0f-9802b169e021)

Чтобы лучше понять концепцию и выгоду от применения селекторов, давайте абстрагируемся от программирования и представим себе железнодорожный вокзал. Вариант без селектора: есть три железнодорожных пути (каналы), на каждый из них в любой момент времени может прибыть поезд (данные из буфера), на каждом пути постоянно ожидает сотрудник вокзала (поток выполнения), задача которого – обслуживание прибывшего поезда. В результате трое сотрудников постоянно находятся на вокзале даже если там вообще нет поездов. Вариант с селектором: ситуация та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику вокзала (поток выполнения) о прибытии поезда. Таким образом на вокзале достаточно присутствия одного сотрудника.


**Предпосылки создания:**

Недостатки IO:

+ The `File` class lacked some important functionality, such as a copy method.
+ It also defined many methods that returned boolean. As one can imagine, in case of an error, `false` was returned, 
rather than throwing an exception. The developer had, indeed, no way of knowing why it failed.
+ Did not provide good handling on support of symbolic links.
+ A limited set of file attributes was provided.

To overcome these problems, java.nio package was introduced in java 4. The key features were:
+ Channels and Selectors: A channel is an abstraction on lower-level file system features, e.g. memory-mapped files.
+ Buffers: Buffering for all primitive classes (except for Boolean).
+ Charset: Charset (`java.nio.charset`), encoders, and decoders to map bytes and Unicode symbols

With java 7 the `java.nio.file` package is introduced providing a better support for handling symbolic links, 
file attributes access and specially to support extended the file system through classes such 
as **Path, Paths and Files**.

Состоит из 3 основных компонентов:
+ `Channels`
+ `Buffers`
+ `Selectors`

Java NIO: Channels read data into Buffers, and Buffers write data into Channels
There are several Channel and Buffer types. Here is a list of the primary Channel implementations in Java NIO:
+ `FileChannel`
+ `DatagramChannel`
+ `SocketChannel`
+ `ServerSocketChannel`

A Selector allows a single thread to handle multiple Channel's. 
This is handy if your application has many connections (Channels) open, but only has low traffic on each connection. 
For instance, in a chat server.

Example.
```java
RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
    FileChannel inChannel = aFile.getChannel();
    ByteBuffer buf = ByteBuffer.allocate(48);
    int bytesRead = inChannel.read(buf);
    while (bytesRead != -1) {
      System.out.println("Read " + bytesRead);
      buf.flip();
      while(buf.hasRemaining()){
          System.out.print((char) buf.get());
      }
      buf.clear();
      bytesRead = inChannel.read(buf);
    }
    aFile.close();
```

Java NIO позволяет управлять несколькими каналами (сетевыми соединениями или файлами) используя минимальное число потоков выполнения. Однако ценой такого подхода является более сложный, чем при использовании блокирующих потоков, парсинг данных.

Если вам необходимо управлять тысячами открытых соединений одновременно, причем каждое из них передает лишь незначительный объем данных, выбор Java NIO для вашего приложения может дать преимущество. Дизайн такого типа схематически изображен на следующем рисунке:

![smimg](https://habrastorage.org/r/w1560/files/b21/6b7/736/b216b77362834dfe930a26faebe5b457.png)

[к оглавлению](#IO)

## 4. Что такое NIO.2?

с выходом версии Java 1.7 появился еще и Java NIO.2, но присущие ему новшества касаются, в первую очередь, работы с `файловым вводом/выводом`

Это совершенно новый подход, в отличии от старого java.io.File призванный полностью его заменить во всех аспектах, касающихся взаимодействия с файловой системой.

NIO2 уже по-умолчанию имеет удобные возможности исполнения в многопоточном приложении. Без мучительных конфигураций можно исполнять операции работы с фаловой системой или сетью в фоновом потоке.

Со всех сторон упрощает кодинг и привносит даже новые возможности? которые ранее были не доступны. Например работа напрямую с символическими ссылками.
Вот некоторые из методов, которые сильно упрощают жизнь:

Files.walkFileTree()
Files.isSymbolicLink()
Files.readAttributes()

Новое апи хорошо оптимизировали для работы с конкретной ОС используюся ее те или иные нативные преимущества для скорости работы с ФС сетью, большими файлами.

Улучшения касаются оптимизации работы приложения на нескольких многоядерных процессоров, которые позволяют программе исполняться в "настоящей" мультипоточной манере. Представляет программистам достаточно простую абстракцию для мультипоточной работы с файлами и сокетами.

[к оглавлению](#IO)

## 5. Что такое Scanner?

Исходя из названия класса «Scanner», можно догадаться, что этот класс имеет смысл использовать для «сканирования» источника данных. Под сканированием подразумевается нахождение последовательности символов среди данных источника. Формально говоря, последовательность символов называется токеном или лексемой, а процесс сканирования лексическим анализом.

Токенами могут быть примитивы, строки (в значении с англ. line), символьные выражения, соответствующие регулярному выражению и т.п.. В общем все, что может быть представлено в виде последовательности символов.

Для выделения последовательности символов необходимо знать шаблон, по которому их нужно выделять. В общем случае, это регулярное выражение. Однако, регулярные выражения трудно читаемы, если у Вас мало навыков работы с ними. В этом случае нам на помощь приходит Scanner, который поддерживает большинство шаблонов, например, по поиску примитивов. Тем не менее, шаблон есть всегда. Если мы его не задаем, он как-то задается внутри Scanner.

Важно! В Scanner в качестве шаблона задается разделитель между токенами, а не сам шаблон токенов, как при работе с обычными регулярными выражениями.

Класс java.util.Scanner может быть полезен, когда нужно вычленить из данных только те, что Вам нужны. Для этого нужно назначить разделитель, например, пробел, запятая или регулярное выражение. Также Scanner имеет полезную особенность для чтения чисел различных систем счисления. 

`Scanner` - класс в `java.util` для чтения данных примитивных типов `int`, `double`, `String` и т.д. 
Это самый простой способ для получения входящих данных, но не самый эффективный если есть ограничения по времени.

Обычно создается в виде
```
Scanner sc = new Scanner(System.in);
```
Для чтения данных типа `XYZ` используется метод `nextXYZ()`. Для проверки что есть данные такого типа `hasNextXYZ()`

Например:
+ `hasNextBoolean()`
+ `hasNextByte()`
+ `hasNextDouble()`
+ `hasNextFloat()`
- -------------------------------------------------------------------------------------

`Scanner` (от англ. scanner — считыватель, сканер) — это класс в языке программирования Java, предназначенный для чтения данных из файлов или стандартного ввода.

Scanner позволяет пользователю вводить данные, которые затем можно использовать в программе. Он также может использоваться для обработки данных, полученных с помощью других источников, таких как сетевые соединения, базы данных и т.д.

В Java Scanner является удобным инструментом для работы с потоками ввода-вывода, так как он позволяет пользователю легко обрабатывать данные, не заботясь о том, как они были получены.

[к оглавлению](#IO)

## 6. Как работает Scanner внутри?

Сам класс работает как Iterator, т.к. поддерживает данный интерфейс.

Причем большинство методов можно разделить на hasTYPE и nextTYPE, где TYPE - это тип по шаблону которого будет происходить отделение токенов друг от друга. Например, hasInt(), nextInt().

В качестве источника данных Scanner принимает любой вид данных, включая Reader, InputStream, File для java.io и Readable, Path для java.util.nio. Также можно задать источник в виде строки String.

![image](https://github.com/artemaverin/summary/assets/97846877/b40d337f-fe7e-4439-9df9-ed69ea06c194)


#1
```java
public class ScannerExample2 {
    public static void main(String[] args) {
        var data = "empl1@mail.ru, empl2@mail.ru, empl3@mail.ru";
        var scanner = new Scanner(new ByteArrayInputStream(data.getBytes()))
                .useDelimiter(", ");
        while (scanner.hasNext()) {
            System.out.println(scanner.next());
        }
    }
}
```

Здесь в качестве источника мы указали одну из реализаций InputStream – ByteArrayInputStream. В качестве разделителя с помощью метода useDelimiter() мы указали нужный разделитель.

В данном случае мы могли воспользоваться методом String.split(), но когда дело доходит до чтения файлов, то Scanner позволяет использовать преимущества буферизированных потоков и возможности по разбиению на токены.

#2

Еще одной интересной возможностью Scanner является возможность задать систему счисления при чтении чисел. Например, можно прочитать числа в шестнадцатеричном виде и вывести в десятичном таким образом:

```java
public class ScannerExample3 {
    public static void main(String[] args) throws Exception {
        var data = "A 1B FF 110";
        var file = File.createTempFile("data", null);
        try (BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file))) {
            out.write(data.getBytes());
        }
        try (var scanner = new Scanner(file).useRadix(16)) {
            while (scanner.hasNextInt()) {
                System.out.print(scanner.nextInt());
                System.out.print(" ");
            }
        }
    }
}
```

Теперь мы указываем в качестве источника данных временный файл, который создаем и в который записываем предварительно. Метод useRadix() указывает в какой системе счисления находятся входные числа.

Важно! Если Scanner работает с внешними источниками его нужно использовать с try-with-resources.

использует регулярные выражения
```java
private static final String LINE_SEPARATOR_PATTERN =
                                           "\r\n|[\n\r\u2028\u2029\u0085]";
private static Pattern NON_ASCII_DIGIT = Pattern.compile(
        "[\\p{javaDigit}&&[^0-9]]");
```                                           
кеширует значения
```java
public String nextLine() {
       modCount++;
        if (hasNextPattern == linePattern())
            return getCachedResult();
        clearCaches();
        String result = findWithinHorizon(linePattern, 0);
        if (result == null)
            throw new NoSuchElementException("No line found");
        MatchResult mr = this.match();
        String lineSep = mr.group(1);
        if (lineSep != null)
            result = result.substring(0, result.length() - lineSep.length());
        if (result == null)
            throw new NoSuchElementException();
        else
            return result;
    }
```  
Java `Scanner` class extends `Object` class and implements `Iterator` and `Closeable` interfaces.

[к оглавлению](#IO)

## 7. Какие базовые методы существуют в Scanner?

+ `delimiter()` It is used to get the Pattern which the Scanner class is currently using to match delimiters.
+ `hasNextLine` 
+ `nextLine`
+ `hasNextInt` 
+ `nextInt` ...

- `public boolean hasNext()` - Возвращает true, если у этого сканера есть другой токен на входе.
- `public boolean hasNext(String pattern)` - Возвращает true, если следующий токен соответствует шаблону, созданному из указанной строки.
- `public boolean hasNext(Pattern pattern)` - Возвращает true, если следующий полный токен соответствует указанному шаблону.

и множество вариаций:

- `public boolean hasNextLine()` - возвращает логический тип данных, который соответствует новой строке String, которую содержит объект Scanner.
- `public boolean hasNextBoolean()` - проверяет, имеет ли объект логический тип данных в своем буфере.
- `public boolean hasNextByte()` - возвращает значение true, если следующий байт в буфере сканера можно преобразовать в тип данных байта, в противном случае – значение false.

и тд

- `public String next()` - Находит и возвращает следующий полный токен.
- `public String next(String pattern)` - Возвращает следующий токен, если он соответствует шаблону, созданному из указанной строки.
- `public String next(Pattern pattern)` - Возвращает следующий токен, если он соответствует указанному шаблону.

также множество вариаций:

- `public String nextLine()` - Перемещает сканер за текущую строку и возвращает пропущенный ввод.
- `public boolean nextBoolean()` - Сканирует следующий токен ввода как логическое значение и возвращает его.
- `public byte nextByte()` - как byte.

- `public Scanner useDelimiter(Pattern pattern)` - Устанавливает шаблон ограничения этого сканера в указанный шаблон.
- `public Scanner useDelimiter(String pattern)` - как метод выше, но созданный из указанной строки.
- `public Scanner useRadix(int radix)` - Устанавливает radix равным указанному.

https://hr-vector.com/java/class-scanner

https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html

[к оглавлению](#IO)

## 8. Что такое байтовый поток Как он реализован внутри?

Byte streams работает с данными побайтово (8 bits). Например, `FileInputStream` используется для чтения 
и `FileOutputStream` для записи. Byte streams интерфейс, который внутри основан на байтовом массиве. 
В основе находится некий буфер который заполняется, вычитывается и заново заполняется. Методы внутри native.
```java
private native int read0() throws IOException;
```

Байтовые потоки предоставляют средства ввода-вывода отдельных байтов, например, чтения и записи двоичных данных. 

В основе байтовых потоков лежат абстрактные классы InputStream и OutputStream (потоки ввода и вывода соответственно). Каждый из этих классов имеет свои классы-реализации, которые учитывают особенности разных устройств (файлов на диске, сетевых соединений, буферов памяти и т.д.). 

Ниже перечислены классы-реализации абстрактных классов InputStream и OutputStream. Многие из них мы будем изучать далее в этом разделе, поэтому вдаваться в их подробности сейчас не нужно.



Основные классы-реализации InputStream (потоки ввода):

    - ByteArrayInputStream - читает байты из массива

    - FileInputStream - читает данные из файла

    - ObjectInputStream - поток ввода объектов

    - PipedInputStream - канал ввода

    - FilterInputStream - реализует класс InputStream. От него реализуются следующие 3 класса:

            - BufferedInputStream - буферизированный поток ввода

            - DataInputStream - читает данные примитивных типов

            - PushbackInputStream - поток ввода, поддерживающий возврат одного байта обратно в поток ввода



Основные классы-реализации OutputStream (потоки вывода):

    - ByteArrayOutputStream - записывает байты в массив

    - FileOutputStream - записывает данные в файл

    - ObjectOutputStream - поток вывода объектов

    - PipedOutputStream - канал вывода

    - PrintStream - поток вывода, содержащий методы print() и println()

    - FilterOutputStream - реализует класс OutputStream. От него реализуются следующие 2 класса:

            - BufferedOutputStream - буферизированный поток вывода

            - DataOutputStream - записывает данные примитивных типов



Важно! Все классы, имеющие в названии InputStream/OutputStream читают/пишут данные побайтово.

[к оглавлению](#IO)

## 9. Что такое символьный поток Как он реализован внутри?

В Java, символы хранятся в кодировке `Unicode` (16 bit). Символный поток позволяет читать данные символ за символом. 
Например `FileReader` и `FileWriter` символьные потоки.
Для них можно задать кодировку:
```java 
Reader reader = new InputStreamReader(in, "UTF-8");
``` 

Символьные потоки предоставляют средства ввода-вывода отдельных символов. В них применяется кодировка Юникод. Читать данные по байтам в большинстве случаев неудобно, поэтому были введены символьные потоки, которые во многих случаях более эффективны, чем байтовые, так как считывают целиком символы, а не байты. Но на низком уровне весь ввод-вывод в java все равно имеет байтовую организацию.

В основе символьных потоков лежат абстрактные классы Reader и Writer (потоки ввода и вывода соответственно). Каждый из этих классов также имеет свои классы-реализации, которые учитывают особенности разных устройств (файлов на диске, сетевых соединений, буферов памяти и т.д.). 

Ниже перечислены классы-реализации абстрактных классов Reader и Writer. Многие из них мы будем изучать далее в этом разделе, поэтому вдаваться в их подробности сейчас не нужно.


Основные классы-реализации Reader (потоки ввода символов):

    - BufferedReader - буферизированный поток ввода символов

    - CharArrayReader - читает символы из массива

    - PipedReader - канал ввода

    - StringReader - читает символы из строки

    - FilterReader - фильтрованный поток чтения. От этого класса наследуется класс PushbackReader:

            - PushbackReader - поток ввода, позволяющий вернуть считанные символы обратно в поток ввода

    - InputStreamReader - преобразует байты в символы. От этого класса наследуется класс FileReader:

            - FileReader - читает символы из файла


Основные классы-реализации Writer (потоки вывода символов):

    - BufferedWriter - буферизированный поток вывода символов

    - CharArrayWriter - записывает символы в массив

    - PipedWriter - канал вывода

    - StringWriter - записывает символы в строку

    - FilterWriter - фильтрованный поток записи. 

    - PrintWriter - поток вывода, содержащий методы print() и println()

    - OutputStreamWriter - преобразует символы в байты. От этого класса наследуется класс FileWriter:

            - FileWriter - записывает символы в файл


Важно! Способ чтения/записи с помощью классов, имеющих в названии Reader/Writer зависит от конкретной реализации. (текст и символы).


Ключевыми методами абстрактных классов InputStream, OutputStream, Reader и Writer являются методы read() - считать данные, и write() - записать данные. В данных классах эти методы абстрактные, они переопределяются во всех их классах-реализациях. 

[к оглавлению](#IO)

## 10. Что такое буферизированный поток?

Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный 
буфер в памяти, с помощью которого повышается производительность при чтении и записи потоков.
`BufferedInputStream` и `BufferedOutputStream`. 
Это может сделать программу намного эффективней, т.к. каждый такой запрос часто инициировал доступ к диску, сетевое 
действие, или некоторую другую работу, которая относительно дорога.

Буферизированный поток - это стандартный поток, к которому добавлен специальный буфер в памяти, который увеличивает производительность чтения и записи. Обращение к ресурсу при чтении/записи - это очень затратный процесс, поэтому чем меньше обращений к ресурсу - тем лучше. `Буферизированные потоки - это обёртки обычных потоков с буфером.`

Классы с InputStream/OutputStream в названии читают и пишут побайтово. То есть, например, метод read() читает всего один байт за раз. Такой способ чтения/записи очень медленный.

Для ускорения процессов существуют буферизированные потоки. Они увеличивают производительность программы за счет считывания некоторого объема данных в буфер. Пример из реального мира: если нам нужно переложить, например, какие-то вещи из одного места в другое, мы воспользуемся пакетом, чтобы унести сразу несколько вещей, а не носить их по одной. Пакет - это и есть буфер.

Зачем нужен буфер? Манипуляции с буфером происходят быстрее, чем манипуляции напрямую с внешним ресурсом (Например, сетью или жестким диском). Буфер выгоден тем, что при записи данных на диск, данные не пишутся непосредственно на ресурс (диск), а сохраняются в буфере потока. В этом случае данные будут записаны на диск либо при закрытии потока, либо при явном вызове метода flush(), который переводит накопленные буфером данные в поток. 

Главный плюс буфера в том, что мы не обращаемся к диску за каждой единицей данных. Если нам нужно считать данные, то в буфер считается больший объем, чем нужно, и при следующем чтении оно будет производится из буфера, не обращаясь к ресурсу. Так же и при записи, например, на диск данные будут записываться сразу большими блоками.

Как уже говорилось выше, каждое обращение к внешнему ресурсу - дорогостоящая операция. Например, метод read() в нашей программе инициирует системный вызов, который обращается к операционной системе для выполнения операции чтения с ресурса. Аналогично и с методом write(). Запросы к ОС сопровождаются дополнительной тратой времени и ресурсов. Буфер помогает уменьшить количество таких обращений, соответственно, ускоряет работу программы. Считав данные в буфер, мы можем работать с его данными внутри программы, не обращаясь для этого к ОС. Новое чтение с диска или запись на диск (физический) происходит только когда все данные из буфера чтения уже прочитаны, либо буфер записи уже переполнен (либо принудительно через метод flush()). 

Буферное побайтовое чтение/запись реализовано классами BufferedInputStream и BufferedOutputStream.

Буферное посимвольное чтение/запись реализовано классами BufferedReader и BufferedWriter.

Все buffered* классы являются обёртками и не могут существовать сами по себе. При создании объектов этих классов в их конструкторы нужно передавать объекты классов-реализаций InputStream/OutputStream. Могут быть и цепочки обёрток, но в корне всегда должен быть байтовый или символьный поток.

объекты классов BufferedInputStream и BufferedOutputStream создаются с помощью следующих конструкторов:

- public BufferedInputStream(InputStream in)
- public BufferedInputStream(InputStream in, int size)

- public BufferedOutputStream(OutputStream out)
- public BufferedOutputStream(OutputStream out, int size)

то есть в конструкторы этих классов мы должны передать какие-либо реализации интерфейсов InputStream и OutputStream. В нашем случае мы буферизируем побайтовое чтение из файла и запись в файл, поэтому в буферизированные обёртки BufferedInputStream и BufferedOutputStream передаём реализации побайтового чтения и записи - FileInputStream и FileOutputStream. Буферизированные обёртки реализуют шаблон декоратор. Подробнее об этом будет в следующих уроках.

Cуществуют не только классы, представляющие из себя сами потоки (например, FileInputStream), но и классы-обёртки для таких классов (например BufferedInputStream для FileInputStream), выполняющие какую-то полезную функцию.

Практически у всех байтовых классов *InputStream / *OuputStream существует свой символьный аналог *Reader / *Writer. Работают они аналогично друг другу. Выбор того или иного класса должен зависеть от того, в каком виде представлены данные, с которыми нужно работать.

В заключение можно сказать, что в уроках по IO в показательных целях могут применяться различные байтовые и символьные потоки для чтения различных типов данных, но нужно запомнить важный момент: если нужно работать только с текстовыми (символьными) данными, то рекомендуется использовать символьные потоки и их обёртки (*Reader / *Writer), а если данные имеют байтовый или смешанный вид, то рекомендуется применять байтовые потоки и их обёртки (*InputStream / *OuputStream). Это важно не только с точки зрения производительности, но и с точки зрения целостности данных. Например, нельзя прочитать файл png символьным потоком, так как *.png файл содержит только байтовые данные, которые невозможно привести к символам.

https://job4j.ru/profile/exercise/45/task-view/1059

[к оглавлению](#IO)

## 11. Какие классы-обёртки позволяют ускорить чтение/запись за счет использования буфера?

Для ускорения процессов существуют буферизированные потоки. Они увеличивают производительность программы за счет считывания некоторого объема данных в буфер. Пример из реального мира: если нам нужно переложить, например, какие-то вещи из одного места в другое, мы воспользуемся пакетом, чтобы унести сразу несколько вещей, а не носить их по одной. Пакет - это и есть буфер.

Главный плюс буфера в том, что мы не обращаемся к диску за каждой единицей данных. Если нам нужно считать данные, то в буфер считается больший объем, чем нужно, и при следующем чтении оно будет производится из буфера, не обращаясь к ресурсу. Так же и при записи, например, на диск данные будут записываться сразу большими блоками.

- `BufferedInputStream(InputStream in)/BufferedInputStream(InputStream in, int size)`
- `BufferedOutputStream(OutputStream out)/BufferedOutputStream(OutputStream out, int size)`
- `BufferedReader(Reader r)/BufferedReader(Reader in, int sz)`
- `BufferedWriter(Writer out)/BufferedWriter(Writer out, int sz)`

[к оглавлению](#IO)


## 12. Как осуществлятся ввод и вывод из командной строки?

По умолчанию ввод с клавиатуры, вывод на монитор.

Все приложения Java автоматически импортируют пакет java.lang. Класс System этого пакета содержит свойства исполняющей среды Java.

Класс `System` содержит также три переменные предопределенных потоков ввода-вывода: `in`, `out` и `err`   
+ Переменная `System.out` ссылается на стандартный поток вывода. По умолчанию это консоль.
+ Переменная `System.in` ссылается на стандартный поток ввода, которым по умолчанию является клавиатура.
+ `System.err` - для ошибок.

[к оглавлению](#IO)

## 13. Что такое класс Console Расскажите его АПИ?

Альтернатива стандратным потокам ввода / вывода класс `Console`.

Класс Console предназначен для работы с консолью - командной строкой Windows или терминалом Linux/MacOS и упрощает работу с ними. Класс Console определён в пакете java.io. 

Для консольного ввода-вывода этот класс использует уже запущенные в системе потоки System.in и System.out. 

Для создание экземпляра используется `System.console()`. Метод может вернуть `null`, если консоль недоступна. 
Консоль позволяет вводить пароль используя метод `readPassword` (не видны символы при вводе, не сохраняется в памяти). 

Доступ к консоли (командной строке) можно получить только из самой командной строки. Попытка получить объект консоли в любой среде разработки вернёт null, поэтому полученный объект требуется проверять на null.
   
полезные методы класса Console:

- readLine() - читает с консоли строку, которую ввёл пользователь. Сохраняет данные в String.
- readPassword() - читает с консоли строку, которую ввёл пользователь. Отличие от метода readLine() в том, что вводимые пользователем символы не будут отображаться на консоли в целях безопасности. Сохраняет данные в char[] - массив байтов.
- format() и printf() - эти методы мы уже знаем. format() сохраняет отформатированную строку, а printf() выводит отформатированную строку на печать без сохранения.
- flush() - принудительно выводит в консоль все данные, находящиеся в буфере в данный момент.

Наша JVM запущена не из стандартной интерактивной консоли операционной системы, а из среды разработки, поэтому у неё нет связи с консолью (командной строкой), соответственно, мы не можем получить объект консоли и взаимодействовать с ней. Чтобы получить доступ к консоли (командной строке), нужно запустить программу непосредственно из неё. 


https://job4j.ru/profile/exercise/45/task-view/1071
[к оглавлению](#IO)

## 14. Что такое поток данных Data stream?

Класс DataOutputStream позволяет записывать примитивные типы данных, а также строковые значения в байтовом представлении, а класс DataInputStream позволяет считывать примитивы из их байтового представления. 

Классы DataInputStream и DataOutputStream реализуют интерфейсы DataInput и DataOutput соответственно. Эти интерфейсы содержат методы, с помощью которых можно читать и записывать примитивы и строки в поток. Например, writeBoolean(), writeDouble(), readBoolean(), readDouble() и т.д. Эти методы преобразуют значения примитивных типов в последовательность байтов и наоборот. Таким образом упрощается хранение данных в двоичной форме в файлах.

DataInputStream и DataOutputStream являются обёртками и не могут существовать сами по себе. При создании объектов этих классов в их конструкторы нужно передавать объекты классов-реализаций InputStream/OutputStream. Могут быть и цепочки обёрток, но в корне всегда должен быть сам байтовый поток.

```java
try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path));
             DataInputStream in = new DataInputStream(new FileInputStream(path))) {
```

Здесь важно понимать, что в файл мы пишем данные в двоичном формате, поэтому считывать записанные данные нужно в том же порядке и в те же типы данных, так как код в файле - это просто набор байтов. В файле нет никакой информации о типе данных или месте начала/конца каких-либо значений. Не зная порядок, в котором мы задавали данные в этот файл, прочитать эту информацию будет невозможно. 

Например, при записи значения типа int в файл будет помещено 4 байта информации, при записи значения типа double - 8 байт и т.д. Если мы записали в файл сначала int (4 байта), потом double (8 байт), то при попытке считать сначала double, а потом int, мы получим некорректные значения, так как чтение из файла будет происходить тоже побайтово, то есть каждый метод read*** будет считывать столько байт, какой тип у него идёт в названии вместо звёздочек (readInt - 4 байта и т.д.). В результате сначала вместо 4 байт мы считаем 8, а потом вместо 8 байт - 4, поэтому считывание нужно производить в те же переменные и в той же последовательности, в которой они были записаны в файл.

Во всех методах интерфейса DataInput информация о достижении конца файла возвращается не в виде значения -1, как это было в методе read() предыдущих классов, а с помощью выброса исключения EOFException - End of file exception. 

https://job4j.ru/profile/exercise/45/task-view/1069

[к оглавлению](#IO)

## 15. Что такое поток объектов, Object stream?

Потоки объектов представлены в пакете java.io классами ObjectInputStream и ObjectOutputStream. ObjectOutputStream превращает объект в его байтовое представление. ObjectInputStream восстанавливает объект из байтового представления в обычное. Эти процессы называются сериализацией и десериализацией соответственно. С помощью этих операций можно сохранить объект (состояние объекта) в виде последовательности байт, удобной для передачи по сети, и восстановить эту последовательность байт обратно в объект, например, на другом компьютере.

Классы ObjectInputStream и ObjectOutputStream наследуют классы InputStream / OutputStream и реализуют интерфейсы ObjectInput / ObjectOutput, которые, в свою очередь, наследуют интерфейсы DataInput / DataOutput, с которыми мы уже знакомы из урока по потокам данных. Интерфейсы ObjectInput и ObjectOutput наследуют все методы интерфейсов DataInput и DataOutput, а также определяют методы readObject() и writeObject() соответственно, с помощью которых производится непосредственное преобразование объекта в байтовое представление и обратно. А так как унаследованы все методы интерфейсов DataInput / DataOutput, то потоки объектов могут содержать и примитивные, и объектные значения.

`ObjectOutputStream` используется для конвертации объектов в поток. В java это называется сериализация. 
Объект преобразоыванный таким образом может быть сохранен в базу данных, передан по сети и т.п. 
Для записи в файл можно использовать `FileOutputStream`.
Объект который передается в потоке должен реализовывать интерфейс `java.io.Serializable`.
```java
FileOutputStream fos = new FileOutputStream("EmployeeObject.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);
// write object to file
oos.writeObject(emp);
```

При сериализации используют переменную `SerialVersionUID`. 
Во время сериализации, среда выполнения Java создает номер версии для класса, так что она может десереализировать 
его позже. В Java этот номер версии известен как `SerialVersionUID`. Если во время десериализации, `SerialVersionUID` 
не соответствует, то процесс завершится с исключением

`SerialVersionUID` используется для указании версии сериализованных данных.
+ Когда мы не объявляем `SerialVersionUID` в нашем классе, среда выполнения Java делает это за нас, но этот процесс 
чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, 
которые реализованы в классе и пр. Вы можете найти точную информацию в документации о сериализации от Oracle.
+ Рекомендуется объявлять `SerialVersionUID` как `private static final long` переменную во избежание механизма по умолчанию.

https://job4j.ru/profile/exercise/45/task-view/1072

[к оглавлению](#IO)

## 16. Что такое Path Как он реализуется на разных ОС?

Java 7 представляет новую абстракцию для пути, а именно интерфейс `Path`. Он используется в новых функциях и API, 
по всему NIO.2. Объект пути содержит имена каталогов и файлов, которые составляют полный путь до файла/каталога, 
представленного объектом `Path`. 

`Path` содержит методы для извлечения элементов пути, манипуляций с ними и их добавления.

Путь к файлу, в разных системх может записываться по разному, `\` или `/`, поэтому лучше
использовать `File.separator` для построения пути
```java
// Cоздание объекта Path через вызов статического метода get() класса Paths 
Path testFilePath = Paths.get("/home/heorhi/testfile.txt"); 
         
//Пример строки создания объекта Path пути для запуска в Windows 
Path testFilePath = Paths.get("D:\\test\\testfile.txt");
```
- -----------------------------------------------------------------------

Класс Path включает в себя различные методы, которые могут быть использованы для получения информации о пути, получения доступа к элементам пути, преобразования пути в другие формы, извлечения части пути.

Path - это интерфейс. Так как у разных файловых систем есть свои особенности, интерфейс дает возможность реализовать собственную версию - наследника интерфейса Path в разных операционных системах. Path имеет несколько реализаций под некоторые операционные системы. При создании объекта Path, под капотом создается специальный объект, представляющий реализацию операционной системы, в которой он создается. Так как в разных ОС пути могут быть записаны по-разному, то объект, созданный в одной ОС, может не работать в другой ОС. 

В документации интерфейса Path указан следующий вариант корректного использования Path в условиях кроссплатформенности:

```java
Path path = FileSystems.getDefault().getPath("logs", "access.log");
BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);
```

В следующей строке 

```java
Path path = FileSystems.getDefault().getPath("logs", "access.log");
```

в параметры метода getPath() передаются части пути отдельными строками. При создании пути, из этих частей программой будет определен разделитель с помощью метода FileSystem.getSeparator(), и с помощью этого разделителя будет собрана строка. В данном случае будет определен разделитель той ОС, в которой выполняется программа.

Например, в ОС Windows путь из примера будет собран с помощью разделителя "\" таким образом: logs\access.log

Создать объект Path можно двумя способами.

1.
```java
Path dir = Paths.get("path/paths");
        Files.createDirectories(dir);
```

Здесь создается новая директория. Путь к файлу инкапсулируется в объект интерфейса Path с помощью метода Paths.get(). Класс Paths был введен в JDK 7 с обновлением NIO API. Этот класс содержит единственный метод get(), который помещает путь внутрь объекта Paths. Далее создаются директории на диске в корне проекта с помощью метода createDirectories() класса Files (метод создаёт директории, даже если их не существовало). Класс Files также появился с обновлением NIO API в JDK 7, в этот класс были вынесены статические методы из класса File для работы с объектом Path. 



2.
```java
Path path = Path.of("path/paths/path.txt");
        Files.createFile(path);
```

Здесь создаётся новый файл. Второй способ заключается в том, что путь к файлу инкапсулируется с помощью метода of() класса Path. Рекомендуется использовать этот способ, так как метод Paths.get() под капотом вызывает метод Path.of(). Метод Path.of() был создан с целью визуального восприятия, что это фабричный метод, как и другие of() методы в Java, так как метод get() не совсем соответствовал его смыслу. Далее создается файл на диске в директории paths с помощью метода createFile().

Если повторно попытаться создать уже существующий файл или директорию, то будет выброшено исключение FileAlreadyExistsException, говорящее о том, что данный файл (в конкретном примере директория), уже существует. Теперь мы можем знать о проблеме и можем ее обрабатывать, в отличие от поведения класса File, когда бы мы получили просто false.

https://job4j.ru/profile/exercise/45/task-view/1016
[к оглавлению](#IO)

## 17. Как получить список файлов?
**Ответ № 1**
+ Без учета подпапок
```java
File file = new File("dir");
File[] filesArr = file.listFiles();
String[] filesNames = file.list();
```

**метод Files.newDirectoryStream()**

Метод newDirectoryStream() возвращает поток, содержащий файлы и директории, находящиеся в директории path (без вложенных). В следующих строках мы получаем этот поток и выводим все его элементы на печать:
```java
DirectoryStream<Path> paths = Files.newDirectoryStream(target);
paths.forEach(System.out::println);
```

+ С учетом подпапок
```java
public void listFilesForFolder(final File folder) {
    for (final File fileEntry : folder.listFiles()) {
        if (fileEntry.isDirectory()) {
            listFilesForFolder(fileEntry);
        } else {
            System.out.println(fileEntry.getName());
        }
    }
}
final File folder = new File("/home/you/Desktop");
listFilesForFolder(folder);
```
 
**Java 8**
+ Java NIO без учета подпапок
```java
Stream<Path> stramFiles = Files.list(Paths.get("dir"));
```
+ С учетом подпапок. Files.walk API is available from Java 8.
```java
try (Stream<Path> paths = Files.walk(Paths.get("/home/you/Desktop"))) {
    paths
        .filter(Files::isRegularFile)
        .forEach(System.out::println);
}
```
+ Через `walkFileTree` 
(The difference between `walk` and `walkFileTree` is that they supply different interfaces for walking the tree: 
`walkFileTree` takes `FileVisitor`, walk gives `Stream<Path>`)
```java
Files.walkFileTree(directory, Collections.emptySet(), 1, new SimpleFileVisitor<Path>() {
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        doSomething(file);
        return FileVisitResult.CONTINUE;
    }
    
    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) {
        // log exc
        return FileVisitResult.CONTINUE;
    }
});
```

**Ответ № 2**

1. С помощью методов `new File().list()` и `new File().listFiles()` вызываемых у объекта класса **File**
```java
File target = new File("src/main/java/ru/job4j/io/files");
String[] list = target.list(); 
        for (String f : list) {
            System.out.println(f);
        }
        File[] listFiles = target.listFiles(); 
        for (File f : listFiles) {
            System.out.println(f);
        }
```

метод list() возвращает массив строк с именами файлов и директорий, содержащихся в директории files
метод listFiles() возвращает массив объектов типа File с инкапсулированными путями расположения этих объектов в файловой системе, содержащихся в директории files

2. С помощью встроенного механизма FileVisitor  метода класса Files - public static Path walkFileTree(Path start, FileVisitor<? super Path> visitor) throws IOException

```java
public class PrintFiles implements FileVisitor<Path> {


    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
        return CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        System.out.println(file.toAbsolutePath());
        return CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
        return CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        return CONTINUE;
    }
}
```
Интерфейс FileVisitor имеет 4 метода. Нас будет интересовать только visitFile. Java последовательно передает в него файлы, а программист их обрабатывает.

```java
public class Search {
    public static void main(String[] args) throws IOException {
        Path start = Paths.get(".");
        Files.walkFileTree(start, new PrintFiles());
    }
}
```
2.1. Существует еще варинт  с SimpleFileVisitor
_SimpleFileVisitor_ уже реализует FileVisitor, переопределяя все методы только с указанием на дальнейший обход CONTINUE.

Это означает, что унаследовавшись от него мы можем переопределить только нужный нам метод.

3. **метод Files.newDirectoryStream()**

```java
DirectoryStream<Path> paths = Files.newDirectoryStream(target);
paths.forEach(System.out::println);
```

https://habr.com/ru/articles/437694/
 
[к оглавлению](#IO)
 
## 18. Как проверить что файловая сущность является файлом или папкой?

```java
File file = new File("/Users/pankaj/source.txt");
File dir = new File("/Users/pankaj");
File notExists = new File("/Users/pankaj/notafile");
        
System.out.println("/Users/pankaj/source.txt is file?" + file.isFile());
System.out.println("/Users/pankaj/source.txt is directory?" + file.isDirectory());
        
System.out.println("/Users/pankaj is file?" + dir.isFile());
System.out.println("/Users/pankaj is directory?" + dir.isDirectory());
        
System.out.println("/Users/pankaj/notafile is file?" + notExists.isFile());
System.out.println("/Users/pankaj/notafile is directory?" + notExists.isDirectory());
```
С использованием `path`
```java
Path file = new File(path).toPath();
boolean exists =      Files.exists(file);        // Check if the file exists
boolean isDirectory = Files.isDirectory(file);   // Check if it's a directory
boolean isFile =      Files.isRegularFile(file); // Check if it's a regular file
```

[к оглавлению](#IO)

## 19. Как удалить файл?

класс File содержит следующие методы:
- public boolean delete()
- public void deleteOnExit()
Удалить файл или директорию можно с помощью метода delete(). Каталог можно удалить, только если он пустой!
Также класс File содержит метод deleteOnExit(), который не удаляет файл сразу, а удалит его по завершении работы программы.

класс Files содержит статический метод `public static boolean deleteIfExists(Path path) throws IOException`

**Using `java.io.File.delete()` function:**
```java
File file = new File("/Users/pankaj/file.txt");

if(file.delete()) {
    System.out.println("/Users/pankaj/file.txt File deleted");
} else {
    System.out.println("File /Users/pankaj/file.txt doesn't exist");
}    
```
**Using `java.nio.file.files.deleteIfExists(Path p)`**
```java
Files.deleteIfExists(Paths.get("C:\\Users\\Mayank\\Desktop\\445.txt")); 
```

[к оглавлению](#IO)

## 20. Как переместить файл?

**Перемещение файла.**

На собеседовании могут спросить каким образом можно переместить файл. До JDK 7 не было готовой возможности переместить файл в другую директорию, но есть 2 варианта как это можно сделать вручную:

- Если переместить нужно содержимое файла, то достаточно применить метод File.renameTo(), то есть просто переименовать его, тем самым достигая результата "перемещения" данных в файл с заданным именем. Имейте в виду, что этот метод работает не во всех файловых системах, как было указано ранее.
- Если требуется переместить файл в другую директорию, то нужно скопировать содержимое файла в новый файл в другой директории, после чего старый файл удалить.

Начиная с версии JDK 7 появилась возможность переместить файл с помощью метода move() класса Files. - `public static Path move(Path source, Path target, CopyOption... options) throws IOException`

`Java.io.File` does not contains any ready make move file method, 
but you can workaround with the following two alternatives :

+ `File.renameTo()` (может не сработать на разных файловых системах. Надо проверять результат)
+ Copy to new file and delete the original file.

Для Java 7:

+ `Files.move(Paths.get("/foo.txt")`, `Paths.get("bar.txt")`, `StandardCopyOption.REPLACE_EXISTING);`

[к оглавлению](#IO)

## 21. Как управлять атрибутами файла?

https://job4j.ru/profile/exercise/45/task-view/1021

Файлы имеют атрибуты, например, время создания, время последнего изменения, каталог, владелец, права доступа и т.д. Атрибуты также называют метаданными файла. У разных файловых систем имеются разные атрибуты файлов. Атрибуты файлов в Java представлены в пакете java.nio.file.attribute в виде иерархии интерфейсов с учётом особенностей разных файловых систем.

Во главе этой иерархии находится интерфейс BasicFileAttributeView. Данный интерфейс инкапсулирует атрибуты, применяющиеся во множестве файловых систем. 

У интерфейса BasicFileAttributeView есть 2 наследника:

- Интерфейс DosFileAttributeView - описывает атрибуты, связанные с файловой системой FAT.
- Интерфейс PosixFileAttributeView - описывает атрибуты, определенные по стандартам POSIX (Portable Operating System Interface — переносимый интерфейс операционных систем). POSIX - это набор стандартов, описывающих интерфейсы между ОС и прикладной программой (API), библиотеку языка C и набор приложений и их интерфейсов. Стандарт создан для обеспечения совместимости UNIX-подобных ОС и переносимости прикладных программ на уровне исходного кода. Может быть использован и для других типов ОС.

Эти и другие интерфейсы, которые содержатся в пакете java.nio.file.attribute, имеют очень узкое применение, поэтому в этом уроке мы рассмотрим только шире применяющийся интерфейс BasicFileAttributeView (BasicFileAttribute).

В данном примере создаётся файл в корне проекта, создается представление из атрибутов этого файла и получаются сами атрибуты:
```java
Path file = Path.of("Attributes.txt");
Files.createFile(file);
BasicFileAttributeView attrView = Files.getFileAttributeView(file, BasicFileAttributeView.class); //В следующей строке объект BasicFileAttributeView получается с помощью метода Files.getFileAttributeView()
BasicFileAttributes attributes = attrView.readAttributes(); //BasicFileAttributeView содержит представление атрибутов файла. Сами атрибуты получаются методом readAttributes()
```

Метод readAttributes() возвращает тип BasicFileAttributes. Реализации BasicFileAttributeView и BasicFileAttributes отличаются тем, что BasicFileAttributeView - это представление атрибутов файла, включающее и обязательные, и необязательные методы атрибутов файла, а с помощью метода readAttributes() атрибуты извлекаются из файловой системы в BasicFileAttributes, но в этом типе доступны будут только обязательные (основные) методы. Необязательные методы нужно вызывать через объект BasicFileAttributeView.

Некоторые методы работы с атрибутами файла в целях упрощения работы с ними вынесены в класс Files и объявлены статическими. Например, чтобы получить атрибуты файла, не обязательно получать представление требуемой группы атрибутов, можно использовать более быстрый вариант с помощью вызова статического метода Files.readAttributes():

```java
Path file = ...
BasicFileAttributes attrs = Files.readAttributes(file, BasicFileAttributes.class);
```


```java
public class AttributesUsage {
    public static void main(String[] args) throws IOException {
        Path file = Path.of("Attributes.txt");
        Files.createFile(file);
        BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class);
        System.out.println("Это обычный файл? " + attributes.isRegularFile());
        System.out.println("Это директория? " + attributes.isDirectory());
        System.out.println("Это символическая ссылка? " + attributes.isSymbolicLink());
        System.out.println("Это не файл, директория или символическая ссылка? " + attributes.isOther());
        System.out.println("Дата создания файла: " + attributes.creationTime());
        System.out.println("Размер файла: " + attributes.size());
        System.out.println("Время последнего доступа: " + attributes.lastAccessTime());
        System.out.println("Время последнего изменения: " + attributes.lastModifiedTime());
    }
}
```

Атрибуты файла также можно изменять:

- через метод `setTimes​(FileTime  lastModifiedTime, FileTime  lastAccessTime, FileTime  createTime)` интерфейса BasicFileAttributeView. Через этот метод можно заменить только время изменения файла, время его последнего доступа и время создания. Если нужно установить только 1 или 2 из этих значений, в остальные параметры передаётся null.
- через метод `Files.setAttribute()`. С помощью данного метода можно установить новое значение какого-либо атрибута, передав в метод файл, группу и имя нужного атрибута, и новое значение.

**Базовые атрибуты** (доступны во всех ОС):

+ File type
+ File size
+ Created time
+ Owner of the file
+ Last time modified
+ Last time accessed
+ Hidden
+ System file
+ Regular file
+ isDirectory

**`FileAttributeView`** - базовый интерфейс с подинтерфейсами

+ `BasicFileAttributeView`
+ `DosFileAttributeView`
+ `PosixFileAttributeView`
+ `UserDefinedFileAttributeView`
+ `AclFileAttributeView`
+ `FileOwnerAttributeView`

```java
Path path = FileSystems.getDefault().getPath("c:/test", "somefile.txt");
BasicFileAttributeView basicView = Files.getFileAttributeView(path, BasicFileAttributeView.class);
basicView.readAttributes().lastAccessTime().toMillis();;  // will return the last time the file was read.
basicView.readAttributes().lastModifiedTime().toMillis();  // will return the last time the file was changed.
basicView.readAttributes().creationTime().toMillis();  // will return the creation time.
```

```java
DosFileAttributeView dosView = Files.getFileAttributeView(path,DosFileAttributeView.class);
dosView.setHidden(true);
dosView.setReadOnly(true);
dosView.setSystem(true);
dosView.setArchive(true);
```

[к оглавлению](#IO)

## 22. Как создать файл?

Абсолютный путь - путь, который указывает на одно и то же место в файловой системе, независимо от текущего каталога. Например: C:\projects\job4j_exercises\src\main\java\ru\job4j\io\files\file.txt

Относительный путь - путь, указанный относительно текущего каталога. Например: src\main\java\ru\job4j\io\files\file.txt

Четыре способа:
1. `File file = new File("file.txt");` \\ Теперь объект file хранит путь, который мы в него передали. Физически файл на диске еще не создан.

   `file.createNewFile();` \\ В следующей строке из объекта типа File создается файл на диске по пути, который хранит объект file
     
2. `FileOutputStream fos = new FileOutputStream("data/dataresult.txt");`

   `fos.write("Hello, world!".getBytes());`
  
   `fos.flush();`
  
   `fos.close();`

- Конструктор класса FileOutputStream принимает имя файла. Файл dataresult.txt будет создан в каталоге "data" в корне проекта.
- Для записи используется метод out.write. Этот метод принимает массив байт, поэтому строку преобразовали в массив байтов.
- Любой ресурс должен быть закрыт для это используется конструкция try-with-resources. 
  
3. `String fileData = "Pankaj Kumar";`

   `Files.write(Paths.get("name.txt"), fileData.getBytes());`
  
4. `Path path = Paths.get("name.txt");`

   `Files.createFile(path);`

[к оглавлению](#IO)

## 23. Как создать директорию?

Два способа:
+ `new File("/path/directory").mkdirs();`

Метод mkdir() создает директорию только при наличии всех остальных директорий в переданном пути. Если по пути к целевой директории нужно создавать поддиректории, то нужно использовать метод mkdirs() - он создает целевую директорию и все поддиректории, если они еще не существуют.

+ `Files.createDirectories(Paths.get("/path/to/directory"));`

[к оглавлению](#IO)

## 24. Как записать в файл?

+ **BufferedWritter**
```java
    BufferedWriter writer = new BufferedWriter(new FileWriter("c:/temp/samplefile1.txt"));
    writer.write(fileContent);
    writer.close();
```
        
+ **FileWriter/PrintWriter**
```java
    FileWriter fileWriter = new FileWriter("c:/temp/samplefile2.txt");
    fileWriter.write(fileContent);
    fileWriter.close();
```

+ **FileOutputStream**
```java
    FileOutputStream fos = new FileOutputStream("c:/temp/samplefile4.txt");
    byte[] strToBytes = fileContent.getBytes();
    fos.write(strToBytes);
    
    fos.close();
```

+ **DataOutputStream**
```java
    FileOutputStream fos = new FileOutputStream("c:/temp/samplefile5.txt");
    DataOutputStream dataOutStream = new DataOutputStream(new BufferedOutputStream(fos));
    dataOutStream.writeUTF(fileContent);
     
    dataOutStream.close();
```

+ **FileChannel**
```java
    RandomAccessFile stream = new RandomAccessFile("c:/temp/samplefile6.txt", "rw");
    FileChannel channel = stream.getChannel();
    byte[] strBytes = fileContent.getBytes();
    ByteBuffer buffer = ByteBuffer.allocate(strBytes.length);
    buffer.put(strBytes);
    buffer.flip();
    channel.write(buffer);
    stream.close();
    channel.close();
```
+ **Java 7 Path**
```java
    Path path = Paths.get("c:/temp/samplefile7.txt");     
    Files.write(path, fileContent.getBytes());
```

**Summary**
+ If we try to write to a file that doesn’t exist, the file will be created first and no exception will be thrown (except using Path method).
+ Always close the output stream after writing the file content to release all resources. It will also help in not corrupting the file.
+ Use PrintWriter is used to write formatted text.
+ Use FileOutputStream to write binary data.
+ Use DataOutputStream to write primitive data types.
+ Use FileChannel to write larger files.

[к оглавлению](#IO)

## 25. Как прочитать данные из файла?

+ **FileInputStream**
```java
try (FileInputStream in = new FileInputStream("data/input.txt")) {
            StringBuilder text = new StringBuilder();
            int read;
            while ((read = in.read()) != -1) {
                text.append((char) read);
            }
            System.out.println(text);
        } catch (Exception e) {
            e.printStackTrace();
        }
```
Данные считываются по байтам. Здесь используется конструкция try-with-resources, чтобы закрыть поток ввода.

+ **BufferedReader**
```java
    BufferedReader br = new BufferedReader(new FileReader(file)); 
          
    String st; 
    while ((st = br.readLine()) != null) 
        System.out.println(st); 
    }
```
+**Scanner**
В качестве источника данных Scanner принимает любой вид данных, включая Reader, InputStream, File для java.io и Readable, Path для java.util.nio. Также можно задать источник в виде строки String.
```java
public static void main(String[] args) {
        var data = "empl1@mail.ru, empl2@mail.ru, empl3@mail.ru";
        var scanner = new Scanner(new ByteArrayInputStream(data.getBytes()))
                .useDelimiter(", ");
        while (scanner.hasNext()) {
            System.out.println(scanner.next());
        }
    }
```
    
+ **FileReader**
```java
    FileReader fr = 
        new FileReader("C:\\Users\\pankaj\\Desktop\\test.txt"); 
      
    int i; 
    while ((i=fr.read()) != -1) 
    System.out.print((char) i);      
```
+ **Scanner**
```java
    Scanner sc = new Scanner(file); 
      
    // we just need to use \\Z as delimiter 
    sc.useDelimiter("\\Z"); 
      
    System.out.println(sc.next());
```
+ **Reading the whole file in a List**
```java
    data = new String(Files.readAllBytes(Paths.get(fileName)));
```

[к оглавлению](#IO)

## 26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?

**PrintStream**

Класс PrintStream можно использовать не только для штатного вывода данных в консоль, но и для вывода в другие потоки. Например, в файл.

```java
try (PrintStream stream = new PrintStream(new FileOutputStream("data/print.txt"))) {
            stream.println("Из PrintStream в FileOutputStream");
        } catch (IOException e) {
            e.printStackTrace();
        }
```

>Если мы зайдём в класс System, то увидим, что переменная out - это объект класса PrintStream. В документации к этой переменной написано, что out является стандартным потоком вывода, который всегда открыт и ожидает данных. А метод println() - это метод класса PrintStream, который и выводит в консоль текстовое представление переданного аргумента. Другие вариации этого метода - print() и printf() также являются методами класса PrintStream. Эти три метода выводят данные в выходной поток.

>в конструкторе с реализацией OutputStream есть параметр autoFlush. Этот параметр подразумевает автоматическую очистку буфера путём записи всех данных на целевой носитель. Автоматическая запись данных будет происходить в случае заполнения буфера целиком, вызове println() метода, либо при считывании символа новой строки (\n). Для этого нужно передать в параметр autoFlush аргумент true. В документации приводятся эти ситуации в виде случаев, когда будет произведена автоочистка буфера, но не описаны ситуации, когда этого не произойдёт, поэтому гарантируется только то, что при autoFlush = true все данные будут полностью записаны на целевой носитель, но не гарантируется, что autoFlush будет работать именно так, как описано.

>autoFlush подразумевает метод flush(), который принудительно записывает все имеющиеся в буфере данные на целевой носитель. Данный метод (как и autoFlush) имеет смысл только тогда, когда есть чёткая причина, почему данные из буфера нужно записать в какой-то конкретный момент. Таких ситуаций практически не бывает. Также метод close() принудительно вызывает flush() перед закрытием потока, поэтому когда мы используем поток в конструкции try-с-ресурсами, то явный вызов flush() не требуется.


Помимо методов print*() записать данные в файл в нашем примере можно и с помощью метода write(), так как PrintStream наследует все методы своего абстрактного класса-родителя OutputStream.

```java
try (PrintStream stream = new PrintStream(new FileOutputStream("data/print.txt"))) {
    stream.println("Из PrintStream в FileOutputStream");
    stream.write("Новая строка".getBytes());
```

У методов print*() есть много перегруженных вариантов с разными типами данных в параметре, поэтому в методе println() мы передавали сразу строку. Метод write() принимает в качестве параметра массив байтов, поэтому переданную строку превращаем в байты с помощью метода getBytes().

**PrintWriter**

PrintWriter - это символьный аналог класса PrintStream. Для вывода текста в консоль лучше подходит PrintWriter, так как он работает сразу с символами и использует юникод для преобразования символов, тем самым поддерживается платформонезависимость. Класс PrintStream появился в Java 1.0, а класс PrintWriter только в 1.1. Базовый вывод в консоль в Java осуществляется с помощью PrintStream, что, казалось бы, нецелесообразно, когда уже есть более располагающий к работе с выводом символов класс PrintWriter, но так как в Java существует обратная совместимость, то штатный вывод в консоль так и остался через класс PrintStream. Но если вам нужно работать с текстовыми данными, то лучше использовать для этих целей PrintWriter, а если с байтовыми или смешанными данными, то PrintStream.

Важно! При чтении/записи данных нужно четко понимать вид, в котором представлены данные. Например, если мы захотим считать и записать данные какого-нибудь нетекстового файла типа png с помощью PrintWriter, то выведенные данные будут повреждены, так как png содержит байтовые данные, а PrintWriter будет пытаться интерпретировать из них символы.

**Различие**

Главное их отличие только в том, что PrintStream читает побайтово, а PrintWriter посимвольно, и выбирать тот или иной класс нужно в зависимости от вида данных, с которым требуется работать.

Также есть еще одно отличие у PrintWriter касаемо опции autoFlush. У данного класса autoFlush будет производиться в случае вызовов методов println(), printf() или format().

https://job4j.ru/profile/exercise/45/task-view/1079

[к оглавлению](#IO)

## 27. Что такое потоки байтовых массивов? Как они устроены?

Классы ByteArrayInputStream и ByteArrayOutputStream являются реализациями байтовых потоков (не обёртками) и позволяют читать данные из массива байтов и записывать данные в массив байтов соответственно.

**ByteArrayInputStream**
```java
byte[] bytes = new byte[] {'J', 'a', 'v', 'a'};
        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
        int data;
        while ((data = stream.read()) != -1) {
            System.out.print((char) data);
        }
```

Также считывать данные из массива можно не целиком. Для этого у класса ByteArrayInputStream есть соответсвующий конструктор.Помимо массива байтов, в этот конструктор передаются ещё параметры offset (позиция, с которой начнется считывание) и length (сколько байтов нужно считать).

```java
System.out.println();
String str = "123456789";
byte[] bytes1 = str.getBytes();
ByteArrayInputStream byteStream2 = new ByteArrayInputStream(bytes1, 3, 4);
int data1;
while ((data1 = byteStream2.read()) != -1) {
    System.out.print((char) data1);
}
```

В выводе видим, что из строки 123456789 (массива байтов [1][2][3][4][5][6][7][8][9]) считались 4 байта, начиная с позиции 3

**ByteArrayOutputStream**

Данный класс представляет собой поток вывода, в котором данные записываются в массив байтов. Данный поток содержит protected поле, в которое записывается считанная информация. То есть относительно других классов, которые мы рассматривали или будем рассматривать, метод write() данного потока записывает данные из массива байтов не куда-либо, а в своё внутреннее поле.

Для создания объекта класса ByteArrayOutputStream существует 2 конструктора:

![image](https://github.com/artemaverin/summary/assets/97846877/70510a9e-e668-4684-8e56-505765c75910)

В первом случае внутренний массив байтов будет иметь изначальную ёмкость 32 байта, но при его переполнении данный массив будет автоматически расширяться. Во втором случае можно сразу инициализировать массив своим начальным значением.
```java
System.out.println();
ByteArrayOutputStream outStream = new ByteArrayOutputStream();
byte[] bytes2 = "Message".getBytes();
outStream.writeBytes(bytes2);
System.out.println(outStream);
```

Вместо метода write() мы используем метод writeBytes(). Метод write() может выбросить исключение ввода-вывода (IOException), а так как в данном случае запись массива во внутреннее поле объекта outStream происходит без участия системы ввода-вывода, то в Java 11 в классе ByteArrayOutputStream появился метод writeBytes(), который аналогичен методу write(). Он точно так же записывает указанное содержимое, только при его использовании не нужно оборачивать этот код в блок try-catch (не бросает исключение).

Согласно документации этих классов, явно закрывать эти потоки методом close() необязательно, что и сделано в нашем уроке, то есть мы не помещали наш код в конструкцию try-с-ресурсами, но всегда нужно иметь ввиду, что в будущем реализация программы может измениться, и может возникнуть ошибка необработанного исключения, поэтому всё же рекомендуется закрывать все открытые потоки, то есть помещать их в конструкцию try-с-ресурсами.

Символьными аналогами классов ByteArrayInputStream и ByteArrayOutputStream являются классы CharArrayReader и CharArrayWriter. Они работают аналогично классам, которые мы разбирали в этом уроке, только работают не с байтами, а с символами.

[к оглавлению](#IO)

## 28. Зачем нужен класс RandomAccessFile?

Ранее мы познакомились с классами работы с файлами FileInputStream и FileOutputStream. С помощью этих классов мы можем либо только читать из файла, либо только записывать в файл, так как эти потоки являются последовательными, то есть в этих потоках доступ к данным происходит последовательно от байта к байту (либо от символа к символу в случае FileReader / FileWriter).

Файл, который читается с помощью последовательного потока, называется файлом с `последовательным доступом`. Данные такого файла нельзя обновлять, пока идёт чтение или запись. В Java есть возможность читать и записывать в файл одновременно. Для этого существует класс RandomAccessFile в пакете java.io. Класс RandomAccessFile даёт возможность читать и записывать данные в любом месте файла. Таким образом можно обращаться к данным в произвольном порядке. Файл, читаемый с помощью класса RandomAccessFile называется файлом с `произвольным доступом`. Данные можно читать и записывать из / в любого места файла.

Файл произвольного доступа - это последовательность байтов. Он поддерживает файловый указатель - это указатель местоположения курсора в файле (его позиция). При создании файла произвольного доступа этот указатель всегда находится на нулевой позиции. При чтении / записи одного байта указатель двигается вперёд к следующему байту данных. 

Главная особенность класса RandomAccessFile - это возможность перемещаться по данным и читать только те данные, которые нам нужны, вместо считывания файла целиком, а также записывать данные в указанное место (в начало, конец или произвольно). 

Для этого в классе RandomAccessFile определены следующие методы:

- seek(номер позиции) - перемещает указатель на указанную позицию (выставляет указатель перед указанной позицией, как на картинках выше). Соответственно seek(0) переместит указатель в начало файла, а seek(файл.length()) переместит указатель в конец файла.

- getFilePointer() - возвращает текущую позицию, на которой находится указатель в данный момент. Как было указано выше, файл произвольного доступа - это последовательность байтов, поэтому этот и предыдущий методы устанавливают и возвращают позицию именно в байтах. То есть если у нас, например, в файле записано несколько значений типа int, то чтобы прочитать второе значение, нужно ставить указатель на 4 позицию, так как первые 4 байта (0-3 ячейки) будет занимать первое значение типа int.

Непосредственное чтение / запись производятся с помощью методов типа read*Тип(), readLine(), readUTF() / write*Тип(), writeUTF() и т.д

При создании файла произвольного доступа (объекта RandomAccessFile), помимо локации исходного файла нужно указывать режим:

```java
RandomAccessFile randomAccess = new RandomAccessFile("data/random.txt", "r");
```
Режимы бывают трех типов: "r" - файл будет открыт только для чтения, "rw" - чтение и запись, "rws" - чтение и запись, при этом каждое изменение файла мгновенно отражается в исходном файле (то есть изменения сразу же сохраняются на носителе). Если указанного файла не существует, то в режиме "r" будет выброшено исключение FileNotFoundException, а в режиме "rw" и "rws" будет создан новый файл с указанным названием.

https://job4j.ru/profile/exercise/45/task-view/1080

[к оглавлению](#IO)

## 29. Данные в каком виде можно считывать байтовыми и символьными потоками?

Буферизированный поток - это стандартный поток, к которому добавлен специальный буфер в памяти, который увеличивает производительность чтения и записи. Обращение к ресурсу при чтении/записи - это очень затратный процесс, поэтому чем меньше обращений к ресурсу - тем лучше. Буферизированные потоки - это обёртки обычных потоков с буфером.

Буферное побайтовое чтение/запись реализовано классами BufferedInputStream и BufferedOutputStream.

Буферное посимвольное чтение/запись реализовано классами BufferedReader и BufferedWriter.

+ `java.io.BufferedInputStream(InputStream in)` || `BufferedInputStream(InputStream in, int size)`,
+ `java.io.BufferedOutputStream(OutputStream out)` || `BufferedOutputStream(OutputStream out, int size)`,
+ `java.io.BufferedReader(Reader r)` || `BufferedReader(Reader in, int sz)`,
+ `java.io.BufferedWriter(Writer out)` || `BufferedWriter(Writer out, int sz)`

[к оглавлению](#IO)

## 30. Что такое сокет?

Программа, которая отправляет запросы, называется клиентом. Программа, которая принимает запросы, обрабатывает их и отправляет ответы, называется сервером. 

Сокет представляет собой комбинацию IP - адреса и порта и является одним концом двустороннего канала связи между двумя программами. 

Java для работы в сети имеет специальный пакет java.net. 

java.net.ServerSocket - класс реализует серверный сокет, который ожидает запросы, приходящие от клиентов по сети, и может отправлять ответ. 
java.net.Socket - класс реализует клиентский сокет. 
Соединение между java - сокетами устанавливается с помощью транспортного протокола TCP. То есть используя сокеты мы можем передавать и получать информацию по установленному TCP - соединению.

```java
public class EchoServer {
    public static void main(String[] args) throws IOException {
        try (ServerSocket server = new ServerSocket(9000)) { // Вызов конструктора ServerSocket создает серверный сокет, привязанный к указанному порту. Чтобы клиент мог узнать, где находится сервер ему нужен адрес и порт, 9000 - это порт. По умолчанию адрес будет localhost.
            while (!server.isClosed()) {
                Socket socket = server.accept(); //Вызов метода accept() заставляет программу ждать подключений по указанному порту, работа программы продолжится только после подключения клиента. После успешного подключения метод возвращает объект Socket, который используется для взаимодействия с клиентом.
                try (OutputStream out = socket.getOutputStream();
                     BufferedReader in = new BufferedReader(
                             new InputStreamReader(socket.getInputStream()))) {
                    out.write("HTTP/1.1 200 OK\r\n\r\n".getBytes());
                    for (String str = in.readLine(); str != null && !str.isEmpty(); str = in.readLine()) {
                        System.out.println(str);
                    }  
                    out.flush();
                }
            }
        }
    }
}
```

Создание сервера:

```java
server = new ServerSocket(4004); // серверсокет прослушивает порт 4004
System.out.println("Сервер запущен!"); 
clientSocket = server.accept(); // accept() будет ждать пока
                
try { // установив связь и воссоздав сокет для общения с клиентом можно перейти
                    
    in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
    // и отправлять
    out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));
    String word = in.readLine(); // ждём пока клиент что-нибудь нам напишет
    System.out.println(word);
    // не долго думая отвечает клиенту
    out.write("Привет, это Сервер! Подтверждаю, вы написали : " + word + "\n");
    out.flush(); // выталкиваем все из буфера
    } finally { // в любом случае сокет будет закрыт
        System.out.println("dfjkhgkdf");
        clientSocket.close();
        // потоки тоже хорошо бы закрыть
        in.close();
        out.close();
}
```

Создание клиента:

```java
// адрес - локальный хост, порт - 4004, такой же как у сервера
clientSocket = new Socket("localhost", 4004); // этой строкой мы запрашиваем у сервера доступ на соединение
reader = new BufferedReader(new InputStreamReader(System.in));
in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); // читать соообщения с сервера
out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream())); // писать туда же

System.out.println("Вы что-то хотели сказать? Введите это здесь:");
// если соединение произошло и потоки успешно созданы - мы можем
// работать дальше и предложить клиенту что то ввести
// если нет - вылетит исключение
String word = reader.readLine(); // ждём пока клиент что-нибудь не напишет в консоль
out.write(word + "\n"); // отправляем сообщение на сервер
out.flush();
String serverWord = in.readLine(); // ждём, что скажет сервер
System.out.println(serverWord); // получив - выводим на экран
```

[к оглавлению](#IO)

## 31. Какие виды сокетов есть в Java? С каким протоколом они работают?

Виды сокетов:

java.net.ServerSocket - класс реализует серверный сокет, который ожидает запросы, приходящие от клиентов по сети, и может отправлять ответ. 
java.net.Socket - класс реализует клиентский сокет.

Соединение между java - сокетами устанавливается с помощью транспортного протокола TCP. То есть используя сокеты мы можем передавать и получать информацию по установленному TCP - соединению.

HTTP - это протокол прикладного уровня, работающий “поверх” транспортного протокола TCP, то есть HTTP - сообщения отправляются по установленному TCP - соединению.

Протокол HTTP использует клиент - серверную архитектуру передачи данных, в роли клиента обычно выступают браузеры и различные приложения, отправляющие HTTP - запросы. Каждый запрос отправляется серверу, который обрабатывает его и возвращает ответ.  именно он лежит в основе обмена данными в интернете

[к оглавлению](#IO)

## 32. Как отправить через сокет сообщение?

Если мы введём в поисковой строке “www.job4j.ru” и нажмем enter, браузер сформирует HTTP - запрос для получения HTML - документа этой страницы и направит его на сервер. Тот, в свою очередь,  сформирует HTTP - ответ, содержащий документ, и отправит его клиенту.
```java
public class EchoServer {
    public static void main(String[] args) throws IOException {
        try (ServerSocket server = new ServerSocket(9000)) {
            while (!server.isClosed()) {
                Socket socket = server.accept();
                try (OutputStream out = socket.getOutputStream();
                     BufferedReader in = new BufferedReader(
                             new InputStreamReader(socket.getInputStream()))) {
                    out.write("HTTP/1.1 200 OK\r\n".getBytes());
                    for (String str = in.readLine(); str != null && !str.isEmpty(); str = in.readLine()) {
                         System.out.println(str);
                    }
                    out.flush();
                }
            }
        }
    }
}
```

Браузер отправляет запросы и принимает ответы, используя протокол HTTP. Чтобы браузер понял наш ответ, мы также должны использовать структуру HTTP - сообщения. Сначала запишем стартовую строку с кодом состояния, затем добавим пустую строку (\r\n\r\n), и только после этого записываем наше сообщение.

[к оглавлению](#IO)

## 33. Что такое логирование?

﻿Логирование - это процесс записи в файл полезной информации о работе программы.

Полученный файл называют лог-файлом. Если приложение работает плохо, то первое что проверяют - это лог файл. В логах удобно получать информацию о времени выполнении в классе и строчке кода, где была сделана запись.
```
log4j.rootLogger=DEBUG, console
log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%d{ISO8601} %5p %c:%M:%L - %m%n
```
Что можно логировать:
- Начало/конец работы приложения. Нужно знать, что приложение действительно запустилось, как мы и ожидали, и завершилось так же ожидаемо.
- Вопросы безопасности. Здесь хорошо бы логировать попытки подбора пароля, логирование входа важных юзеров и т.д.
- Некоторые состояния приложения. Например, переход из одного состояния в другое в бизнес процессе.
- Некоторая информация для дебага, с соответственным уровнем логирования.
- Некоторые SQL скрипты. Есть реальные случаи, когда это нужно. Опять-таки, умелым образом регулируя уровни, можно добиться отличных результатов.
- Выполняемые нити(Thread) могут быть логированы в случаях с проверкой корректной работы.

[к оглавлению](#IO)

## 34. Какие уровни логирования вы знаете?

![image](https://github.com/artemaverin/summary/assets/97846877/df2458af-7465-4458-92b3-bb6ca93b6ec1)


Что такое уровни логирования? Для того, чтоб как-то ранжировать логи, нужно было дать определенные обозначения и разграничения. Для этого ввели уровни логирования. 

Уровень задается в приложении. Если запись относится к уровню ниже обозначенного, она не вносится в лог. 

Например, у нас есть логи, с помощью которых дебажат приложение. В нормальной работе на продакшене (когда приложение используют по назначению), такие логи не нужны. Поэтому уровень логирования будет выше, чем для дебага.

рассмотрим уровни на примере log4j. Остальные решения, кроме JUL, используют такие же уровни. Вот они в порядке уменьшения:
- OFF: никакие логи не записываются, все будут проигнорированы;
- FATAL: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;
- ERROR: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. Остальные запросы могут работать корректно;
- WARN: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система устояла и выполнила запрос;
- INFO: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые действия системы;
- DEBUG: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее ожидают, или описания действия системы: “method1 начал работу”;
- TRACE: менее приоритетные логи для отладки, с наименьшим уровнем логирования;
- ALL: уровень, при котором будут записаны все логи из системы.

Получается, что если в приложении в каком-то месте включен уровень логирования INFO, будут логироваться все уровни, начиная с INFO и до FATAL. Если будет уровень логирования FATAL, будут записаны только логи с этим уровнем.

[к оглавлению](#IO)

## 35. Какая библиотека для логирования используется в курсе? Как ее настроить?

В Java есть несколько библиотек для логгирования: Logback, log4j, System.out.println.

Библиотека slf4j позволяет абстрагироваться от конкретных библиотек. Это позволяет придерживаться единого стиля логгирования для проектов.

![image](https://github.com/artemaverin/summary/assets/97846877/5f70cd0a-4579-46e2-af28-0a7efe6a29f7)
```java
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.30</version>
</dependency>
```

```java
package ru.job4j.io;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class UsageLog4j {

    private static final Logger LOG = LoggerFactory.getLogger(UsageLog4j.class.getName());

    public static void main(String[] args) {
        LOG.trace("trace message");
        LOG.debug("debug message");
        LOG.info("info message");
        LOG.warn("warn message");
        LOG.error("error message");
    }
}
```

Log4j - библиотека позволяет осуществить логирование процессов в приложении.

```java
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

```java
package ru.job4j.io;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

public class UsageLog4j {

    private static final Logger LOG = LogManager.getLogger(UsageLog4j.class.getName());

    public static void main(String[] args) {
        LOG.trace("trace message");
        LOG.debug("debug message");
        LOG.info("info message");
        LOG.warn("warn message");
        LOG.error("error message");
    }
}
```

log4j properties

```
log4j.rootLogger=DEBUG, console
log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%d{ISO8601} %5p %c:%M:%L - %m%n
```

1. Запись в консоль, файл или базу данных. Log4j позволяет записывать информацию не только в консоль или файл, но так же в базу данных или отправлять по почте. В нашем примере мы используем вывод информации в консоль.

```java
log4j.appender.console=org.apache.log4j.ConsoleAppender
```
В разделе JDBC мы добавим конфигурацию для вывода информации в файл. На данном этапе используем только вывод в консоль.

2. Формат записи. В логах удобно получать информацию о времени выполнении в классе и строчке кода, где была сделана запись.

```java
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%d{ISO8601} %5p %c:%M:%L - %m%n
```
Разберем вывод.

Дата:

```java
%d{ISO8601}
```
Уровень сообщения:

```java
%5p
```
Класс, метод, строчка:

```java
%c:%M:%L
```
Текст сообщения:

```java
%m%n
```
3. Уровень логирования.

log4j.rootLogger=DEBUG, console
Чем критичнее сообщение, тем выше должен быть уровень сообщения.

ERROR - критические ошибки.

DEBUG - отладочная информация.

[к оглавлению](#IO)

## 36. Опишите из каких элементов состоит формат JSON 

JSON (JavaScript Object Notation) – текстовый формат обмена данными, основан на синтаксисе JavaScript, удобен для написания и чтения человеком. Несмотря на происхождение от JavaScript формат независим от него и может использоваться практически с любым языком программирования, для многих из которых существуют готовые библиотеки для создания и обработки данных в формате JSON.

Примитивные типы данных в JSON:
- число (целое или вещественное)
- литералы true, false и null
- строка —символы юникода, заключённые в двойные кавычки

Ссылочные типы данных:
- Объект - заключается в фигурные скобки ({ и }) и содержит разделенный запятой список пар имя/значение.
- Массив - заключается в квадратные скобки ([ и ]) и содержит разделенный запятой список значений.

**JSON-объект**
JSON-объект — это неупорядоченное множество пар «ключ:значение», заключённых в фигурные скобки {}  и взаимодействие с ним проходит, как со словарем.

Ключ — это название параметра (свойства), который мы передаём серверу. Он служит маркером для принимающей запрос системы, чтобы она поняла, что мы ей отправили.

представление в формате JSON:

{

  "sex" : false, // пара «ключ: значение» с логическим типом

  "age" : 30, // пара «ключ: значение» с числовым типом

 

  " contact" : { // объект

    " phone " : " 11-111" // пара «ключ: значение» со строкой

  },

  "statuses":["Worker","Married"] // массив строк

}

```java
public class Main {
    public static void main(String[] args) {
        final Person person = new Person(false, 30, new Contact("11-111"),
                new String[] {"Worker", "Married"});

        /* Преобразуем объект person в json-строку. */
        final Gson gson = new GsonBuilder().create();
        System.out.println(gson.toJson(person));

        /* Создаём новую json-строку с модифицированными данными*/
        final String personJson =
                "{"
                        + "\"sex\":false,"
                        + "\"age\":35,"
                        + "\"contact\":"
                        + "{"
                        + "\"phone\":\"+7(924)111-111-11-11\""
                        + "},"
                        + "\"statuses\":"
                        + "[\"Student\",\"Free\"]"
                        + "}";
        /* Превращаем json-строку обратно в объект */
        final Person personMod = gson.fromJson(personJson, Person.class);
        System.out.println(personMod);
    }
}
```

[к оглавлению](#IO)

## 37. Как преобразовать POJO в/из json?

POJO (Plain Old Java Object) — «старый добрый Java-объект», простой Java-объект. Термин впервые начал употребляться Мартином Фаулером и его коллегами как результат поиска способов упрощения разработки. Нет формального определения, какие объекты являются POJO, обычно руководствуются следующими соглашениями для класса:

- не наследуется от других классов (возможно, кроме POJO-классов того же пакета)
- не реализует интерфейсов (иногда делается исключение для маркерных интерфейсов из стандартной библиотеки, или тех, которые нужны для бизнес-модели),
- не использует аннотаций в определениях
- не зависит от сторонних библиотек.

POJO классы:
**class Person**
```java
public class Person {

    private boolean sex;

    private int age;

    private Contact contact;

    private String[] statuses;

    public Person() { }

    public Person(boolean sex, int age, Contact contact, String... statuses) {
        this.sex = sex;
        this.age = age;
        this.contact = contact;
        this.statuses = statuses;
    }

    @Override
    public String toString() {
        return "Person{"
                + "sex=" + sex
                + ", age=" + age
                + ", contact=" + contact
                + ", statuses=" + Arrays.toString(statuses)
                + '}';
    }

}

```

**класс Contact**
```java
public class Contact {

    private String phone;

    public Contact() {

    }

    public Contact(String phone) {
        this.phone = phone;
    }

    @Override
    public String toString() {
        return "Contact{"
                + "phone='" + phone + '\''
                + '}';
    }
}
```

Объекты классов Person, Contact являются POJO, но для корректного преобразования в строку с помощью org.json к ним ещё необходимо добавить геттеры.

```java
public static void main(String[] args) {
    /* JSONObject из json-строки строки */
    JSONObject jsonContact = new JSONObject("{\"phone\":\"+7(924)111-111-11-11\"}");

    /* JSONArray из ArrayList */
    List<String> list = new ArrayList<>();
    list.add("Student");
    list.add("Free");
    JSONArray jsonStatuses = new JSONArray(list);

    /* JSONObject напрямую методом put */
    final Person person = new Person(false, 30, new Contact("11-111"), "Worker", "Married");
    JSONObject jsonObject = new JSONObject();
    jsonObject.put("sex", person.getSex());
    jsonObject.put("age", person.getAge());
    jsonObject.put("contact", jsonContact);
    jsonObject.put("statuses", jsonStatuses);

    /* Выведем результат в консоль */
    System.out.println(jsonObject.toString());

    /* Преобразуем объект person в json-строку */
    System.out.println(new JSONObject(person).toString());
}
```

https://javarush.com/groups/posts/3970-kofe-breyk-175-kak-mih-mozhem-prochitatjh-fayl-json-v-java-chto-takoe-java-development-kit-jdk

----------------------------------------------------------------------------------------

Для преобразования POJO (Plain Old Java Object) в JSON и обратно можно использовать библиотеку Gson. Gson позволяет легко преобразовывать Java-объекты в JSON-строки и обратно, используя аннотации и методы.

Пример преобразования POJO в JSON:
```java
import com.google.gson.Gson;

public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // getter and setter methods
}
```
Преобразование POJO в JSON можно выполнить следующим образом:

Импортируйте библиотеку Gson в ваш класс:
```java
import com.google.gson.*;
```
Создайте экземпляр Gson и передайте его в конструктор:
```java
Gson gson = new Gson();
```
Преобразуйте ваш объект POJO в строку JSON с помощью метода toJson() объекта Gson:
```java
Person person = new Person("John", 25);
String json = gson.toJson(person); // "{"name":"John","age":25}"
```
Преобразуйте строку JSON обратно в объект POJO с помощью метода fromJson():
```java
Person newPerson = gson.fromJson(json, Person.class); // new Person("John",25)
```
Таким образом, вы можете легко преобразовать объект POJO в и из JSON, используя библиотеку Gson.

[к оглавлению](#IO)

## 38. Опишите из каких элементов состоит формат XML

XML (eXtensible Markup Language) - это расширяемый язык разметки документов, который используется для структурирования и хранения данных. Формат XML состоит из следующих элементов:

1. Объявление XML. Это первая строка, которая должна идти в файле, под расширением XML. В ней указывается кодировка и версия XML
```java
<?xml version="1.1" encoding="UTF-8" ?>
```
2. Теги - это специальные символы, которые используются для определения структуры документа. Теги могут быть открытыми или закрытыми. Открытые теги имеют закрывающий тег, который должен быть указан после открывающего тега. Закрытые теги не имеют закрывающего тега и начинаются с косой черты “/”.
```java
<device>
    <producer>Lenovo</producer>
    <model>Thinkpad</model>
</device>
```
3. Атрибуты - это дополнительные свойства элемента, которые могут содержать значения. Атрибуты могут быть обязательными или необязательными. Обязательные атрибуты должны быть указаны в теге, а необязательные могут отсутствовать.
```java
<size>
    <width>100</width>
    <height>100</height>
</size>
```
4. Комментарии - это последовательность символов, которая начинается с решетки “#” и заканчивается символом перевода строки. Комментарии не влияют на структуру документа и могут использоваться для пояснения содержимого.
```java
<!-- комментарии -->
```

https://job4j.ru/profile/exercise/174/task-view/328
[к оглавлению](#IO)

## 39. Как преобразовать POJO в/из xml?

Для того чтобы сериализовать и десериализовать нам нужно добавить аннотации JAXB, которая даст библиотеке информацию о том как парсить объект.

1) Как вы уже знаете xml обязательно должен иметь корневой тег, в котором все и будет располагаться. Для его обозначения служит

@XmlRootElement. Эту аннотацию нужно ставить над сущностью, которая будет корневой в нашем случае это Person

2) Над вложенными сущностями нам нужно поставить просто @XmlElement

3) Для того чтобы поле считалось атрибутом нужно поставить  @XmlAttribute, по умолчанию поле парсится как тег

4) Мы можем указать также как мы хотим читать/писать объект. По геттерам/сеттерам или напрямую по полям (используется рефлексия). Мы будем использовать доступ по полям. Для этих целей служит аннотация @XmlAccessorType

**процесс сериализации и десериализации**
```java
package ru.job4j.io.serialization.xml;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import java.io.StringReader;
import java.io.StringWriter;

public class Main {
    public static void main(String[] args) throws Exception {
        Person person = new Person(false, 30, new Contact("11-111"), "Worker", "Married");
        /* Получаем контекст для доступа к АПИ */
        JAXBContext context = JAXBContext.newInstance(Person.class);
        /* Создаем сериализатор */
        Marshaller marshaller = context.createMarshaller();
        /* Указываем, что нам нужно форматирование */
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        String xml = "";
        try (StringWriter writer = new StringWriter()) {
            /* Сериализуем */
            marshaller.marshal(person, writer);
            xml = writer.getBuffer().toString();
            System.out.println(xml);
        }
        /* Для десериализации нам нужно создать десериализатор */
        Unmarshaller unmarshaller = context.createUnmarshaller();
        try (StringReader reader = new StringReader(xml)) {
            /* десериализуем */
            Person result = (Person) unmarshaller.unmarshal(reader);
            System.out.println(result);
        }

    }
}
```

https://job4j.ru/profile/exercise/174/task-view/329

[к оглавлению](#IO)

## 40. Что такое сериализация / десериализация?

Сериализация в Java - это процесс преобразования объектов в последовательность байтов, которая может быть сохранена или передана через сеть или между процессами. Десериализация - это обратный процесс, который восстанавливает объект из этой последовательности байтов.

Сериализация позволяет сохранять объекты в файлах, базах данных или передавать их по сети. Она используется для сохранения состояния объектов во время выполнения программы, например, чтобы восстановить состояние после сбоя или для передачи объекта между разными процессами.

Десериализация используется для восстановления объектов из сохраненных последовательностей байтов. Она может использоваться для загрузки объектов из файлов, баз данных или сети.

Оба процесса могут быть реализованы с помощью стандартных классов Java, таких как Serializable и Externalizable. Эти классы позволяют определить, какие поля объекта должны быть сериализованы и какие методы должны быть вызваны при десериализации.
```
Externalizable и Serializable - это два разных механизма сериализации объектов Java.

Serializable используется для сериализации объекта в поток байтов и его десериализации обратно в объект при чтении из потока.
Serializable позволяет сохранять объект в файл или передавать его по сети.

Externalizable используется для сохранения объекта в файл и его извлечения из файла.
Externalizable не может использоваться для передачи объекта по сети или использовать его в других программах.

Таким образом, Serializable используется для сериализации и десериализации объектов, а Externalizable используется только для сохранения объектов в файл.
```

`Сериализация` – процесс преобразования объектов в бинарный (т.е. последовательность битов) или текстовый формат.

`Десериализация` – процесс преобразования сериализованных данных в объекты, т.е. операция обратная сериализации.

Обычно механизм сериализации/десериализации используется для сохранения состояния программы между запусками, хранения настроек, передачи данных между программами локально или по сети.

В Java существует стандартный механизм сериализации в бинарный формат – `Java serialization`, из текстовых форматов наиболее популярны JSON, XML, YAML, BSON (binary JSON).

`Java serialization`. Для стандартной сериализации объекта необходимо в классе имплементировать интерфейс `Serializable`, этот интерфейс является маркерным, т.е. нет необходимости реализовывать его методы, он сообщает JVM, что объект нашего класса может быть сериализован. Для сериализации объектов в поток используется метод writeObject, для чтения из потока readObject класса ObjectOutputStream.

* Поле serialVersionUID - уникальный идентификатор версии сериализованного класса, необходим для обеспечения механизмов версионности, т.е. нужен JVM для понимания, что сериализованный объект при десериализации имеет те же члены класса, методы и пр. Если значения не совпадают, будет выброшено исключение java.io.InvalidClassException. Для наглядности в примере мы задаем значение поля вручную, в реальной разработке лучше использовать штатный механизм Java генерации serialVersionUID или разработать свой.
* При сериализации объекта сериализуются все объекты, на которые он ссылается в своих полях, поэтому вложенные объекты тоже должны быть Serializable.
* Для исключения полей из сериализации используется ключевое слово transient.
* С помощью интерфейса Externalizable можно реализовать собственный алгоритм сериализации/десериализации, для этого нужно переопределить два обязательных метода — writeExternal() и readExternal().

[к оглавлению](#IO)

## 41. Что такое регулярные выражения? Зачем они нужны?

`Регулярные выражения` (Regular Expressions или RegEx) - это шаблоны, с помощью которых производится поиск по совпадению в тексте. То есть это строка, описывающая последовательность символов, которую желаем найти. С помощью определенного синтаксиса искать можно не только символы напрямую, но и целые диапазоны или комбинации символов. Тем самым можно создавать самые разнообразные шаблоны для поиска с помощью последовательности обычных символов, метасимволов и квантификаторов (о метасимволах и квантификаторах будет рассказано в следующем уроке). 

`Регулярные выражения` - это специальные шаблоны, которые используются для поиска и сопоставления подстрок в тексте. Они позволяют определить условия, которым должна соответствовать строка, и использовать их для фильтрации, извлечения или замены подстрок.

Регулярные выражения могут использоваться для различных задач, таких как:

1. Фильтрация данных: Вы можете использовать регулярные выражения для поиска определенных подстрок или символов в тексте и удаления их. Это может быть полезно, например, при обработке текстовых файлов или веб-страниц.
2. Извлечение данных: Регулярные выражения могут помочь вам извлечь определенную информацию из текста, такую как номера телефонов, адреса электронной почты, даты и т.д.
3. Замена данных: С помощью регулярных выражений вы можете заменять определенные символы или подстроки в тексте на другие значения. Это может быть необходимо, например, для исправления ошибок или форматирования данных.
4. Парсинг XML-документов: Регулярные выражения также могут использоваться для парсинга XML-документов, например, чтобы извлечь значения из тегов или атрибутов.
5. Поиск и замена в коде: Регулярные выражения можно использовать для поиска и замены определенных фрагментов кода, таких как комментарии или отступы.
6. Отладка кода: Регулярные выражения позволяют быстро и легко находить ошибки в коде, такие как неправильные имена переменных или неправильные условия.
7. Проверка корректности ввода: Регулярные выражения могут быть использованы для проверки корректности введенных данных, таких как номера телефонов или адреса электронной почты.
8. Работа с HTML-разметкой: Регулярные выражения часто используются для работы с HTML-документами, такими как парсинг HTML-кода или проверка корректности разметки.

[к оглавлению](#IO)

## 42. Как создать регулярное выражение в Java?

Для создания регулярного выражения в Java можно использовать класс java.util.regex.Pattern и его методы.

Вот пример создания регулярного выражения для поиска всех строк, которые содержат хотя бы один символ из списка “a”, “b” или “c”:
```java
String pattern = "\\b(a|b|c)\\b";
Pattern regex = Pattern.compile(pattern);
// ...
Matcher matcher = regex.matcher("abcd");
if (matcher.find()) {
    System.out.println("Строка содержит хотя бы один из символов 'a', 'b' или 'c'");
} else {
    System.out.println("В строке нет символов из списка 'a', 'b' или 'c'");
}
```
Здесь мы создаем регулярное выражение “\b(a|b|c)\b”, которое соответствует любому из символов “a”, “b” или “c”, заключенному в границы слова. Затем мы используем метод compile() для создания объекта Pattern, который мы можем использовать для поиска совпадений в строках. Метод matcher.find() проверяет, найдено ли совпадение в строке “abcd”, и выводит результат на консоль.
- ---------------------------------------------------------------------------------------------

В Java работа с регулярными выражениями производится с помощью классов Pattern и Matcher из пакета java.util.regex. Эти классы работают в паре. В классе Pattern определяется регулярное выражение (создается шаблон и сопоставитель), а с помощью класса Matcher производится сопоставление шаблона с текстом.

```java
package ru.job4j.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexExample {
    public static void main(String[] args) {
        Pattern pattern = Pattern.compile("Я учусь на Job4j");

        String text1 = "Я учусь на Job4j"; 
        Matcher matcher1 = pattern.matcher(text1); 
        boolean isPresent1 = matcher1.matches(); 
        System.out.println(isPresent1); 

        String text2 = "Я учусь на курсе Job4j"; 
        Matcher matcher2 = pattern.matcher(text2); 
        boolean isPresent2 = matcher2.matches(); 
        System.out.println(isPresent2); 
    }
}
```
Метод compile() класса Pattern создает неизменяемый шаблон из переданной последовательности символов, который мы можем использовать для проверки его на наличие присутствия в тексте. 

Метод matcher() класса Pattern создает сопоставитель нашего шаблона с заданным текстом.

Проверить данное сопоставление на полное соответствие шаблона тексту можно с помощью метода matches() класса Matcher

[к оглавлению](#IO)

## 43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?

Метасимвол - это символ или последовательность символов, имеющие специальное назначение.

Метасимволы делятся на несколько групп:

1) _Позиционные метасимволы._ Определяют позицию искомого символа или последовательности в тексте. Позиция - это место перед или после любого символа в слове. Для наглядности в слове _П_р_и_в_е_т_  все позиции отмечены символом подчеркивания. Ниже в описании метасимволов будет использоваться такое подчеркивание для указания описываемой позиции.
- ^ - начало строки (_текст1 555 текст). Находит заданную последовательность, только если она является началом строки.
- $ - конец строки (текст1 555 текст_). Находит заданную последовательность, только если она является концом строки.
- \b - граница слова (_текст1_ _555_ _тек%ст_). Слово - это непрерывная последовательность любых букв, цифр, символов.
- \B - не граница слова (т_е_к_с_т_1 5_5_5). Все позиции, кроме границ слов.
2) _Метасимволы группировки (символьные классы)._ Определяют диапазоны символов.
- [abc] - символ(ы) или диапазон символов. Каждый проверяемый в тексте символ проверяется на присутствие в заданном диапазоне. Запись может быть в разном виде. Например, [a] - символ a, [at] - символы a и t, [a-k] - символы от a до k, [1-4] - символы от 1 до 4 и т.д. Важно! Каждая из записей в квадратных скобках [] относится к одному символу. То есть при данной записи [abc] каждый символ текста будет оцениваться на предмет является ли он a, b или c. В данном случае текст делится на литералы, состоящие из одного символа. Также найденные вхождения не пересекаются. Например, при поиске вхождения [ab][ab] (2 символа, каждый из которых a или b) в строке "aababa" будет найдено 3 вхождения - "aa", "ba", "ba".
- [a-сx-z] - объединение диапазонов. В данной записи совмещены диапазоны а-с и x-z. Запись может содержать и одиночные символы.
3) _Метасимволы группы литералов._
- . (точка) - любой символ.
- \d - любой цифровой символ.
- \D - любой символ, кроме цифровых.
- \s - символ пробела.
- \S - все символы, кроме пробела.
- \w - символ буквы, цифры или символ подчеркивания.
- \W - любой символ, кроме буквы, цифры и символа подчеркивания.
4) _Метасимволы редактирования текста._
- \n - символ новой строки.
- \r - символ возврата каретки в начало строки.
- \t - символ табуляции.

Метасимволы - это специальные символы, которые используются для обозначения других символов или групп символов в регулярных выражениях. Они позволяют создавать более сложные и гибкие выражения для поиска и замены текста.

Некоторые из наиболее распространенных метасимволов включают:

– . - обозначает любой символ (кроме новой строки)
– * - обозначает любое количество символов (включая ноль)
– + - обозначает один или более символов
– ? - обозначает ноль или один символ
– {m,n} - обозначает m символов, за которыми следует n символов

Метасимволы могут использоваться для создания различных типов выражений, таких как шаблоны регулярного выражения, регулярные выражения, выражения поиска и замены, и т.д. Они также могут быть использованы для определения диапазонов символов, например, для поиска слов, начинающихся с определенного символа.

В целом, метасимволы являются важным инструментом для создания гибких и эффективных выражений для поиска и обработки текста в регулярных выражениях и других языках программирования.

[к оглавлению](#IO)

## 26. Какие существуют виды потоков ввода/вывода?

Разделяют два вида потоков ввода/вывода: байтовые и символьные.

[к оглавлению](#IO)

## 27. Назовите основные предки потоков ввода/вывода?

+ Байтовые: `java.io.InputStream`, `java.io.OutputStream`;

+ Символьные: `java.io.Reader`, `java.io.Writer`;

[к оглавлению](#IO)

## 28. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?

Базовый класс `InputStream` представляет классы, которые получают данные из различных источников:
+ массив байтов;
+ строка (`String`);
+ файл;
+ канал (`pipe`) - данные помещаются с одного конца и извлекаются с другого;
+ последовательность различных потоков, которые можно объединить в одном потоке;
+ другие источники (например, подключение к интернету).

Класс `OutputStream` — это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, 
определяющие, куда направляются ваши данные: 
+ в массив байтов (но не напрямую в `String` - предполагается, что вы сможете 
создать их из массива байтов); 
+ в файл; 
+ или в канал.

Символьные потоки имеют два основных абстрактных класса `Reader` и `Writer`, управляющие потоками символов `Unicode`. 
Класс `Reader` — абстрактный класс, определяющий символьный потоковый ввод. Класс `Writer` — абстрактный класс, 
определяющий символьный потоковый вывод. В случае ошибок все методы класса передают исключение `IOException`.

[к оглавлению](#IO)

## 29. Что вы знаете о RandomAccessFile?

Класс `RandomAccessFile` наследуется напрямую от `Object` и не наследуется от вышеприведенных базовых классов ввода\вывода. 
Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому.

Работа с классом `RandomAccessFile` напоминает использование совмещенных в одном классе потоков `DataInputStream` и 
`DataOutputStream` (они реализуют те же интерфейсы `DataInput` и `DataOutput`). Кроме того, метод `seek()` позволяет 
переместиться к определенной позиции и изменить хранящееся там значение.

При использовании `RandomAccessFile` необходимо знать структуру файла. Класс `RandomAccessFile` содержит методы для 
чтения и записи примитивов и строк UTF-8.

[к оглавлению](#IO)

## 30. Какой класс надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?

Для чтения байтовых данных (не строк) применяется класс `DataInputStream`. В этом случае необходимо использовать 
классы из группы `InputStream`.

Для преобразования строки в массив байтов, пригодный для помещения в поток `ByteArrayInputStream`, в классе `String` 
предусмотрен метод `getBytes()`. Полученный `ByteArrayInputStream` представляет собой поток `InputStream`, подходящий 
для передачи `DataInputStream`.

При побайтовом чтении символов из форматированного потока `DataInputStream` методом `readByte()` любое полученное 
значение будет считаться действительным, поэтому возвращаемое значение неприменимо для идентификации конца потока. 
Вместо этого можно использовать метод `available()`, который сообщает, сколько еще осталось символов.

Класс `DataInputStream` позволяет читать элементарные данные из потока через интерфейс `DataInput`, который определяет 
методы, преобразующие элементарные значения в форму последовательности байтов. Такие потоки облегчают сохранение в 
файле двоичных данных.

Конструктор: `DataInputStream(InputStream stream);`

Методы: `readDouble()`, `readBoolean()`, `readInt()`.

[к оглавлению](#IO)

## 31. Какой класс надстройка позволяет ускорить чтение/запись за счет использования буфера?

Для этого используются классы, позволяющие буферизировать поток:
+ `java.io.BufferedInputStream(InputStream in)` || `BufferedInputStream(InputStream in, int size)`,
+ `java.io.BufferedOutputStream(OutputStream out)` || `BufferedOutputStream(OutputStream out, int size)`,
+ `java.io.BufferedReader(Reader r)` || `BufferedReader(Reader in, int sz)`,
+ `java.io.BufferedWriter(Writer out)` || `BufferedWriter(Writer out, int sz)`

[к оглавлению](#IO)

## 32. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?

`OutputStreamWriter` — мост между классом `OutputStream` и классом `Writer`. 
Символы, записанные в поток, преобразовываются в байты.

```java
OutputStream outputStream = new FileOutputStream("c:\\data\\output.txt");
Writer  outputStreamWriter = new OutputStreamWriter(outputStream, "UTF-8");
outputStreamWriter.write("Hello World");
outputStreamWriter.close();
```

`InputStreamReader` — аналог для чтения. 
При помощи методов класса `Reader` читаются байты из потока `InputStream` и далее преобразуются в символы.

```java
InputStream inputStream  = new FileInputStream("c:\\data\\input.txt");
Reader inputStreamReader = new InputStreamReader(inputStream, "UTF-8");
int data = inputStreamReader.read();
while(data != -1) {
    char theChar = (char) data;
    data = inputStreamReader.read();
}
inputStreamReader.close();
```
 
[к оглавлению](#IO)

## 33. Какой символ является разделителем при указании пути к ЭФС?

Для различных систем символ разделителя различается. Вытащить его можно используя `file.separator`, 
а также в статическом поле `File.separator`.  Для Windows это ‘\’.

[к оглавлению](#IO)

## 34. Что вы знаете об интерфейсе FilenameFilter?

Интерфейс `FilenameFilter` применяется для проверки попадает ли объект `File` под некоторое условие. 
Этот интерфейс содержит единственный метод `boolean accept(File pathName)`. 
Этот метод необходимо переопределить и реализовать.

[к оглавлению](#IO)

## 35. Что такое сериализация?

**Сериализация** - это процесс сохранения состояния объекта в последовательность байт. 

**Десериализация** - это процесс восстановления объекта, из этих байт. 

Java Serialization API предоставляет стандартный механизм для создания сериализуемых объектов.

[к оглавлению](#IO)

## 10. Что такое форматированный вывод Какие механизмы позволяют осуществить форматированный вызов?

+ %a	Шестнадцатеричное число с плавающей точкой
+ %b	Булево значение
+ %c	Символ
+ %d	Десятичное целое
+ %e	Число в научной записи
+ %f	Десятичное число с плавающей точкой
+ %h	Хеш-код от аргумента
+ %o	Восьмеричное целое
+ %n	Символ переноса строки
+ %t	Время
+ %x	Шестнадцатеричное целое

```java
String output = String.format("%s = %d", "joe", 35);
String.format(); Formatter
```

Можно создать `Formatter` и привязать его к `StrungBuilder`:
```java
StringBuilder sbuf = new StringBuilder();
Formatter fmt = new Formatter(sbuf);
fmt.format("PI = %f%n", Math.PI);
System.out.print(sbuf.toString());
```
Также есть свое форматирование для вывода дат.
Можно задавать выравнивание, количество отступов:
```java
String.format("|%-20d|", 93); // prints: |93                  |
String.format("|%020d|", 93); // prints: |00000000000000000093|
```

[к оглавлению](#IO)

## IO

[1. Что такое поток ввода вывода?](#1-Что-такое-поток-ввода-вывода)

[2. Что такое Java IO?](#2-Что-такое-Java-IO)

[3. Что такое Java NIO?](#3-Что-такое-Java-NIO)

[4. Что такое NIO.2?](#4-Что-такое-NIO-2)

[5. Что такое Scanner?](#5-Что-такое-Scanner)

[6. Как работает Scanner внутри?](#6-Как-работает-Scanner-внутри)

[7. Какие базовые методы существуют в Scanner?](#7-Какие-базовые-методы-существуют-в-Scanner)

[8. Что такое байтовый поток? Как он реализован внутри?](#8-Что-такое-байтовый-поток-Как-он-реализован-внутри)

[9. Что такое символьный поток? Как он реализован внутри?](#9-Что-такое-символьный-поток-Как-он-реализован-внутри)

[10. Что такое буферизированный поток?](#10-Что-такое-буферизированный-поток)

[11. Какие классы обёртки позволяют ускорить чтение/запись за счет использования буфера?](#11-Какие-классы-обёртки-позволяют-ускорить-чтение-запись-за-счет-использования-буфера)

[12. Как осуществлятся ввод и вывод из командной строки?](#12-Как-осуществлятся-ввод-и-вывод-из-командной-строки)

[13. Что такое класс Console? Расскажите его АПИ.](#13-Что-такое-класс-Console-Расскажите-его-АПИ)

[14. Что такое поток данных? Data stream.](#14-Что-такое-поток-данных-Data-stream)

[15. Что такое поток объектов, Object stream.](#15-Что-такое-поток-объектов,-Object-stream)

[16. Что такое Path? Как он реализуется на разных ОС?](#16-Что-такое-Path-Как-он-реализуется-на-разных-ОС)

[17. Как получить список файлов?](#17-Как-получить-список-файлов)

[18. Как проверить что файловая сущность является файлом или папкой?](#18-Как-проверить-что-файловая-сущность-является-файлом-или-папкой)

[19. Как удалить файл?](#19-Как-удалить-файл)

[20. Как переместить файл?](#20-Как-переместить-файл)

[21. Как управлять атрибутами файла?](#21-Как-управлять-атрибутами-файла)

[22. Как создать файл?](#22-Как-создать-файл)

[23. Как создать директорию?](#23-Как-создать-директорию)

[23. Как записать в файл?](#23-Как-записать-в-файл)

[24. Как прочитать данные из файла?](#24-Как-прочитать-данные-из-файла)

[25. Работа с сокетами](#25-Работа-с-сокетами)

[26. Какие существуют виды потоков ввода/вывода?](#26-Какие-существуют-виды-потоков-ввода/вывода)

[27. Назовите основные предки потоков ввода/вывода.](#27-Назовите-основные-предки-потоков-ввода/вывода)

[28. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?](#28-Что-общего-и-чем-отличаются-следующие-потоки-InputStream-OutputStream-Reader-Writer)

[29. Что вы знаете о RandomAccessFile?](#29-Что-вы-знаете-о-RandomAccessFile)

[30. Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?](#30-Какой-класс-надстройка-позволяет-читать-данные-из-входного-байтового-потока-в-формате-примитивных-типов-данных)

[31. Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?](#31-Какой-класс-надстройка-позволяет-ускорить-чтение/запись-за-счет-использования-буфера)

[32. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?](#32-Какие-классы-позволяют-преобразовать-байтовые-потоки-в-символьные-и-обратно)

[33. Какой символ является разделителем при указании пути к ЭФС?](#33-Какой-символ-является-разделителем-при-указании-пути-к-ЭФС)

[34. Что вы знаете об интерфейсе FilenameFilter?](#34-Что-вы-знаете-об-интерфейсе-FilenameFilter)

[35. Что такое сериализация?](#35-Что-такое-сериализация)

## 1. Что такое поток ввода вывода??

Поток ввода-вывода - это абстракция для потребления или поставки данных. Потоки ввода-вывода связаны с физическим устройством через базовую систему ввода-вывода в Java. Благодаря абстракции потоков ввода-вывода все потоки ведут себя одинаково независимо от физического устройства (клавиатуры, консоли, файлов, сети). С помощью одних и тех же классов и методов ввода-вывода можно принимать данные с разнотипных устройств и передавать их также в разнотипные устройства, не задумываясь о реализации. Например, принять данные с клавиатуры и сохранить в файл, либо принять данные из сети и вывести на консоль. Потоки ввода-вывода избавляют нас от необходимости разбираться в отличиях ввода с клавиатуры или из файла, вывода на консоль или в файл и т.д. Таким образом, цель создания IO API - абстрактный доступ к вводу-выводу, чтобы не зависеть от подробностей реализации физических устройств.

Поток ввода - это объект, из которого можно считать данные (input) - чтение.

Поток вывода - это объект, в который можно записать данные (output) - запись.

IO API (java.io) предназначен для чтения и записи данных в ресурсы, например, файл, сетевое подключение, консоль, буфер.

Зная об устройстве системы ввода-вывода Java, можно визуализировать процесс считывания и записи таким образом:

![imageTaskPreview (1)](https://github.com/artemaverin/summary/assets/97846877/e0e453af-3e02-4ee6-aef6-73e39de80ff5)

Приложение считывает данные из ресурса с помощью подходящей реализации потока ввода, а потом записывает эти данные в хранилище с помощью подходящего потока вывода.

В Java источник и приемник данных описаны через абстрактные классы: InputSream & OutputStream

**Предопределенные потоки ввода-вывода.**

Все приложения Java автоматически импортируют пакет java.lang. Класс System этого пакета содержит свойства исполняющей среды Java. В том числе он содержит три предопределенных потока ввода-вывода: in, out и err. Эти переменные можно использовать в любой части программы.

System.out - ссылается на стандартный поток вывода (консоль). 

System.in - ссылается на стандартный поток ввода (клавиатура). 

System.err - ссылается на стандартный поток вывода ошибок (консоль). 

Переменные out и err содержат внутри объект типа PrintStream, а переменная in содержит внутри объект типа InputStream. 

В курсе мы всегда выводили в консоль сообщения с помощью вызова переменной System.out, содержащей объект PrintStream, у которого вызывался метод println(). Это предопределенный поток вывода для этой цели.

![imageTaskSource (2)](https://github.com/artemaverin/summary/assets/97846877/a2c26044-54bf-478e-9365-aa2b4fe3baf7)


[к оглавлению](#IO)

## 2. Что такое Java IO?

IO API (java.io) предназначен для чтения и записи данных в ресурсы, например, файл, сетевое подключение, консоль, буфер.

IO API – (Input & Output) в первую очередь это Java API, которые облегчают работу с потоками. 
В `java.io` существуют так называемые потоки ввода и вывода (`InputStream` and `OutputStream`).

В основном `java.io` предназначен для чтения и записи данных в ресурс:

1) файл;
2) при работе с сетевым подключением;
3) `System.err`, `System.in`, `System.out`;
4) при работе с буфером.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/io_diagram.gif)

Для разных типов данных существуют разные реализации классов

|_| Byte Based| _| Character Based| _ |
| ---| ---| ---| ---| --- |
| _| Input| Output| Input| Output |
| Basic| InputStream| OutputStream| Reader / InputStreamReader| Writer / OutputStreamWriter |
| Arrays| ByteArrayInputStream| ByteArrayOutputStream| CharArrayReader| CharArrayWriter |
| Files| FileInputStream / RandomAccessFile| FileOutputStream / RandomAccessFile| FileReader| FileWriter |
| Pipes| PipedInputStream| PipedOutputStream| PipedReader| PipedWriter |
| Buffering| BufferedInputStream| BufferedOutputStream| BufferedReader| BufferedWriter |
| Filtering| FilterInputStream| FilterOutputStream| FilterReader| FilterWriter |
| Parsing| PushbackInputStream / StreamTokenizer| _| PushbackReader / LineNumberReader| _ |
| Strings| _| _| StringReader| StringWriter |
| Data| DataInputStream| DataOutputStream| _| _ |
| Data - Formatted| _| PrintStream| _| PrintWriter |
| Objects| ObjectInputStream| ObjectOutputStream| _| _ |

**Классы Java IO API**

**Базовые**

+ `InputStream` /` OutputStream` - абстрактный класс, определяющий потоковый байтовый ввод/вывод
+ `Reader` / `Writer` - Символьные потоки имеют два основных абстрактных класса `Reader` и `Writer`, 
управляющие потоками символов `Unicode`.
+ `InputStreamReader` / `OutputStreamWriter` Входной/выдодной поток, транслирующий байты в символы

**Массивы**
+ `ByteArrayInputStream` / `ByteArrayOutputStream` - использует байтовый массив в потоке.
+ `CharArrayReader` / `CharArrayWriter` - читает/пишет из символьного массива.

**Files**
+ `FileInputStream` / `FileOutputStream` - Чтение/Отправка данных в файл на диске. Реализация класса `OutputStream`                                       
+ `RandomAccessFile` / `RandomAccessFile` - Чтение/запись файлов с произвольным доступом. метод `seek()` позволяет 
переместиться к определенной позиции и изменить хранящееся там значение. 
При использовании RandomAccessFile необходимо знать структуру файла. Класс `RandomAccessFile` содержит методы для чтения 
и записи примитивов и строк UTF-8.
`RandomAccessFile` может открываться в режиме чтения ("r") или чтения/записи ("rw"). Также есть режим "rws", когда файл 
открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство.
+ `FileReader` / `FileWriter` `FileWriter` записывает данные в файл. При вводе/выводе практически всегда применяется 
буферизация, поэтому используется `BufferedWriter`.                           
Когда данные входного потока исчерпываются, метод `readLine()` возвращает `null`. Для потока явно вызывается метод `close()`; 
если не вызвать его для всех выходных файловых потоков, в буферах могут остаться данные, и файл получится неполным

**Буферизация**
+ `BufferedInputStream` / `BufferedOutputStream` - буферизируемый поток. Буферы вывода нужно для повышения производительности
+ `BufferedReader` / `BufferedWriter`

Если вы имеете меньшее количество соединений, по которым передаются большие объемы данных, то лучшим выбором станет классический дизайн системы ввода/вывода:

![dfjk](https://habrastorage.org/r/w1560/files/1f1/35b/d83/1f135bd8390444fb83552aa4fb899fbf.png)

[к оглавлению](#IO)

## 3. Что такое Java NIO?

| IO| NIO |
| ---| --- |
| Потокоориентированный| Буфер-ориентированный |
| Блокирующий (синхронный) ввод/вывод| Неблокирующий (асинхронный) ввод/вывод |

**Предпосылки создания:**

Недостатки IO:

+ The `File` class lacked some important functionality, such as a copy method.
+ It also defined many methods that returned boolean. As one can imagine, in case of an error, `false` was returned, 
rather than throwing an exception. The developer had, indeed, no way of knowing why it failed.
+ Did not provide good handling on support of symbolic links.
+ A limited set of file attributes was provided.

To overcome these problems, java.nio package was introduced in java 4. The key features were:
+ Channels and Selectors: A channel is an abstraction on lower-level file system features, e.g. memory-mapped files.
+ Buffers: Buffering for all primitive classes (except for Boolean).
+ Charset: Charset (`java.nio.charset`), encoders, and decoders to map bytes and Unicode symbols

With java 7 the `java.nio.file` package is introduced providing a better support for handling symbolic links, 
file attributes access and specially to support extended the file system through classes such 
as **Path, Paths and Files**.

Состоит из 3 основных компонентов:
+ `Channels`
+ `Buffers`
+ `Selectors`

Java NIO: Channels read data into Buffers, and Buffers write data into Channels
There are several Channel and Buffer types. Here is a list of the primary Channel implementations in Java NIO:
+ `FileChannel`
+ `DatagramChannel`
+ `SocketChannel`
+ `ServerSocketChannel`

A Selector allows a single thread to handle multiple Channel's. 
This is handy if your application has many connections (Channels) open, but only has low traffic on each connection. 
For instance, in a chat server.

Example.
```java
RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
    FileChannel inChannel = aFile.getChannel();
    ByteBuffer buf = ByteBuffer.allocate(48);
    int bytesRead = inChannel.read(buf);
    while (bytesRead != -1) {
      System.out.println("Read " + bytesRead);
      buf.flip();
      while(buf.hasRemaining()){
          System.out.print((char) buf.get());
      }
      buf.clear();
      bytesRead = inChannel.read(buf);
    }
    aFile.close();
```

Java NIO позволяет управлять несколькими каналами (сетевыми соединениями или файлами) используя минимальное число потоков выполнения. Однако ценой такого подхода является более сложный, чем при использовании блокирующих потоков, парсинг данных.

Если вам необходимо управлять тысячами открытых соединений одновременно, причем каждое из них передает лишь незначительный объем данных, выбор Java NIO для вашего приложения может дать преимущество. Дизайн такого типа схематически изображен на следующем рисунке:

![smimg](https://habrastorage.org/r/w1560/files/b21/6b7/736/b216b77362834dfe930a26faebe5b457.png)

[к оглавлению](#IO)

## 4. Что такое NIO.2?

с выходом версии Java 1.7 появился еще и Java NIO.2, но присущие ему новшества касаются, в первую очередь, работы с файловым вводом/выводом

Это совершенно новый подход, в отличии от старого java.io.File призванный полностью его заменить во всех аспектах, касающихся взаимодействия с файловой системой.

NIO2 уже по-умолчанию имеет удобные возможности исполнения в многопоточном приложении. Без мучительных конфигураций можно исполнять операции работы с фаловой системой или сетью в фоновом потоке.

Со всех сторон упрощает кодинг и привносит даже новые возможности? которые ранее были не доступны. Например работа напрямую с символическими ссылками.
Вот некоторые из методов, которые сильно упрощают жизнь:

Files.walkFileTree()
Files.isSymbolicLink()
Files.readAttributes()

Новое апи хорошо оптимизировали для работы с конкретной ОС используюся ее те или иные нативные преимущества для скорости работы с ФС сетью, большими файлами.

Улучшения касаются оптимизации работы приложения на нескольких многоядерных процессоров, которые позволяют программе исполняться в "настоящей" мультипоточной манере. Представляет программистам достаточно простую абстракцию для мультипоточной работы с файлами и сокетами.

[к оглавлению](#IO)

## 5. Что такое Scanner?

Исходя из названия класса «Scanner», можно догадаться, что этот класс имеет смысл использовать для «сканирования» источника данных. Под сканированием подразумевается нахождение последовательности символов среди данных источника. Формально говоря, последовательность символов называется токеном или лексемой, а процесс сканирования лексическим анализом.

Токенами могут быть примитивы, строки (в значении с англ. line), символьные выражения, соответствующие регулярному выражению и т.п.. В общем все, что может быть представлено в виде последовательности символов.

Для выделения последовательности символов необходимо знать шаблон, по которому их нужно выделять. В общем случае, это регулярное выражение. Однако, регулярные выражения трудно читаемы, если у Вас мало навыков работы с ними. В этом случае нам на помощь приходит Scanner, который поддерживает большинство шаблонов, например, по поиску примитивов. Тем не менее, шаблон есть всегда. Если мы его не задаем, он как-то задается внутри Scanner.

Важно! В Scanner в качестве шаблона задается разделитель между токенами, а не сам шаблон токенов, как при работе с обычными регулярными выражениями.

Класс java.util.Scanner может быть полезен, когда нужно вычленить из данных только те, что Вам нужны. Для этого нужно назначить разделитель, например, пробел, запятая или регулярное выражение. Также Scanner имеет полезную особенность для чтения чисел различных систем счисления. 

`Scanner` - класс в `java.util` для чтения данных примитивных типов `int`, `double`, `String` и т.д. 
Это самый простой способ для получения входящих данных, но не самый эффективный если есть ограничения по времени.

Обычно создается в виде
```
Scanner sc = new Scanner(System.in);
```
Для чтения данных типа `XYZ` используется метод `nextXYZ()`. Для проверки что есть данные такого типа `hasNextXYZ()`

Например:
+ `hasNextBoolean()`
+ `hasNextByte()`
+ `hasNextDouble()`
+ `hasNextFloat()`

[к оглавлению](#IO)

## 6. Как работает Scanner внутри?

Сам класс работает как Iterator, т.к. поддерживает данный интерфейс.

Причем большинство методов можно разделить на hasTYPE и nextTYPE, где TYPE - это тип по шаблону которого будет происходить отделение токенов друг от друга. Например, hasInt(), nextInt().

В качестве источника данных Scanner принимает любой вид данных, включая Reader, InputStream, File для java.io и Readable, Path для java.util.nio. Также можно задать источник в виде строки String.

![image](https://github.com/artemaverin/summary/assets/97846877/b40d337f-fe7e-4439-9df9-ed69ea06c194)


#1
```java
public class ScannerExample2 {
    public static void main(String[] args) {
        var data = "empl1@mail.ru, empl2@mail.ru, empl3@mail.ru";
        var scanner = new Scanner(new ByteArrayInputStream(data.getBytes()))
                .useDelimiter(", ");
        while (scanner.hasNext()) {
            System.out.println(scanner.next());
        }
    }
}
```

Здесь в качестве источника мы указали одну из реализаций InputStream – ByteArrayInputStream. В качестве разделителя с помощью метода useDelimiter() мы указали нужный разделитель.

В данном случае мы могли воспользоваться методом String.split(), но когда дело доходит до чтения файлов, то Scanner позволяет использовать преимущества буферизированных потоков и возможности по разбиению на токены.

#2

Еще одной интересной возможностью Scanner является возможность задать систему счисления при чтении чисел. Например, можно прочитать числа в шестнадцатеричном виде и вывести в десятичном таким образом:

```java
public class ScannerExample3 {
    public static void main(String[] args) throws Exception {
        var data = "A 1B FF 110";
        var file = File.createTempFile("data", null);
        try (BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file))) {
            out.write(data.getBytes());
        }
        try (var scanner = new Scanner(file).useRadix(16)) {
            while (scanner.hasNextInt()) {
                System.out.print(scanner.nextInt());
                System.out.print(" ");
            }
        }
    }
}
```

Теперь мы указываем в качестве источника данных временный файл, который создаем и в который записываем предварительно. Метод useRadix() указывает в какой системе счисления находятся входные числа.

Важно! Если Scanner работает с внешними источниками его нужно использовать с try-with-resources.

использует регулярные выражения
```java
private static final String LINE_SEPARATOR_PATTERN =
                                           "\r\n|[\n\r\u2028\u2029\u0085]";
private static Pattern NON_ASCII_DIGIT = Pattern.compile(
        "[\\p{javaDigit}&&[^0-9]]");
```                                           
кеширует значения
```java
public String nextLine() {
       modCount++;
        if (hasNextPattern == linePattern())
            return getCachedResult();
        clearCaches();
        String result = findWithinHorizon(linePattern, 0);
        if (result == null)
            throw new NoSuchElementException("No line found");
        MatchResult mr = this.match();
        String lineSep = mr.group(1);
        if (lineSep != null)
            result = result.substring(0, result.length() - lineSep.length());
        if (result == null)
            throw new NoSuchElementException();
        else
            return result;
    }
```  
Java `Scanner` class extends `Object` class and implements `Iterator` and `Closeable` interfaces.

[к оглавлению](#IO)

## 7. Какие базовые методы существуют в Scanner?

+ `delimiter()` It is used to get the Pattern which the Scanner class is currently using to match delimiters.
+ `hasNextLine` 
+ `nextLine`
+ `hasNextInt` 
+ `nextInt` ...

`public boolean hasNext()` - Возвращает true, если у этого сканера есть другой токен на входе.
`public boolean hasNext(String pattern)` - Возвращает true, если следующий токен соответствует шаблону, созданному из указанной строки.
`public boolean hasNext(Pattern pattern)` - Возвращает true, если следующий полный токен соответствует указанному шаблону.

и множество вариаций:

`public boolean hasNextLine()` - возвращает логический тип данных, который соответствует новой строке String, которую содержит объект Scanner.
`public boolean hasNextBoolean()` - проверяет, имеет ли объект логический тип данных в своем буфере.
`public boolean hasNextByte()` - возвращает значение true, если следующий байт в буфере сканера можно преобразовать в тип данных байта, в противном случае – значение false.

и тд

`public String next()` - Находит и возвращает следующий полный токен.
`public String next(String pattern)` - Возвращает следующий токен, если он соответствует шаблону, созданному из указанной строки.
`public String next(Pattern pattern)` - Возвращает следующий токен, если он соответствует указанному шаблону.

также множество вариаций:

`public String nextLine()` - Перемещает сканер за текущую строку и возвращает пропущенный ввод.
`public boolean nextBoolean()` - Сканирует следующий токен ввода как логическое значение и возвращает его.
`public byte nextByte()` - как byte.

`public Scanner useDelimiter(Pattern pattern)` - Устанавливает шаблон ограничения этого сканера в указанный шаблон.
`public Scanner useDelimiter(String pattern)` - как метод выше, но созданный из указанной строки.
`public Scanner useRadix(int radix)` - Устанавливает radix равным указанному.

https://hr-vector.com/java/class-scanner

https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html

[к оглавлению](#IO)

## 8. Что такое байтовый поток Как он реализован внутри?

Byte streams работает с данными побайтово (8 bits). Например, `FileInputStream` используется для чтения 
и `FileOutputStream` для записи. Byte streams интерфейс, который внутри основан на байтовом массиве. 
В основе находится некий буфер который заполняется, вычитывается и заново заполняется. Методы внутри native.
```java
private native int read0() throws IOException;
```

Байтовые потоки предоставляют средства ввода-вывода отдельных байтов, например, чтения и записи двоичных данных. 

В основе байтовых потоков лежат абстрактные классы InputStream и OutputStream (потоки ввода и вывода соответственно). Каждый из этих классов имеет свои классы-реализации, которые учитывают особенности разных устройств (файлов на диске, сетевых соединений, буферов памяти и т.д.). 

Ниже перечислены классы-реализации абстрактных классов InputStream и OutputStream. Многие из них мы будем изучать далее в этом разделе, поэтому вдаваться в их подробности сейчас не нужно.



Основные классы-реализации InputStream (потоки ввода):

    - ByteArrayInputStream - читает байты из массива

    - FileInputStream - читает данные из файла

    - ObjectInputStream - поток ввода объектов

    - PipedInputStream - канал ввода

    - FilterInputStream - реализует класс InputStream. От него реализуются следующие 3 класса:

            - BufferedInputStream - буферизированный поток ввода

            - DataInputStream - читает данные примитивных типов

            - PushbackInputStream - поток ввода, поддерживающий возврат одного байта обратно в поток ввода



Основные классы-реализации OutputStream (потоки вывода):

    - ByteArrayOutputStream - записывает байты в массив

    - FileOutputStream - записывает данные в файл

    - ObjectOutputStream - поток вывода объектов

    - PipedOutputStream - канал вывода

    - PrintStream - поток вывода, содержащий методы print() и println()

    - FilterOutputStream - реализует класс OutputStream. От него реализуются следующие 2 класса:

            - BufferedOutputStream - буферизированный поток вывода

            - DataOutputStream - записывает данные примитивных типов



Важно! Все классы, имеющие в названии InputStream/OutputStream читают/пишут данные побайтово.

[к оглавлению](#IO)

## 9. Что такое символьный поток Как он реализован внутри?

В Java, символы хранятся в кодировке `Unicode` (16 bit). Символный поток позволяет читать данные символ за символом. 
Например `FileReader` и `FileWriter` символьные потоки.
Для них можно задать кодировку:
```java 
Reader reader = new InputStreamReader(in, "UTF-8");
``` 

Символьные потоки предоставляют средства ввода-вывода отдельных символов. В них применяется кодировка Юникод. Читать данные по байтам в большинстве случаев неудобно, поэтому были введены символьные потоки, которые во многих случаях более эффективны, чем байтовые, так как считывают целиком символы, а не байты. Но на низком уровне весь ввод-вывод в java все равно имеет байтовую организацию.

В основе символьных потоков лежат абстрактные классы Reader и Writer (потоки ввода и вывода соответственно). Каждый из этих классов также имеет свои классы-реализации, которые учитывают особенности разных устройств (файлов на диске, сетевых соединений, буферов памяти и т.д.). 

Ниже перечислены классы-реализации абстрактных классов Reader и Writer. Многие из них мы будем изучать далее в этом разделе, поэтому вдаваться в их подробности сейчас не нужно.


Основные классы-реализации Reader (потоки ввода символов):

    - BufferedReader - буферизированный поток ввода символов

    - CharArrayReader - читает символы из массива

    - PipedReader - канал ввода

    - StringReader - читает символы из строки

    - FilterReader - фильтрованный поток чтения. От этого класса наследуется класс PushbackReader:

            - PushbackReader - поток ввода, позволяющий вернуть считанные символы обратно в поток ввода

    - InputStreamReader - преобразует байты в символы. От этого класса наследуется класс FileReader:

            - FileReader - читает символы из файла


Основные классы-реализации Writer (потоки вывода символов):

    - BufferedWriter - буферизированный поток вывода символов

    - CharArrayWriter - записывает символы в массив

    - PipedWriter - канал вывода

    - StringWriter - записывает символы в строку

    - FilterWriter - фильтрованный поток записи. 

    - PrintWriter - поток вывода, содержащий методы print() и println()

    - OutputStreamWriter - преобразует символы в байты. От этого класса наследуется класс FileWriter:

            - FileWriter - записывает символы в файл


Важно! Способ чтения/записи с помощью классов, имеющих в названии Reader/Writer зависит от конкретной реализации. (текст и символы).


Ключевыми методами абстрактных классов InputStream, OutputStream, Reader и Writer являются методы read() - считать данные, и write() - записать данные. В данных классах эти методы абстрактные, они переопределяются во всех их классах-реализациях. 

[к оглавлению](#IO)

## 10. Что такое буферизированный поток?

Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный 
буфер в памяти, с помощью которого повышается производительность при чтении и записи потоков.
`BufferedInputStream` и `BufferedOutputStream`. 
Это может сделать программу намного эффективней, т.к. каждый такой запрос часто инициировал доступ к диску, сетевое 
действие, или некоторую другую работу, которая относительно дорога.

Буферизированный поток - это стандартный поток, к которому добавлен специальный буфер в памяти, который увеличивает производительность чтения и записи. Обращение к ресурсу при чтении/записи - это очень затратный процесс, поэтому чем меньше обращений к ресурсу - тем лучше. `Буферизированные потоки - это обёртки обычных потоков с буфером.`

Классы с InputStream/OutputStream в названии читают и пишут побайтово. То есть, например, метод read() читает всего один байт за раз. Такой способ чтения/записи очень медленный.

Для ускорения процессов существуют буферизированные потоки. Они увеличивают производительность программы за счет считывания некоторого объема данных в буфер. Пример из реального мира: если нам нужно переложить, например, какие-то вещи из одного места в другое, мы воспользуемся пакетом, чтобы унести сразу несколько вещей, а не носить их по одной. Пакет - это и есть буфер.

Зачем нужен буфер? Манипуляции с буфером происходят быстрее, чем манипуляции напрямую с внешним ресурсом (Например, сетью или жестким диском). Буфер выгоден тем, что при записи данных на диск, данные не пишутся непосредственно на ресурс (диск), а сохраняются в буфере потока. В этом случае данные будут записаны на диск либо при закрытии потока, либо при явном вызове метода flush(), который переводит накопленные буфером данные в поток. 

Главный плюс буфера в том, что мы не обращаемся к диску за каждой единицей данных. Если нам нужно считать данные, то в буфер считается больший объем, чем нужно, и при следующем чтении оно будет производится из буфера, не обращаясь к ресурсу. Так же и при записи, например, на диск данные будут записываться сразу большими блоками.

Как уже говорилось выше, каждое обращение к внешнему ресурсу - дорогостоящая операция. Например, метод read() в нашей программе инициирует системный вызов, который обращается к операционной системе для выполнения операции чтения с ресурса. Аналогично и с методом write(). Запросы к ОС сопровождаются дополнительной тратой времени и ресурсов. Буфер помогает уменьшить количество таких обращений, соответственно, ускоряет работу программы. Считав данные в буфер, мы можем работать с его данными внутри программы, не обращаясь для этого к ОС. Новое чтение с диска или запись на диск (физический) происходит только когда все данные из буфера чтения уже прочитаны, либо буфер записи уже переполнен (либо принудительно через метод flush()). 

Буферное побайтовое чтение/запись реализовано классами BufferedInputStream и BufferedOutputStream.

Буферное посимвольное чтение/запись реализовано классами BufferedReader и BufferedWriter.

Все buffered* классы являются обёртками и не могут существовать сами по себе. При создании объектов этих классов в их конструкторы нужно передавать объекты классов-реализаций InputStream/OutputStream. Могут быть и цепочки обёрток, но в корне всегда должен быть байтовый или символьный поток.

объекты классов BufferedInputStream и BufferedOutputStream создаются с помощью следующих конструкторов:

- public BufferedInputStream(InputStream in)
- public BufferedInputStream(InputStream in, int size)

- public BufferedOutputStream(OutputStream out)
- public BufferedOutputStream(OutputStream out, int size)

то есть в конструкторы этих классов мы должны передать какие-либо реализации интерфейсов InputStream и OutputStream. В нашем случае мы буферизируем побайтовое чтение из файла и запись в файл, поэтому в буферизированные обёртки BufferedInputStream и BufferedOutputStream передаём реализации побайтового чтения и записи - FileInputStream и FileOutputStream. Буферизированные обёртки реализуют шаблон декоратор. Подробнее об этом будет в следующих уроках.

Cуществуют не только классы, представляющие из себя сами потоки (например, FileInputStream), но и классы-обёртки для таких классов (например BufferedInputStream для FileInputStream), выполняющие какую-то полезную функцию.

Практически у всех байтовых классов *InputStream / *OuputStream существует свой символьный аналог *Reader / *Writer. Работают они аналогично друг другу. Выбор того или иного класса должен зависеть от того, в каком виде представлены данные, с которыми нужно работать.

В заключение можно сказать, что в уроках по IO в показательных целях могут применяться различные байтовые и символьные потоки для чтения различных типов данных, но нужно запомнить важный момент: если нужно работать только с текстовыми (символьными) данными, то рекомендуется использовать символьные потоки и их обёртки (*Reader / *Writer), а если данные имеют байтовый или смешанный вид, то рекомендуется применять байтовые потоки и их обёртки (*InputStream / *OuputStream). Это важно не только с точки зрения производительности, но и с точки зрения целостности данных. Например, нельзя прочитать файл png символьным потоком, так как *.png файл содержит только байтовые данные, которые невозможно привести к символам.

https://job4j.ru/profile/exercise/45/task-view/1059

[к оглавлению](#IO)

## 11. Какие классы-обёртки позволяют ускорить чтение/запись за счет использования буфера?

Для ускорения процессов существуют буферизированные потоки. Они увеличивают производительность программы за счет считывания некоторого объема данных в буфер. Пример из реального мира: если нам нужно переложить, например, какие-то вещи из одного места в другое, мы воспользуемся пакетом, чтобы унести сразу несколько вещей, а не носить их по одной. Пакет - это и есть буфер.

Главный плюс буфера в том, что мы не обращаемся к диску за каждой единицей данных. Если нам нужно считать данные, то в буфер считается больший объем, чем нужно, и при следующем чтении оно будет производится из буфера, не обращаясь к ресурсу. Так же и при записи, например, на диск данные будут записываться сразу большими блоками.

- `BufferedInputStream(InputStream in)/BufferedInputStream(InputStream in, int size)`
- `BufferedOutputStream(OutputStream out)/BufferedOutputStream(OutputStream out, int size)`
- `BufferedReader(Reader r)/BufferedReader(Reader in, int sz)`
- `BufferedWriter(Writer out)/BufferedWriter(Writer out, int sz)`

[к оглавлению](#IO)


## 12. Как осуществлятся ввод и вывод из командной строки?

По умолчанию ввод с клавиатуры, вывод на монитор.

Все приложения Java автоматически импортируют пакет java.lang. Класс System этого пакета содержит свойства исполняющей среды Java.

Класс `System` содержит также три переменные предопределенных потоков ввода-вывода: `in`, `out` и `err`   
+ Переменная `System.out` ссылается на стандартный поток вывода. По умолчанию это консоль.
+ Переменная `System.in` ссылается на стандартный поток ввода, которым по умолчанию является клавиатура.
+ `System.err` - для ошибок.

[к оглавлению](#IO)

## 13. Что такое класс Console Расскажите его АПИ?

Альтернатива стандратным потокам ввода / вывода класс `Console`.

Класс Console предназначен для работы с консолью - командной строкой Windows или терминалом Linux/MacOS и упрощает работу с ними. Класс Console определён в пакете java.io. 

Для консольного ввода-вывода этот класс использует уже запущенные в системе потоки System.in и System.out. 

Для создание экземпляра используется `System.console()`. Метод может вернуть `null`, если консоль недоступна. 
Консоль позволяет вводить пароль используя метод `readPassword` (не видны символы при вводе, не сохраняется в памяти). 
   
полезные методы класса Console:

- readLine() - читает с консоли строку, которую ввёл пользователь. Сохраняет данные в String.
- readPassword() - читает с консоли строку, которую ввёл пользователь. Отличие от метода readLine() в том, что вводимые пользователем символы не будут отображаться на консоли в целях безопасности. Сохраняет данные в char[] - массив байтов.
- format() и printf() - эти методы мы уже знаем. format() сохраняет отформатированную строку, а printf() выводит отформатированную строку на печать без сохранения.
- flush() - принудительно выводит в консоль все данные, находящиеся в буфере в данный момент.

[к оглавлению](#IO)

## 14. Что такое поток данных Data stream?

Класс DataOutputStream позволяет записывать примитивные типы данных, а также строковые значения в байтовом представлении, а класс DataInputStream позволяет считывать примитивы из их байтового представления. 

Классы DataInputStream и DataOutputStream реализуют интерфейсы DataInput и DataOutput соответственно. Эти интерфейсы содержат методы, с помощью которых можно читать и записывать примитивы и строки в поток. Например, writeBoolean(), writeDouble(), readBoolean(), readDouble() и т.д. Эти методы преобразуют значения примитивных типов в последовательность байтов и наоборот. Таким образом упрощается хранение данных в двоичной форме в файлах.

DataInputStream и DataOutputStream являются обёртками и не могут существовать сами по себе. При создании объектов этих классов в их конструкторы нужно передавать объекты классов-реализаций InputStream/OutputStream. Могут быть и цепочки обёрток, но в корне всегда должен быть сам байтовый поток.

```java
try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path));
             DataInputStream in = new DataInputStream(new FileInputStream(path))) {
```

Здесь важно понимать, что в файл мы пишем данные в двоичном формате, поэтому считывать записанные данные нужно в том же порядке и в те же типы данных, так как код в файле - это просто набор байтов. В файле нет никакой информации о типе данных или месте начала/конца каких-либо значений. Не зная порядок, в котором мы задавали данные в этот файл, прочитать эту информацию будет невозможно. 

Например, при записи значения типа int в файл будет помещено 4 байта информации, при записи значения типа double - 8 байт и т.д. Если мы записали в файл сначала int (4 байта), потом double (8 байт), то при попытке считать сначала double, а потом int, мы получим некорректные значения, так как чтение из файла будет происходить тоже побайтово, то есть каждый метод read*** будет считывать столько байт, какой тип у него идёт в названии вместо звёздочек (readInt - 4 байта и т.д.). В результате сначала вместо 4 байт мы считаем 8, а потом вместо 8 байт - 4, поэтому считывание нужно производить в те же переменные и в той же последовательности, в которой они были записаны в файл.

Во всех методах интерфейса DataInput информация о достижении конца файла возвращается не в виде значения -1, как это было в методе read() предыдущих классов, а с помощью выброса исключения EOFException - End of file exception. 

https://job4j.ru/profile/exercise/45/task-view/1069

[к оглавлению](#IO)

## 15. Что такое поток объектов, Object stream?

Потоки объектов представлены в пакете java.io классами ObjectInputStream и ObjectOutputStream. ObjectOutputStream превращает объект в его байтовое представление. ObjectInputStream восстанавливает объект из байтового представления в обычное. Эти процессы называются сериализацией и десериализацией соответственно. С помощью этих операций можно сохранить объект (состояние объекта) в виде последовательности байт, удобной для передачи по сети, и восстановить эту последовательность байт обратно в объект, например, на другом компьютере.

Классы ObjectInputStream и ObjectOutputStream наследуют классы InputStream / OutputStream и реализуют интерфейсы ObjectInput / ObjectOutput, которые, в свою очередь, наследуют интерфейсы DataInput / DataOutput, с которыми мы уже знакомы из урока по потокам данных. Интерфейсы ObjectInput и ObjectOutput наследуют все методы интерфейсов DataInput и DataOutput, а также определяют методы readObject() и writeObject() соответственно, с помощью которых производится непосредственное преобразование объекта в байтовое представление и обратно. А так как унаследованы все методы интерфейсов DataInput / DataOutput, то потоки объектов могут содержать и примитивные, и объектные значения.

`ObjectOutputStream` используется для конвертации объектов в поток. В java это называется сериализация. 
Объект преобразоыванный таким образом может быть сохранен в базу данных, передан по сети и т.п. 
Для записи в файл можно использовать `FileOutputStream`.
Объект который передается в потоке должен реализовывать интерфейс `java.io.Serializable`.
```java
FileOutputStream fos = new FileOutputStream("EmployeeObject.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);
// write object to file
oos.writeObject(emp);
```

При сериализации используют переменную `SerialVersionUID`. 
Во время сериализации, среда выполнения Java создает номер версии для класса, так что она может десереализировать 
его позже. В Java этот номер версии известен как `SerialVersionUID`. Если во время десериализации, `SerialVersionUID` 
не соответствует, то процесс завершится с исключением

`SerialVersionUID` используется для указании версии сериализованных данных.
+ Когда мы не объявляем `SerialVersionUID` в нашем классе, среда выполнения Java делает это за нас, но этот процесс 
чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, 
которые реализованы в классе и пр. Вы можете найти точную информацию в документации о сериализации от Oracle.
+ Рекомендуется объявлять `SerialVersionUID` как `private static final long` переменную во избежание механизма по умолчанию.

https://job4j.ru/profile/exercise/45/task-view/1072

[к оглавлению](#IO)

## 16. Что такое Path Как он реализуется на разных ОС?

Java 7 представляет новую абстракцию для пути, а именно интерфейс `Path`. Он используется в новых функциях и API, 
по всему NIO.2. Объект пути содержит имена каталогов и файлов, которые составляют полный путь до файла/каталога, 
представленного объектом `Path`. 

`Path` содержит методы для извлечения элементов пути, манипуляций с ними и их добавления.

Путь к файлу, в разных системх может записываться по разному, `\` или `/`, поэтому лучше
использовать `File.separator` для построения пути
```java
// Cоздание объекта Path через вызов статического метода get() класса Paths 
Path testFilePath = Paths.get("/home/heorhi/testfile.txt"); 
         
//Пример строки создания объекта Path пути для запуска в Windows 
Path testFilePath = Paths.get("D:\\test\\testfile.txt");
```
- -----------------------------------------------------------------------

Path - это интерфейс. Так как у разных файловых систем есть свои особенности, интерфейс дает возможность реализовать собственную версию - наследника интерфейса Path в разных операционных системах. Path имеет несколько реализаций под некоторые операционные системы. При создании объекта Path, под капотом создается специальный объект, представляющий реализацию операционной системы, в которой он создается. Так как в разных ОС пути могут быть записаны по-разному, то объект, созданный в одной ОС, может не работать в другой ОС. 

В документации интерфейса Path указан следующий вариант корректного использования Path в условиях кроссплатформенности:

```java
Path path = FileSystems.getDefault().getPath("logs", "access.log");
BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);
```

В следующей строке 

```java
Path path = FileSystems.getDefault().getPath("logs", "access.log");
```

в параметры метода getPath() передаются части пути отдельными строками. При создании пути, из этих частей программой будет определен разделитель с помощью метода FileSystem.getSeparator(), и с помощью этого разделителя будет собрана строка. В данном случае будет определен разделитель той ОС, в которой выполняется программа.

Например, в ОС Windows путь из примера будет собран с помощью разделителя "\" таким образом: logs\access.log

Создать объект Path можно двумя способами.

1.
```java
Path dir = Paths.get("path/paths");
        Files.createDirectories(dir);
```

Здесь создается новая директория. Путь к файлу инкапсулируется в объект интерфейса Path с помощью метода Paths.get(). Класс Paths был введен в JDK 7 с обновлением NIO API. Этот класс содержит единственный метод get(), который помещает путь внутрь объекта Paths. Далее создаются директории на диске в корне проекта с помощью метода createDirectories() класса Files (метод создаёт директории, даже если их не существовало). Класс Files также появился с обновлением NIO API в JDK 7, в этот класс были вынесены статические методы из класса File для работы с объектом Path. 



2.
```java
Path path = Path.of("path/paths/path.txt");
        Files.createFile(path);
```

Здесь создаётся новый файл. Второй способ заключается в том, что путь к файлу инкапсулируется с помощью метода of() класса Path. Рекомендуется использовать этот способ, так как метод Paths.get() под капотом вызывает метод Path.of(). Метод Path.of() был создан с целью визуального восприятия, что это фабричный метод, как и другие of() методы в Java, так как метод get() не совсем соответствовал его смыслу. Далее создается файл на диске в директории paths с помощью метода createFile().

Если повторно попытаться создать уже существующий файл или директорию, то будет выброшено исключение FileAlreadyExistsException, говорящее о том, что данный файл (в конкретном примере директория), уже существует. Теперь мы можем знать о проблеме и можем ее обрабатывать, в отличие от поведения класса File, когда бы мы получили просто false.

https://job4j.ru/profile/exercise/45/task-view/1016
[к оглавлению](#IO)

## 17. Как получить список файлов?
**Ответ № 1**
+ Без учета подпапок
```java
File file = new File("dir");
File[] filesArr = file.listFiles();
String[] filesNames = file.list();
```
+ С учетом подпапок
```java
public void listFilesForFolder(final File folder) {
    for (final File fileEntry : folder.listFiles()) {
        if (fileEntry.isDirectory()) {
            listFilesForFolder(fileEntry);
        } else {
            System.out.println(fileEntry.getName());
        }
    }
}
final File folder = new File("/home/you/Desktop");
listFilesForFolder(folder);
```
 
**Java 8**
+ Java NIO без учета подпапок
```java
Stream<Path> stramFiles = Files.list(Paths.get("dir"));
```
+ С учетом подпапок. Files.walk API is available from Java 8.
```java
try (Stream<Path> paths = Files.walk(Paths.get("/home/you/Desktop"))) {
    paths
        .filter(Files::isRegularFile)
        .forEach(System.out::println);
}
```
+ Через `walkFileTree` 
(The difference between `walk` and `walkFileTree` is that they supply different interfaces for walking the tree: 
`walkFileTree` takes `FileVisitor`, walk gives `Stream<Path>`)
```java
Files.walkFileTree(directory, Collections.emptySet(), 1, new SimpleFileVisitor<Path>() {
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        doSomething(file);
        return FileVisitResult.CONTINUE;
    }
    
    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) {
        // log exc
        return FileVisitResult.CONTINUE;
    }
});
```

**Ответ № 2**

1. С помощью методов `new File().list()` и `new File().listFiles()` вызываемых у объекта класса **File**
```java
File target = new File("src/main/java/ru/job4j/io/files");
String[] list = target.list(); 
        for (String f : list) {
            System.out.println(f);
        }
        File[] listFiles = target.listFiles(); 
        for (File f : listFiles) {
            System.out.println(f);
        }
```

метод list() возвращает массив строк с именами файлов и директорий, содержащихся в директории files
метод listFiles() возвращает массив объектов типа File с инкапсулированными путями расположения этих объектов в файловой системе, содержащихся в директории files

2. С помощью встроенного механизма FileVisitor  метода класса Files - public static Path walkFileTree(Path start, FileVisitor<? super Path> visitor) throws IOException

```java
public class PrintFiles implements FileVisitor<Path> {


    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
        return CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        System.out.println(file.toAbsolutePath());
        return CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
        return CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        return CONTINUE;
    }
}
```
Интерфейс FileVisitor имеет 4 метода. Нас будет интересовать только visitFile. Java последовательно передает в него файлы, а программист их обрабатывает.

```java
public class Search {
    public static void main(String[] args) throws IOException {
        Path start = Paths.get(".");
        Files.walkFileTree(start, new PrintFiles());
    }
}
```
2.1. Существует еще варинт  с SimpleFileVisitor
_SimpleFileVisitor_ уже реализует FileVisitor, переопределяя все методы только с указанием на дальнейший обход CONTINUE.

Это означает, что унаследовавшись от него мы можем переопределить только нужный нам метод.

https://habr.com/ru/articles/437694/
 
[к оглавлению](#IO)
 
## 18. Как проверить что файловая сущность является файлом или папкой?

```java
File file = new File("/Users/pankaj/source.txt");
File dir = new File("/Users/pankaj");
File notExists = new File("/Users/pankaj/notafile");
        
System.out.println("/Users/pankaj/source.txt is file?" + file.isFile());
System.out.println("/Users/pankaj/source.txt is directory?" + file.isDirectory());
        
System.out.println("/Users/pankaj is file?" + dir.isFile());
System.out.println("/Users/pankaj is directory?" + dir.isDirectory());
        
System.out.println("/Users/pankaj/notafile is file?" + notExists.isFile());
System.out.println("/Users/pankaj/notafile is directory?" + notExists.isDirectory());
```
С использованием `path`
```java
Path file = new File(path).toPath();
boolean exists =      Files.exists(file);        // Check if the file exists
boolean isDirectory = Files.isDirectory(file);   // Check if it's a directory
boolean isFile =      Files.isRegularFile(file); // Check if it's a regular file
```

[к оглавлению](#IO)

## 19. Как удалить файл?

класс File содержит следующие методы:
- public boolean delete()
- public void deleteOnExit()
Удалить файл или директорию можно с помощью метода delete(). Каталог можно удалить, только если он пустой!
Также класс File содержит метод deleteOnExit(), который не удаляет файл сразу, а удалит его по завершении работы программы.

класс Files содержит статический метод `public static boolean deleteIfExists(Path path) throws IOException`

**Using `java.io.File.delete()` function:**
```java
File file = new File("/Users/pankaj/file.txt");

if(file.delete()) {
    System.out.println("/Users/pankaj/file.txt File deleted");
} else {
    System.out.println("File /Users/pankaj/file.txt doesn't exist");
}    
```
**Using `java.nio.file.files.deleteIfExists(Path p)`**
```java
Files.deleteIfExists(Paths.get("C:\\Users\\Mayank\\Desktop\\445.txt")); 
```

[к оглавлению](#IO)

## 20. Как переместить файл?

**Перемещение файла.**

На собеседовании могут спросить каким образом можно переместить файл. До JDK 7 не было готовой возможности переместить файл в другую директорию, но есть 2 варианта как это можно сделать вручную:

- Если переместить нужно содержимое файла, то достаточно применить метод File.renameTo(), то есть просто переименовать его, тем самым достигая результата "перемещения" данных в файл с заданным именем. Имейте в виду, что этот метод работает не во всех файловых системах, как было указано ранее.
- Если требуется переместить файл в другую директорию, то нужно скопировать содержимое файла в новый файл в другой директории, после чего старый файл удалить.

Начиная с версии JDK 7 появилась возможность переместить файл с помощью метода move() класса Files. - `public static Path move(Path source, Path target, CopyOption... options) throws IOException`

`Java.io.File` does not contains any ready make move file method, 
but you can workaround with the following two alternatives :

+ `File.renameTo()` (может не сработать на разных файловых системах. Надо проверять результат)
+ Copy to new file and delete the original file.

Для Java 7:

+ `Files.move(Paths.get("/foo.txt")`, `Paths.get("bar.txt")`, `StandardCopyOption.REPLACE_EXISTING);`

[к оглавлению](#IO)

## 21. Как управлять атрибутами файла?

https://job4j.ru/profile/exercise/45/task-view/1021

Файлы имеют атрибуты, например, время создания, время последнего изменения, каталог, владелец, права доступа и т.д. Атрибуты также называют метаданными файла. У разных файловых систем имеются разные атрибуты файлов. Атрибуты файлов в Java представлены в пакете java.nio.file.attribute в виде иерархии интерфейсов с учётом особенностей разных файловых систем.

Во главе этой иерархии находится интерфейс BasicFileAttributeView. Данный интерфейс инкапсулирует атрибуты, применяющиеся во множестве файловых систем. 

У интерфейса BasicFileAttributeView есть 2 наследника:

- Интерфейс DosFileAttributeView - описывает атрибуты, связанные с файловой системой FAT.
- Интерфейс PosixFileAttributeView - описывает атрибуты, определенные по стандартам POSIX (Portable Operating System Interface — переносимый интерфейс операционных систем). POSIX - это набор стандартов, описывающих интерфейсы между ОС и прикладной программой (API), библиотеку языка C и набор приложений и их интерфейсов. Стандарт создан для обеспечения совместимости UNIX-подобных ОС и переносимости прикладных программ на уровне исходного кода. Может быть использован и для других типов ОС.

Эти и другие интерфейсы, которые содержатся в пакете java.nio.file.attribute, имеют очень узкое применение, поэтому в этом уроке мы рассмотрим только шире применяющийся интерфейс BasicFileAttributeView (BasicFileAttribute).

В данном примере создаётся файл в корне проекта, создается представление из атрибутов этого файла и получаются сами атрибуты:
```java
Path file = Path.of("Attributes.txt");
Files.createFile(file);
BasicFileAttributeView attrView = Files.getFileAttributeView(file, BasicFileAttributeView.class); //В следующей строке объект BasicFileAttributeView получается с помощью метода Files.getFileAttributeView()
BasicFileAttributes attributes = attrView.readAttributes(); //BasicFileAttributeView содержит представление атрибутов файла. Сами атрибуты получаются методом readAttributes()
```

Метод readAttributes() возвращает тип BasicFileAttributes. Реализации BasicFileAttributeView и BasicFileAttributes отличаются тем, что BasicFileAttributeView - это представление атрибутов файла, включающее и обязательные, и необязательные методы атрибутов файла, а с помощью метода readAttributes() атрибуты извлекаются из файловой системы в BasicFileAttributes, но в этом типе доступны будут только обязательные (основные) методы. Необязательные методы нужно вызывать через объект BasicFileAttributeView.

Некоторые методы работы с атрибутами файла в целях упрощения работы с ними вынесены в класс Files и объявлены статическими. Например, чтобы получить атрибуты файла, не обязательно получать представление требуемой группы атрибутов, можно использовать более быстрый вариант с помощью вызова статического метода Files.readAttributes():

```java
Path file = ...
BasicFileAttributes attrs = Files.readAttributes(file, BasicFileAttributes.class);
```


```java
public class AttributesUsage {
    public static void main(String[] args) throws IOException {
        Path file = Path.of("Attributes.txt");
        Files.createFile(file);
        BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class);
        System.out.println("Это обычный файл? " + attributes.isRegularFile());
        System.out.println("Это директория? " + attributes.isDirectory());
        System.out.println("Это символическая ссылка? " + attributes.isSymbolicLink());
        System.out.println("Это не файл, директория или символическая ссылка? " + attributes.isOther());
        System.out.println("Дата создания файла: " + attributes.creationTime());
        System.out.println("Размер файла: " + attributes.size());
        System.out.println("Время последнего доступа: " + attributes.lastAccessTime());
        System.out.println("Время последнего изменения: " + attributes.lastModifiedTime());
    }
}
```

Атрибуты файла также можно изменять:

- через метод `setTimes​(FileTime  lastModifiedTime, FileTime  lastAccessTime, FileTime  createTime)` интерфейса BasicFileAttributeView. Через этот метод можно заменить только время изменения файла, время его последнего доступа и время создания. Если нужно установить только 1 или 2 из этих значений, в остальные параметры передаётся null.
- через метод `Files.setAttribute()`. С помощью данного метода можно установить новое значение какого-либо атрибута, передав в метод файл, группу и имя нужного атрибута, и новое значение.

**Базовые атрибуты** (доступны во всех ОС):

+ File type
+ File size
+ Created time
+ Owner of the file
+ Last time modified
+ Last time accessed
+ Hidden
+ System file
+ Regular file
+ isDirectory

**`FileAttributeView`** - базовый интерфейс с подинтерфейсами

+ `BasicFileAttributeView`
+ `DosFileAttributeView`
+ `PosixFileAttributeView`
+ `UserDefinedFileAttributeView`
+ `AclFileAttributeView`
+ `FileOwnerAttributeView`

```java
Path path = FileSystems.getDefault().getPath("c:/test", "somefile.txt");
BasicFileAttributeView basicView = Files.getFileAttributeView(path, BasicFileAttributeView.class);
basicView.readAttributes().lastAccessTime().toMillis();;  // will return the last time the file was read.
basicView.readAttributes().lastModifiedTime().toMillis();  // will return the last time the file was changed.
basicView.readAttributes().creationTime().toMillis();  // will return the creation time.
```

```java
DosFileAttributeView dosView = Files.getFileAttributeView(path,DosFileAttributeView.class);
dosView.setHidden(true);
dosView.setReadOnly(true);
dosView.setSystem(true);
dosView.setArchive(true);
```

[к оглавлению](#IO)

## 22. Как создать файл?

Абсолютный путь - путь, который указывает на одно и то же место в файловой системе, независимо от текущего каталога. Например: C:\projects\job4j_exercises\src\main\java\ru\job4j\io\files\file.txt

Относительный путь - путь, указанный относительно текущего каталога. Например: src\main\java\ru\job4j\io\files\file.txt

Четыре способа:
1. `File file = new File("file.txt");` \\ Теперь объект file хранит путь, который мы в него передали. Физически файл на диске еще не создан.

   `file.createNewFile();` \\ В следующей строке из объекта типа File создается файл на диске по пути, который хранит объект file
     
2. `FileOutputStream fos = new FileOutputStream("data/dataresult.txt");`

   `fos.write("Hello, world!".getBytes());`
  
   `fos.flush();`
  
   `fos.close();`

- Конструктор класса FileOutputStream принимает имя файла. Файл dataresult.txt будет создан в каталоге "data" в корне проекта.
- Для записи используется метод out.write. Этот метод принимает массив байт, поэтому строку преобразовали в массив байтов.
- Любой ресурс должен быть закрыт для это используется конструкция try-with-resources. 
  
3. `String fileData = "Pankaj Kumar";`

   `Files.write(Paths.get("name.txt"), fileData.getBytes());`
  
4. `Path path = Paths.get("name.txt");`

   `Files.createFile(path);`

[к оглавлению](#IO)

## 23. Как создать директорию?

Два способа:
+ `new File("/path/directory").mkdirs();`

Метод mkdir() создает директорию только при наличии всех остальных директорий в переданном пути. Если по пути к целевой директории нужно создавать поддиректории, то нужно использовать метод mkdirs() - он создает целевую директорию и все поддиректории, если они еще не существуют.

+ `Files.createDirectories(Paths.get("/path/to/directory"));`

[к оглавлению](#IO)

## 24. Как записать в файл?

+ **BufferedWritter**
```java
    BufferedWriter writer = new BufferedWriter(new FileWriter("c:/temp/samplefile1.txt"));
    writer.write(fileContent);
    writer.close();
```
        
+ **FileWriter/PrintWriter**
```java
    FileWriter fileWriter = new FileWriter("c:/temp/samplefile2.txt");
    fileWriter.write(fileContent);
    fileWriter.close();
```

+ **FileOutputStream**
```java
    FileOutputStream fos = new FileOutputStream("c:/temp/samplefile4.txt");
    byte[] strToBytes = fileContent.getBytes();
    fos.write(strToBytes);
    
    fos.close();
```

+ **DataOutputStream**
```java
    FileOutputStream fos = new FileOutputStream("c:/temp/samplefile5.txt");
    DataOutputStream dataOutStream = new DataOutputStream(new BufferedOutputStream(fos));
    dataOutStream.writeUTF(fileContent);
     
    dataOutStream.close();
```

+ **FileChannel**
```java
    RandomAccessFile stream = new RandomAccessFile("c:/temp/samplefile6.txt", "rw");
    FileChannel channel = stream.getChannel();
    byte[] strBytes = fileContent.getBytes();
    ByteBuffer buffer = ByteBuffer.allocate(strBytes.length);
    buffer.put(strBytes);
    buffer.flip();
    channel.write(buffer);
    stream.close();
    channel.close();
```
+ **Java 7 Path**
```java
    Path path = Paths.get("c:/temp/samplefile7.txt");     
    Files.write(path, fileContent.getBytes());
```

**Summary**
+ If we try to write to a file that doesn’t exist, the file will be created first and no exception will be thrown (except using Path method).
+ Always close the output stream after writing the file content to release all resources. It will also help in not corrupting the file.
+ Use PrintWriter is used to write formatted text.
+ Use FileOutputStream to write binary data.
+ Use DataOutputStream to write primitive data types.
+ Use FileChannel to write larger files.

[к оглавлению](#IO)

## 24. Как прочитать данные из файла?

+ **BufferedReader**
```java
    BufferedReader br = new BufferedReader(new FileReader(file)); 
          
    String st; 
    while ((st = br.readLine()) != null) 
        System.out.println(st); 
    }
```
    
+ **FileReader**
```java
    FileReader fr = 
        new FileReader("C:\\Users\\pankaj\\Desktop\\test.txt"); 
      
    int i; 
    while ((i=fr.read()) != -1) 
    System.out.print((char) i);      
```
+ **Scanner**
```java
    Scanner sc = new Scanner(file); 
      
    // we just need to use \\Z as delimiter 
    sc.useDelimiter("\\Z"); 
      
    System.out.println(sc.next());
```
+ **Reading the whole file in a List**
```java
    data = new String(Files.readAllBytes(Paths.get(fileName)));
```

[к оглавлению](#IO)

## 25. Работа с сокетами?

Создание сервера:

```java
server = new ServerSocket(4004); // серверсокет прослушивает порт 4004
System.out.println("Сервер запущен!"); 
clientSocket = server.accept(); // accept() будет ждать пока
                
try { // установив связь и воссоздав сокет для общения с клиентом можно перейти
                    
    in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
    // и отправлять
    out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));
    String word = in.readLine(); // ждём пока клиент что-нибудь нам напишет
    System.out.println(word);
    // не долго думая отвечает клиенту
    out.write("Привет, это Сервер! Подтверждаю, вы написали : " + word + "\n");
    out.flush(); // выталкиваем все из буфера
    } finally { // в любом случае сокет будет закрыт
        System.out.println("dfjkhgkdf");
        clientSocket.close();
        // потоки тоже хорошо бы закрыть
        in.close();
        out.close();
}
```

Создание клиента:

```java
// адрес - локальный хост, порт - 4004, такой же как у сервера
clientSocket = new Socket("localhost", 4004); // этой строкой мы запрашиваем у сервера доступ на соединение
reader = new BufferedReader(new InputStreamReader(System.in));
in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); // читать соообщения с сервера
out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream())); // писать туда же

System.out.println("Вы что-то хотели сказать? Введите это здесь:");
// если соединение произошло и потоки успешно созданы - мы можем
// работать дальше и предложить клиенту что то ввести
// если нет - вылетит исключение
String word = reader.readLine(); // ждём пока клиент что-нибудь не напишет в консоль
out.write(word + "\n"); // отправляем сообщение на сервер
out.flush();
String serverWord = in.readLine(); // ждём, что скажет сервер
System.out.println(serverWord); // получив - выводим на экран
```

[к оглавлению](#IO)

## 26. Какие существуют виды потоков ввода/вывода?

Разделяют два вида потоков ввода/вывода: байтовые и символьные.

[к оглавлению](#IO)

## 27. Назовите основные предки потоков ввода/вывода?

+ Байтовые: `java.io.InputStream`, `java.io.OutputStream`;

+ Символьные: `java.io.Reader`, `java.io.Writer`;

[к оглавлению](#IO)

## 28. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?

Базовый класс `InputStream` представляет классы, которые получают данные из различных источников:
+ массив байтов;
+ строка (`String`);
+ файл;
+ канал (`pipe`) - данные помещаются с одного конца и извлекаются с другого;
+ последовательность различных потоков, которые можно объединить в одном потоке;
+ другие источники (например, подключение к интернету).

Класс `OutputStream` — это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, 
определяющие, куда направляются ваши данные: 
+ в массив байтов (но не напрямую в `String` - предполагается, что вы сможете 
создать их из массива байтов); 
+ в файл; 
+ или в канал.

Символьные потоки имеют два основных абстрактных класса `Reader` и `Writer`, управляющие потоками символов `Unicode`. 
Класс `Reader` — абстрактный класс, определяющий символьный потоковый ввод. Класс `Writer` — абстрактный класс, 
определяющий символьный потоковый вывод. В случае ошибок все методы класса передают исключение `IOException`.

[к оглавлению](#IO)

## 29. Что вы знаете о RandomAccessFile?

Класс `RandomAccessFile` наследуется напрямую от `Object` и не наследуется от вышеприведенных базовых классов ввода\вывода. 
Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому.

Работа с классом `RandomAccessFile` напоминает использование совмещенных в одном классе потоков `DataInputStream` и 
`DataOutputStream` (они реализуют те же интерфейсы `DataInput` и `DataOutput`). Кроме того, метод `seek()` позволяет 
переместиться к определенной позиции и изменить хранящееся там значение.

При использовании `RandomAccessFile` необходимо знать структуру файла. Класс `RandomAccessFile` содержит методы для 
чтения и записи примитивов и строк UTF-8.

[к оглавлению](#IO)

## 30. Какой класс надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?

Для чтения байтовых данных (не строк) применяется класс `DataInputStream`. В этом случае необходимо использовать 
классы из группы `InputStream`.

Для преобразования строки в массив байтов, пригодный для помещения в поток `ByteArrayInputStream`, в классе `String` 
предусмотрен метод `getBytes()`. Полученный `ByteArrayInputStream` представляет собой поток `InputStream`, подходящий 
для передачи `DataInputStream`.

При побайтовом чтении символов из форматированного потока `DataInputStream` методом `readByte()` любое полученное 
значение будет считаться действительным, поэтому возвращаемое значение неприменимо для идентификации конца потока. 
Вместо этого можно использовать метод `available()`, который сообщает, сколько еще осталось символов.

Класс `DataInputStream` позволяет читать элементарные данные из потока через интерфейс `DataInput`, который определяет 
методы, преобразующие элементарные значения в форму последовательности байтов. Такие потоки облегчают сохранение в 
файле двоичных данных.

Конструктор: `DataInputStream(InputStream stream);`

Методы: `readDouble()`, `readBoolean()`, `readInt()`.

[к оглавлению](#IO)

## 31. Какой класс надстройка позволяет ускорить чтение/запись за счет использования буфера?

Для этого используются классы, позволяющие буферизировать поток:
+ `java.io.BufferedInputStream(InputStream in)` || `BufferedInputStream(InputStream in, int size)`,
+ `java.io.BufferedOutputStream(OutputStream out)` || `BufferedOutputStream(OutputStream out, int size)`,
+ `java.io.BufferedReader(Reader r)` || `BufferedReader(Reader in, int sz)`,
+ `java.io.BufferedWriter(Writer out)` || `BufferedWriter(Writer out, int sz)`

[к оглавлению](#IO)

## 32. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?

`OutputStreamWriter` — мост между классом `OutputStream` и классом `Writer`. 
Символы, записанные в поток, преобразовываются в байты.

```java
OutputStream outputStream = new FileOutputStream("c:\\data\\output.txt");
Writer  outputStreamWriter = new OutputStreamWriter(outputStream, "UTF-8");
outputStreamWriter.write("Hello World");
outputStreamWriter.close();
```

`InputStreamReader` — аналог для чтения. 
При помощи методов класса `Reader` читаются байты из потока `InputStream` и далее преобразуются в символы.

```java
InputStream inputStream  = new FileInputStream("c:\\data\\input.txt");
Reader inputStreamReader = new InputStreamReader(inputStream, "UTF-8");
int data = inputStreamReader.read();
while(data != -1) {
    char theChar = (char) data;
    data = inputStreamReader.read();
}
inputStreamReader.close();
```
 
[к оглавлению](#IO)

## 33. Какой символ является разделителем при указании пути к ЭФС?

Для различных систем символ разделителя различается. Вытащить его можно используя `file.separator`, 
а также в статическом поле `File.separator`.  Для Windows это ‘\’.

[к оглавлению](#IO)

## 34. Что вы знаете об интерфейсе FilenameFilter?

Интерфейс `FilenameFilter` применяется для проверки попадает ли объект `File` под некоторое условие. 
Этот интерфейс содержит единственный метод `boolean accept(File pathName)`. 
Этот метод необходимо переопределить и реализовать.

[к оглавлению](#IO)

## 35. Что такое сериализация?

**Сериализация** - это процесс сохранения состояния объекта в последовательность байт. 

**Десериализация** - это процесс восстановления объекта, из этих байт. 

Java Serialization API предоставляет стандартный механизм для создания сериализуемых объектов.

[к оглавлению](#IO)

## 10. Что такое форматированный вывод Какие механизмы позволяют осуществить форматированный вызов?

+ %a	Шестнадцатеричное число с плавающей точкой
+ %b	Булево значение
+ %c	Символ
+ %d	Десятичное целое
+ %e	Число в научной записи
+ %f	Десятичное число с плавающей точкой
+ %h	Хеш-код от аргумента
+ %o	Восьмеричное целое
+ %n	Символ переноса строки
+ %t	Время
+ %x	Шестнадцатеричное целое

```java
String output = String.format("%s = %d", "joe", 35);
String.format(); Formatter
```

Можно создать `Formatter` и привязать его к `StrungBuilder`:
```java
StringBuilder sbuf = new StringBuilder();
Formatter fmt = new Formatter(sbuf);
fmt.format("PI = %f%n", Math.PI);
System.out.print(sbuf.toString());
```
Также есть свое форматирование для вывода дат.
Можно задавать выравнивание, количество отступов:
```java
String.format("|%-20d|", 93); // prints: |93                  |
String.format("|%020d|", 93); // prints: |00000000000000000093|
```

[к оглавлению](#IO)

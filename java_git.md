## Основы Git

[1. Что такое индекс?](#1-Что-такое-индекс)

[2. Как добавить изменения в индекс?](#2-Как-добавить-изменения-в-индекс)

[3. Как сделать фиксацию изменений?](#3-Как-сделать-фиксацию-изменений)

[4. Как сделать синхронизацию изменений с удаленным репозиторием?](#1-Как-сделать-синхронизацию-изменений-с-удаленным-репозиторием)

[5. Как-синхронизироваться-с-удаленным-репозиторием?](#5-Как-синхронизироваться-с-удаленным-репозиторием)

[6. Как сделать ветку?](#6-Как-сделать-ветку)

[7. Как переключиться между ветками?](#7-Как-переключиться-между-ветками)

[8. Как отменить локальные изменения?](#8-Как-отменить-локальные-изменения)

[9. Расскажи о команде git reset?](#9-Расскажи-о-команде-git-reset)

[10. Расскажите о команде git stash?](#10-Расскажите-о-команде-git-stash)

[11. Расскажите о команде git cherry-pick?](#11-Расскажите-о-команде-git-cherry-pick)

[12. Расскажите, о команде git rerere. Расскажите, как разрешаются конфликты](#12-Расскажите-о-команде-git-rerere-Расскажите-как-разрешаются-конфликты)

## 1. Что такое индекс?

Индекс — промежуточное место между вашим прошлым коммитом и следующим. Вы можете добавлять или удалять файлы из индекса. Когда вы делаете коммит в него попадают данные из индекса, а не из рабочей области.

Индекс в Git — это временное хранилище, в котором содержатся изменения файлов, подготовленные для коммита. Он позволяет контролировать набор файлов, которые будут включены в следующий коммит, а также позволяет подготавливать сложные коммиты, состоящие из нескольких патчей.

Что бы просмотреть индекс, используйте git status.

Что бы удалить файлы из индекса вы можете использовать 2 команды git reset и git restore.
git-restore — восстановит файлы рабочего дерева.
git-reset — сбрасывает текущий HEAD до указанного состояния.
По сути вы можете добиться одного и того же с помощью обеих команд.

Что бы удалить из индекса некоторые файлы используйте:
```java
git restore --staged <file>
```
таким образом вы восстановите ваш индекс (или точнее удалите конкретные файлы из индекса), будто бы git add после последнего коммита не выполнялся для них. С помощью этой команды вы можете восстановить и рабочую директорию, что бы она выглядела так, будто бы после коммита не выполнялось никаких изменений. Вот только эта команда имеет немного странное поведение — если вы добавили в индекс новую версию вашего файла вы не можете изменить вашу рабочую директорию, пока индекс отличается от HEAD. Поэтому вам сначала нужно восстановить ваш индекс и только потом рабочую директорию. К сожалению сделать это одной командой не возможно так как при передаче обеих аргументов (git restore -SW) не происходит ничего. И точно также при передаче -W тоже ничего не произойдет если файл в индексе и HEAD разный. Наверное, это сделали для защиты что бы вы случайно не изменили вашу рабочую директорию. Но в таком случае почему аргумент -W передаётся по умолчанию? В общем мне не понятно зачем было так сделано и для чего вообще была добавлена эта команда. По мне так reset справляется с этой задачей намного лучше, да и еще и имеет более богатый функционал так как может перемещать индекс и рабочую директорию не только на последний коммит но и на любой другой.

Но собственно разработчики рекомендуют для сброса индекса использовать именно git restore -S . Вместо git reset HEAD .

С помощью git status вы можете посмотреть какие файлы изменились но если вы также хотите узнать что именно изменилось в файлах то воспользуйтесь командой:
```java
git diff [<options>]
```
таким образом выполнив команду без аргументов вы можете сравнить ваш индекс с рабочей директорией. Если вы уже добавил в индекс файлы, то используйте git diff --cached что бы посмотреть различия между последним коммитом (или тем который вы укажите) и рабочей директории. Вы также можете посмотреть различия между двумя коммитами или ветками передав их как аргумент. Пример: git diff 00656c 3d5119 покажет различия между коммитом 00656c и 3d5119.

## 2. Как добавить изменения в индекс?

Git add - это команда, используемая в системе контроля версий Git, предназначенная для добавления файлов в индекс текущей ветки. Это означает, что изменения, которые будут внесены в эти файлы, будут отслеживаться и впоследствии объединены в коммит.

Добавление файлов в Git индекс позволяет контролировать изменения в коде и упрощает процесс управления ими. Когда файлы добавляются в индекс, Git запоминает их состояние. Это позволяет разработчикам подготавливать набор файлов для коммита, даже если они не завершили работу над всеми изменениями.

Команда git add может быть использована с флагом -u для добавления только тех файлов, которые были изменены с момента последнего коммита или слития. Это помогает сэкономить время при работе с большим количеством файлов и сконцентрироваться на тех, которые действительно были изменены.

Важно отметить, что Git не отслеживает временные файлы или файлы, которые не были добавлены в Git индекс. Это делает git add необходимой командой для каждого разработчика, работающего с Git.

Что бы добавить файлы в индекс для отслеживания используйте

```java
git add [<опции>]
```
Полезные параметры команды git add:

* -f, --force — добавить также игнорируемые файлы
* -u, --update — обновить отслеживаемые файлы

**Примеры**

Предположим, у вас есть проект с несколькими файлами и вы хотите добавить их все в индекс для последующего коммита. Вы можете сделать это, выполнив команду:

git add .
Эта команда добавит все файлы и папки из текущей директории в Git индекс. Если вы хотите добавить только определенные файлы, вы можете использовать маску файла или перечислить их вручную. Например, чтобы добавить все файлы с расширением .py, вы можете выполнить:

git add *.py
Это очень полезно, если у вас есть много файлов, которые вы не хотите добавлять в индекс все сразу.

## 3. Как сделать фиксацию изменений?

git commit -m "text"

Теперь, когда ваш индекс находится в нужном состояний, пора сделать коммит ваших изменений. Запомните, что все файлы для которых вы не выполнили git add после момента редактирования — не войдут в этот коммит. На деле файлы в нём будут, но только их старая версия (если таковая имеется).

Для того чтобы сделать фиксацию (commit) изменений в Git, нужно выполнить следующие шаги:

1. Добавить файлы в индекс с помощью команды “git add”.
2. Зафиксировать изменения в индексе в виде коммита с помощью команды “git commit”.
3. Отправить изменения на удаленный репозиторий с помощью команд “git push”.
4. Процесс выглядит следующим образом:

Сначала вы добавляете файлы в индекс (с помощью команды git add), чтобы Git знал, какие файлы были изменены и готовы к коммиту.
Затем вы фиксируете изменения в индексе (с помощью команды git commit), создавая новый коммит с вашими изменениями.
Наконец, вы отправляете изменения на удаленный репозиторий (с помощью команд git push), чтобы другие разработчики могли получить доступ к вашим изменениям.

Для того что бы сделать коммит ваших изменений используйте:

```java
git commit [<опции>]
```

Полезные опции команды git commit:

-F, --file [file] — Записать сообщение коммита из указанного файла

--author [author] — Подменить автора коммита

--date [date] — Подменить дату коммита

-m, --mesage [message] — Сообщение коммита

-a, --all — Закоммитеть все изменения в файлах

-i, --include [files...] — Добавить в индекс указанные файлы для следующего коммита

-o, --only [files...] — Закоммитеть только указанные файлы

--amend — Перезаписать предыдущий коммит

Вы можете определить сообщение для коммита по умолчанию с помощью commit.template. Эта директива в конфигурационном файле отвечает за файл содержимое которого будет использоваться для коммита по умолчанию. Пример: git config --global commit.template ~/.gitmessage.txt.

Вы также можете изменить, удалить, объединить любой коммит.
Как вы уже могли заметить вы можете быстро перезаписать последний коммит с помощью git commit --amend.
Для изменения коммитом в вашей истории используйте

git rebase -i <commit>

где commit это верхний коммит в вашей цепочке с которого вы бы хотели что либо изменить.

После выполнения git rebase -i в интерактивном меню выберите что вы хотите сделать.

pick <коммит> = использовать коммит
reword <коммит> = использовать коммит, но изменить сообщение коммита
edit <коммит> = использовать коммит, но остановиться для исправления
squash <коммит> = использовать коммит, но объединить с предыдущим коммитом
fixup <коммит> = как «squash», но пропустить сообщение коммита
exec <команда> = выполнить команду (остаток строки) с помощью командной оболочки
break = остановиться здесь (продолжить с помощью «git rebase --continue»)
drop <коммит> = удалить коммит
label <метка> = дать имя текущему HEAD
reset <метка> = сбросить HEAD к указанной метке

Для изменения сообщения определённого коммита.
Необходимо изменить pick на edit над коммитом который вы хотите изменить.
Пример: вы хотите изменить сообщение коммита 750f5ae.

pick 2748cb4 first commit
edit 750f5ae second commit
pick 716eb99 third commit

После сохранения скрипта вы вернётесь в командную строку и git скажет что необходимо делать дальше:

Остановлено на 750f5ae … second commit
You can amend the commit now, with

git commit --amend

Once you are satisfied with your changes, run

git rebase --continue

Как указанно выше необходимо выполнить git commit --amend для того что бы изменить сообщение коммита. После чего выполнить git rebase --continue. Если вы выбрали несколько коммитов для изменения названия то данные операций необходимо будет проделать над каждым коммитом.

Для удаления коммита
Необходимо удалить строку с коммитом.
Пример: вы хотите удалить коммит 750f5ae
Нужно изменить скрипт с такого:
pick 2748cb4 third commit
pick 750f5ae second commit
pick 716eb99 first commit
на такой:
pick 2748cb4 first commit
pick 716eb99 third commit

Для объединения коммитов
Необходимо изменить pick на squash над коммитами которые вы хотите объединить.
Пример: вы хотите объединить коммиты 750f5ae и 716eb99.
Необходимо изменить скрипт с такого:
pick 2748cb4 third commit
pick 750f5ae second commit
pick 716eb99 first commit
На такой
pick 2748cb4 third commit
squash 750f5ae second commit
squash 716eb99 first commit

Заметьте что в интерактивном скрипте коммиты изображены в обратном порядке нежели в git log. С помощью squash вы объедините коммит 750f5ae с 716eb99, а 750f5ae с 2748cb4. В итоге получая один коммит содержащий изменения всех трёх.

## 4. Как сделать синхронизацию изменений с удаленным репозиторием?

Для синхронизации изменений с удаленным репозиторием необходимо выполнить следующие команды:

– git push - отправить свои локальные изменения на удаленный репозиторий.

Эти команды обычно выполняются после добавления и фиксации изменений в вашем локальном репозитории.

Когда и зачем нужно делать push?
После серии коммитов с ключевыми изменениями нужно обновить кодовую базу в удаленном репозитории. Для этого есть две причины:

* Сохранение резервной копии на сервере на случай потери данных на локальной машине.
* Отправка изменений членам команды разработки для синхронизации кодовой базы

```java
git push origin master
```

## 5. Как синхронизироваться с удаленным репозиторием? 

Для синхронизации изменений с удаленным репозиторием необходимо выполнить следующие команды:

– git pull - обновить свой локальный репозиторий новыми изменениями из удаленного репозитория.

```java
git pull origin master
```

Команда ‘**git pull origin master**’ используется для обновления вашего локального репозитория новыми изменениями из удаленного репозитория ‘**origin**’ до ветки ‘master’. Эта команда сначала выполняет **‘git fetch origin’**, которая загружает новые коммиты из удаленного репозитория, а затем ‘**git merge**’, который объединяет эти коммиты с вашей текущей веткой.

* Команда **git fetch origin** загружает все коммиты из удалённого репозитория origin в ваш локальный репозиторий, но ещё не объединяет их с вашей текущей веткой. Она сохраняет информацию о новых коммитах в файле .git/refs/remotes/origin, но не обновляет локальную ветку master.

* Команда **git merge** объединяет два коммита, обычно один из них является последним коммитом в удалённом репозитории, а другой — вашим текущим коммитом. В результате получается новый коммит, который содержит изменения из обоих исходных коммитов.

## 6. Как сделать ветку?

Для создания новой ветки используется команда **git branch hotfix**

Опции git branch:

* -r | -a [--merged | --no-merged] — Список отслеживаемых внешних веток -r. Список и отслеживаемых и локальных веток -a. Список слитых веток --merged. Список не слитых веток --no-merged.
* -l, -f <имя-ветки> [<точка-начала>] — Список имён веток -l. Принудительное создание, перемещение или удаление ветки -f. Создание новой ветки <имя ветки>.
* -r (-d | -D) — Выполнить действие на отслеживаемой внешней ветке -r. Удалить слитую ветку -d. Принудительное удаление (даже не слитой ветки) -D.
* -m | -M [<Старая ветка>] <Новая ветка> — Переместить/переименовать ветки и ее журнал ссылок (-m). Переместить/переименовать ветку, даже если целевое имя уже существует -M.
* (-с | -С) [<старая-ветка>] <новая-ветка> — Скопировать ветку и её журнал ссылок -c. Скопировать ветку, даже если целевое имя уже существует -C.
* -v, -vv — Список веток с последним коммитом на ветке -v. Список и состояние отслеживаемых веток с последним коммитом на них.

Можно создать ветку через IDEA: 
В правом нижнем углу есть меню с указанием текущей ветки.

![image](https://github.com/artemaverin/summary/assets/97846877/ec184706-a40f-4703-99d7-4d3f22a3d052)

Кликнув на стрелочку откроется меню, где можно увидеть все доступный ветки.

![image](https://github.com/artemaverin/summary/assets/97846877/5f101a98-12e3-4ff2-a202-0fd830950047)

В этом же меню есть пункт + New branch.

![image](https://github.com/artemaverin/summary/assets/97846877/c43e36b5-f2c5-4e39-8051-3199974ec708)

Кликнув на этот пункт откроется диалоговое окно. Оно нужно для ввода имени новой ветки.

Давайте создадим ветку hotfix_139840.

![image](https://github.com/artemaverin/summary/assets/97846877/5149ed45-7060-4a46-a14c-c7de850e8e85)

Галка checkout branch - говорит о том, что после создания ветки, линия разработки переключится в новосозданную ветку.
- ----------

Если вы хотите создать ветку удаленно на GitHub или другом сервисе, вам нужно будет использовать соответствующие команды git push с опцией --set-upstream для указания основной ветки, на которую вы хотите пушить изменения.

## 7. Как переключиться между ветками?

Для переключения между ветками в Git нужно выполнить следующие шаги:

- Откройте терминал или командную строку и перейдите в каталог, где находится ваш репозиторий Git.
- Введите команду git branch для просмотра списка всех веток в вашем репозитории.
- Чтобы переключиться на определенную ветку, введите команду git checkout ИМЯ_ВЕТКИ, где ИМЯ_ВЕТКИ - это название ветки, на которую вы хотите переключиться.
- После выполнения команды git checkout вы окажетесь на выбранной ветке и сможете продолжить работу с ней.
- Обратите внимание, что при переключении на другую ветку все изменения, которые вы не зафиксировали, будут потеряны. Чтобы избежать этого, перед переключением на другую ветку убедитесь, что все ваши изменения сохранены в локальной истории коммитов.

## 8. Как отменить локальные изменения?

https://job4j.ru/profile/exercise/180/task-view/910

Если вы хотите отменить все локальные изменения, которые еще не были добавлены в индекс, вы можете использовать команду git reset.

Используя различные опций этой команды вы можете:

* --soft — Cбросить только HEAD
* --mixed — Cбросить HEAD и индекс
* --hard — Cбросить HEAD, индекс и рабочий каталог

Под сбросить понимается переместить на указанный коммит. По умолчанию выполняется --mixed.

Примеру 1. Вы сделали 3 лишних коммита каждый из которых приносит маленькие изменения и вы хотите сделать из них один, таким образом вы можете с помощью git reset --soft переместить указатель HEAD при этом оставив индекс и рабочий каталог нетронутым и сделать коммит. В итоге в вашей истории будет выглядеть так, что все изменения произошли в одном коммите.

Пример 2. Вы добавили в индекс лишние файлы и хотите их от туда убрать. Для этого вы можете использовать git reset HEAD <files...>. Или вы хотите что бы в коммите файлы выглядели как пару коммитов назад. Как я уже говорил ранее вы можете сбросить индекс на любой коммит в отличий от git restore который сбрасывает только до последнего коммита. Только с опцией mixed вы можете применить действие к указанному файлу!

Пример 3. Вы начали работать над новой фичей на вашем проекте, но вдруг работодатель говорит что она более не нужна и вы в порыве злости выполняете git reset --hard возвращая ваш индекс, файлы и HEAD к тому моменту когда вы ещё не начали работать над фичей. А на следующей день вам говорят, что фичу всё таки стоит запилить. Но что же делать? Как же переместится вперёд ведь вы откатили все 3 дерева и теперь в истории с помощью git log их не найти. А выход есть — это журнал ссылок git reflog. С помощью этой команды вы можете посмотреть куда указывал HEAD и переместится не только вниз по истории коммитов но и вверх. Этот журнал является локальным для каждого пользователя.

## 9. Расскажи о команде git reset?

Команда git reset используется для сброса текущего состояния репозитория до предыдущего состояния. Она может использоваться для отмены изменений, удаления файлов из индекса или перемещения HEAD в другую позицию.

Существует несколько опций команды git reset:

– git reset --soft - сбрасывает состояние файлов, но сохраняет все коммиты и их порядок в истории.
– git reset --mixed - сбрасывает состояние файлов и удаляет все незакоммиченные изменения из индекса.
– git reset --hard - полностью сбрасывает текущее состояние репозитория, удаляя все незакоммиченные изменения и коммиты, которые не являются родительскими для других коммитов.

## 10. Расскажите о команде git stash

https://job4j.ru/profile/exercise/180/task-view/912

git stash - это команда, которая временно сохраняет все локальные изменения и позволяет переключиться на другую ветку или выполнить другие задачи, а затем вернуться к исходной ветке и продолжить работу с сохраненными изменениями.

Она может быть полезна, когда вы работаете над задачей и хотите временно переключиться на другую задачу, но не хотите потерять свою работу. git stash сохраняет все изменения, и вы можете вернуться к ним позже, когда будете готовы продолжить работу.

**git stash** — одна из самых восхитительных и полезных Git-команд. Она регистрирует все изменения, вносимые в отслеживаемый файл в вашем рабочем дереве, и скрывает их для последующего использования, а вам показывает чистое дерево, чтобы вы могли спокойно работать с другой его частью. Но если вы создали новые файлы и ещё не проиндексировали их, то по умолчанию git stash их не тронет, поэтому у вас будет неопрятное рабочее дерево. Соответственно, по умолчанию не скрывается и содержимое неотслеживаемых или игнорируемых файлов.

## 11. Расскажите о команде git cherry-pick

Команда git cherry-pick используется для применения определенного коммита из одной ветки репозитория в другую. Это может быть полезно, если вы хотите применить изменения из одного коммита в другой коммит, не объединяя их в один коммит.

Команда git cherry-pick имеет следующий синтаксис:

git cherry-pick SHA-1 коммита

где SHA-1 - это уникальный идентификатор коммита, который вы хотите применить.

После выполнения этой команды, git применит изменения из указанного коммита к текущему коммиту, который вы создаете.
- -----------

Команда git cherry-pick создаёт новый коммит с идентичным отличием от <oid>, родитель которого — текущий коммит. Git в сущности выполняет такие шаги:

Вычисляет разницу между <oid> коммита и его родителя.

Применяет различие к текущему HEAD.

Создаёт новый коммит, корневое дерево которого соответствует новому рабочему каталогу, а родитель созданного коммита — HEAD.

Перемещает ссылку HEAD в этот новый коммит.

![image](https://github.com/artemaverin/summary/assets/97846877/40f5c2c3-117b-45f6-81fa-7dcd1b173387)

После создания нового коммита вывод git log -1 -p HEAD должен совпадать с выводом git log -1 -p <oid>.

Важно понимать, что мы не "перемещали" коммит так, чтобы он был поверх нашего текущего HEAD, мы создали новый коммит, и его вывод diff совпадает со старым коммитом.

## 12. Расскажите, о команде git rerere. Расскажите, как разрешаются конфликты.

Команда git rerere используется для разрешения повторяющихся конфликтов. Когда вы сталкиваетесь с конфликтом при слиянии двух веток, git сохраняет информацию о конфликте, чтобы в следующий раз, когда вы столкнетесь с таким же конфликтом, он мог автоматически его разрешить.

Чтобы использовать git rerere, вам нужно включить его в своем конфигурационном файле, добавив следующую строку: **rerere.enabled true**

После этого, когда вы сталкиваетесь с конфликтом, git сохраняет информацию о нем и в следующий раз, когда вы столкнетесь с таким же конфликтом, он сможет его автоматически разрешить.
- ---------------

Rerere — «reuse recorded resolution” — “повторное использование сохраненных разрешений конфликтов». Механизм rerere способен запомнить каким образом вы разрешали некую часть конфликта в прошлом и провести автоматическое исправление конфликта при возникновении его в следующий раз.

Что бы включить rerere выполните

```java
git config --global rerere.enabled true
```

Таrже вы можите включить rerere создав каталог .git/rr-cache в нужном репозитории.

Используйте git rerere status для того что бы посмотреть для каких файлов rerere сохранил снимки состояния до начала слияния.

Используйте git rerere diff для просмотра текущего состояния конфликта.

Если во время слияния написано: Resolved 'nameFile' using previous resolution. Значит rerere уже устранил конфликт используя кэш.

Для отмены автоматического устранения конфликта используйте git checkout --conflict=merge таким образом вы отмените авто устранение конфликта и вернёте файл(ы) в состояние конфликта для ручного устранения.

## Прочее

![image](https://github.com/artemaverin/summary/assets/97846877/54f4eadb-fc84-4eff-a7c1-7f7ae4ae79d8)

https://stackoverflow.com/questions/59441589/how-is-repository-different-from-workspace

https://docs.github.com/ru

https://git-scm.com/book/ru/v2

## Вопросы:

**С помощью какой команды можно создать пустой репозиторий Git или вновь инициализировать существующий?**

git init

**С помощью какой команды можно добавить отдельный файл в область подготовленных файлов?**

git add имя_файла

**С помощью какой команды можно добавить все файлы и папки в область подготовленных файлов?**

git add .

**С помощью какой команды можно совершить коммит?**

git commit

**С помощью какого флага можно добавить однострочное сообщение при создании коммита?**

-m

**С помощью какой команды можно просмотреть полный список изменений, внесённых конкретным коммитом, указав идентификатор или хеш коммита?**

git show идентификатор

**С помощью какой команды можно просматривать список внесенных в репозиторий изменений, НЕ подготовленных для фиксации?**

git diff

**С помощью какой команды можно просматривать список внесенных в репозиторий изменений, подготовленных для фиксации?**

git diff --staged ??

**С помощью какой команды можно перевести подготовленный файл в состояние не подготовленного к коммиту?**

git reset

**С помощью какой команды можно откатить уже сделанный коммит?**

git revert

**В чем разница между командами git reset и git revert?**

- git revert отменяет изменения, записанные только одним коммитом. Не меняет историю проекта и производит операцию, безопасную для коммитов. Объектом выступает конкретный коммит, созданный в любой момент истории

- git reset откатывает проект к более раннему состоянию, удаляя все последующие коммиты. При отмене через git reset придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно.

**С помощью какой команды можно создать новую ветку?**

git branch имя_ветки

**С помощью какой команды можно просмотреть список всех веток?**

git branch

**С помощью какой команды можно переключиться в другую ветку?**

git checkout имя_ветки

**С помощью какой команды можно удалить ветку в локальном репозитории?**

git branch -d имя_ветки

**С помощью какой команды можно удалить ветку в удаленном репозитории?**

git push origin --delete имя ветки

**С помощью какой команды можно объединить 2 ветки?**

git merge имя_ветки

**С помощью какой команды можно добавить удаленный репозиторий?**

git remote add имя_репозитория ссылка_на_репозиторий 

**С помощью какой команды можно просмотреть удаленные URL-адреса?**

git remote -v

**С помощью какой команды можно отправить изменения в удаленный репозиторий?**

git push

**С помощью какой команды можно загрузить изменения из удалённого репозитория и объединить их с локальной копией?**

git pull

**С помощью какой команды можно выполнить слияние удалённого репозитория с локальным?**

git merge имя_удаленного_репозитория

**С помощью какой команды можно передать новую ветку в удалённый репозиторий?**

git push -u имя_удаленного_репозитория имя_новой_ветки

**С помощью какой команды можно соединить 2 ветки последовательно?**

git rebase ??

**С помощью какой команды можно перенести коммит из одной ветки в другую?**

git cherry-pick

**С помощью какой команды можно запомнить способ разрешения конфликтов?**

git rerere

**С помощью какой команды можно загрузить изменения из удалённого репозитория без объединения с локальной копией?**

git fetch

**Верно ли утверждение: git fetch + get merge = git pull?**

ДА

**С помощью какой команды можно откатить изменения к конкретному коммиту с возвратом и объединением идущих после него коммитов в область подготовленных файлов?**

git reset --soft

**С помощью какой команды можно временно скрыть внесенные изменения и создать чистую рабочую копию?**

git stash

- -------------------------

**Настройка**

git config --global user.name "Artem Averin"

git config --global user.nemail "artem@mail.ru"

**Создание репозитория**

git cd "путь к папке"

git init - создание локального репозитория

git remote origin [url удаленного репозитория с github]

![image](https://github.com/artemaverin/summary/assets/97846877/4cf75b46-291a-49fa-b683-06fc2f32ecac)

git clone [url удаленного реп] - создание локального репозитория полностью кпирующий удаленный

![image](https://github.com/artemaverin/summary/assets/97846877/6584ac77-cab4-4892-b347-8aee9ff94305)

**внесение изменений**

git status - выведет всю информацию о файлах чью версию мы изменили, но еще не сохранили эти изменения внутри гита

git add - подготавливает данные файла к следующему коммиту, добавляя их в индекс гита. Индекс гита - хранилище файлов готовых к коммиту

git commit -m - запоминает версию (комит) всех файлов в репозитории из индекса и присваивает ей уникальныйх хэшкод, по которой затем к ней можно вернуться

![image](https://github.com/artemaverin/summary/assets/97846877/cfb58a10-2bf1-4068-9cc8-5291ae54aa61)

git log - показывает история всех коммитов в данной ветке с их хэшами и сообщениями

git checkout [хэш комита] - перейти к указанному комиту

![image](https://github.com/artemaverin/summary/assets/97846877/d22dd234-7f16-45e4-8e17-25ee0cdf5a4e)

git push [имя репозиория=origin] [ветка=master] - публикует комиты из локального репозиория в удаленый

git pull [имя репозиория=origin] [ветка=master] - скачивает из удаленного репозитория все комиты которых еще нет в локальном

![image](https://github.com/artemaverin/summary/assets/97846877/87f16b08-a438-4772-9077-8b3758adaebf)

**ветки**

Ветка - это последовательность комитов , которая имеет название

![image](https://github.com/artemaverin/summary/assets/97846877/a9a5dd04-360a-442b-a226-3074f340f7f7)

git branch - список всех веток в локальном репозитории

git branch -r  - список всех веток в удаленном репозитории

git branch [имя ветки] - создание новой ветки

git checkout [имя ветки] - переключает на данную локальную ветку

**слияние**

git checkout [имя ветки в которую мы хотим слить изменения]

git merge [имя ветки из которой берем изменения] - производит слияние веток

![image](https://github.com/artemaverin/summary/assets/97846877/3edebe82-4bf2-4e51-b2b5-729e3ddaf30b)

итог merge можно посмотреть в git log

далее нужно сделать push в удаленный репозиторий

_**2 способ**_:

git checkout [имя ветки в которую мы хотим слить изменения]

git rebase [имя ветки из которой хотим перенести] - переносит все изменения со всей историей

![image](https://github.com/artemaverin/summary/assets/97846877/cd3aa0ac-68a8-4c94-a794-6927331badbd)

**Pull/Merge request**

Pull/Merge request - запрос на слияние из вашей feature ветки в в любую другую ветку

![image](https://github.com/artemaverin/summary/assets/97846877/8d57547b-d186-48a0-bfbf-39cdfdca5638)

![image](https://github.com/artemaverin/summary/assets/97846877/fcf8cf6e-da43-4077-bafb-9c21face85e5)

**cherry-pick**

![image](https://github.com/artemaverin/summary/assets/97846877/035dc6ff-3347-425b-ba98-da8bd4a7de56)

git cherry-pick [хэш нужного комита] — это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD. С ее помощью можно выбрать коммит из одной ветки и применить его к другой.

**git revert/reset**

git revert [хэш коммита] - удаление всех предыдущих изменений конкретного коммита, в виде нового комита с этой отмены в вашей ветке

![image](https://github.com/artemaverin/summary/assets/97846877/cc0f35fc-ccf5-4029-b650-71bccca4abb7)

git reset [soft/mixed/hard] [хэш комита до которого нужно удалять ненужные комиты] - 

git reset --soft [hash] - удалит коммиты(не увидим их уже в истории), но в ворспейс все изменения останутся, и останутся в индексе, в состоянии предкомита

git reset --hard [hash] - изменения удаляются из истории, индекас и воркспейса
